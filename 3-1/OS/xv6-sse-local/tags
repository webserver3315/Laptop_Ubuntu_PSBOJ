!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALT	dist/kbd.h	11;"	d
ALT	kbd.h	11;"	d
AS	Makefile	/^AS = $(TOOLPREFIX)gas$/;"	m
AS	dist/Makefile	/^AS = $(TOOLPREFIX)gas$/;"	m
ASFLAGS	Makefile	/^ASFLAGS = -m32 -gdwarf-2 -Wa,-divide$/;"	m
ASFLAGS	dist/Makefile	/^ASFLAGS = -m32 -gdwarf-2 -Wa,-divide$/;"	m
ASSERT	dist/lapic.c	25;"	d	file:
ASSERT	lapic.c	25;"	d	file:
Align	dist/umalloc.c	/^typedef long Align;$/;"	t	file:
Align	umalloc.c	/^typedef long Align;$/;"	t	file:
BACK	dist/sh.c	12;"	d	file:
BACK	sh.c	12;"	d	file:
BACKSPACE	console.c	127;"	d	file:
BACKSPACE	dist/console.c	125;"	d	file:
BBLOCK	dist/fs.h	48;"	d
BBLOCK	fs.h	48;"	d
BCAST	dist/lapic.c	28;"	d	file:
BCAST	lapic.c	28;"	d	file:
BIG	dist/usertests.c	1452;"	d	file:
BIG	usertests.c	1452;"	d	file:
BPB	dist/fs.h	45;"	d
BPB	fs.h	45;"	d
BSIZE	dist/fs.h	6;"	d
BSIZE	fs.h	6;"	d
BUSY	dist/lapic.c	29;"	d	file:
BUSY	lapic.c	29;"	d	file:
B_DIRTY	buf.h	13;"	d
B_DIRTY	dist/buf.h	13;"	d
B_VALID	buf.h	12;"	d
B_VALID	dist/buf.h	12;"	d
C	console.c	189;"	d	file:
C	dist/console.c	187;"	d	file:
C	dist/kbd.h	32;"	d
C	kbd.h	32;"	d
CAPSLOCK	dist/kbd.h	13;"	d
CAPSLOCK	kbd.h	13;"	d
CC	Makefile	/^CC = $(TOOLPREFIX)gcc$/;"	m
CC	dist/Makefile	/^CC = $(TOOLPREFIX)gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer$/;"	m
CFLAGS	dist/Makefile	/^CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer$/;"	m
CMOS_PORT	dist/lapic.c	122;"	d	file:
CMOS_PORT	lapic.c	123;"	d	file:
CMOS_RETURN	dist/lapic.c	123;"	d	file:
CMOS_RETURN	lapic.c	124;"	d	file:
CMOS_STATA	dist/lapic.c	162;"	d	file:
CMOS_STATA	lapic.c	163;"	d	file:
CMOS_STATB	dist/lapic.c	163;"	d	file:
CMOS_STATB	lapic.c	164;"	d	file:
CMOS_UIP	dist/lapic.c	164;"	d	file:
CMOS_UIP	lapic.c	165;"	d	file:
COM1	dist/uart.c	15;"	d	file:
COM1	uart.c	15;"	d	file:
CONSOLE	dist/file.h	37;"	d
CONSOLE	file.h	37;"	d
CONV	dist/lapic.c	216;"	d	file:
CONV	dist/lapic.c	223;"	d	file:
CONV	kernel.asm	/^#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))$/;"	d
CONV	lapic.c	217;"	d	file:
CONV	lapic.c	224;"	d	file:
CPUS	Makefile	/^CPUS := 1$/;"	m
CPUS	dist/Makefile	/^CPUS := 1$/;"	m
CR0_PE	dist/mmu.h	8;"	d
CR0_PE	mmu.h	8;"	d
CR0_PG	dist/mmu.h	10;"	d
CR0_PG	mmu.h	10;"	d
CR0_WP	dist/mmu.h	9;"	d
CR0_WP	mmu.h	9;"	d
CR4_PSE	dist/mmu.h	12;"	d
CR4_PSE	mmu.h	12;"	d
CRTPORT	console.c	128;"	d	file:
CRTPORT	dist/console.c	126;"	d	file:
CTL	dist/kbd.h	10;"	d
CTL	kbd.h	10;"	d
DAY	dist/lapic.c	169;"	d	file:
DAY	lapic.c	170;"	d	file:
DEASSERT	dist/lapic.c	26;"	d	file:
DEASSERT	lapic.c	26;"	d	file:
DELIVS	dist/lapic.c	24;"	d	file:
DELIVS	lapic.c	24;"	d	file:
DEVSPACE	dist/memlayout.h	5;"	d
DEVSPACE	memlayout.h	5;"	d
DIRSIZ	dist/fs.h	51;"	d
DIRSIZ	fs.h	51;"	d
DPL_USER	dist/mmu.h	53;"	d
DPL_USER	mmu.h	53;"	d
Disassembly	bootblock.asm	/^Disassembly of section .text:$/;"	l
Disassembly	cat.asm	/^Disassembly of section .text:$/;"	l
Disassembly	echo.asm	/^Disassembly of section .text:$/;"	l
Disassembly	entryother.asm	/^Disassembly of section .text:$/;"	l
Disassembly	forktest.asm	/^Disassembly of section .text:$/;"	l
Disassembly	getnice.asm	/^Disassembly of section .text:$/;"	l
Disassembly	grep.asm	/^Disassembly of section .text:$/;"	l
Disassembly	init.asm	/^Disassembly of section .text:$/;"	l
Disassembly	initcode.asm	/^Disassembly of section .text:$/;"	l
Disassembly	kernel.asm	/^Disassembly of section .text:$/;"	l
Disassembly	kill.asm	/^Disassembly of section .text:$/;"	l
Disassembly	ln.asm	/^Disassembly of section .text:$/;"	l
Disassembly	ls.asm	/^Disassembly of section .text:$/;"	l
Disassembly	mkdir.asm	/^Disassembly of section .text:$/;"	l
Disassembly	ps.asm	/^Disassembly of section .text:$/;"	l
Disassembly	rm.asm	/^Disassembly of section .text:$/;"	l
Disassembly	setnice.asm	/^Disassembly of section .text:$/;"	l
Disassembly	sh.asm	/^Disassembly of section .text:$/;"	l
Disassembly	stressfs.asm	/^Disassembly of section .text:$/;"	l
Disassembly	swaptest.asm	/^Disassembly of section .text:$/;"	l
Disassembly	test1.asm	/^Disassembly of section .text:$/;"	l
Disassembly	test2.asm	/^Disassembly of section .text:$/;"	l
Disassembly	testcase1.asm	/^Disassembly of section .text:$/;"	l
Disassembly	testcase2.asm	/^Disassembly of section .text:$/;"	l
Disassembly	usertests.asm	/^Disassembly of section .text:$/;"	l
Disassembly	wc.asm	/^Disassembly of section .text:$/;"	l
Disassembly	zombie.asm	/^Disassembly of section .text:$/;"	l
E0ESC	dist/kbd.h	17;"	d
E0ESC	kbd.h	17;"	d
ELF_MAGIC	dist/elf.h	3;"	d
ELF_MAGIC	elf.h	3;"	d
ELF_PROG_FLAG_EXEC	dist/elf.h	40;"	d
ELF_PROG_FLAG_EXEC	elf.h	40;"	d
ELF_PROG_FLAG_READ	dist/elf.h	42;"	d
ELF_PROG_FLAG_READ	elf.h	42;"	d
ELF_PROG_FLAG_WRITE	dist/elf.h	41;"	d
ELF_PROG_FLAG_WRITE	elf.h	41;"	d
ELF_PROG_LOAD	dist/elf.h	37;"	d
ELF_PROG_LOAD	elf.h	37;"	d
EMBRYO	dist/proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
EMBRYO	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
ENABLE	dist/lapic.c	19;"	d	file:
ENABLE	lapic.c	19;"	d	file:
EOI	dist/lapic.c	17;"	d	file:
EOI	lapic.c	17;"	d	file:
ERROR	dist/lapic.c	38;"	d	file:
ERROR	lapic.c	38;"	d	file:
ESR	dist/lapic.c	20;"	d	file:
ESR	lapic.c	20;"	d	file:
EXEC	dist/sh.c	8;"	d	file:
EXEC	sh.c	8;"	d	file:
EXTMEM	dist/memlayout.h	3;"	d
EXTMEM	memlayout.h	3;"	d
EXTRA	Makefile	/^EXTRA=\\$/;"	m
FD_INODE	dist/file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon9
FD_INODE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon1
FD_NONE	dist/file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon9
FD_NONE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon1
FD_PIPE	dist/file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon9
FD_PIPE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon1
FILES	Makefile	/^FILES = $(shell grep -v '^\\#' runoff.list)$/;"	m
FILES	dist/Makefile	/^FILES = $(shell grep -v '^\\#' runoff.list)$/;"	m
FIXED	dist/lapic.c	30;"	d	file:
FIXED	lapic.c	30;"	d	file:
FL_IF	dist/mmu.h	5;"	d
FL_IF	mmu.h	5;"	d
FSSIZE	dist/param.h	13;"	d
FSSIZE	param.h	13;"	d
GDBPORT	Makefile	/^GDBPORT = $(shell expr `id -u` % 5000 + 25000)$/;"	m
GDBPORT	dist/Makefile	/^GDBPORT = $(shell expr `id -u` % 5000 + 25000)$/;"	m
HOURS	dist/lapic.c	168;"	d	file:
HOURS	lapic.c	169;"	d	file:
Header	dist/umalloc.c	/^typedef union header Header;$/;"	t	typeref:union:header	file:
Header	umalloc.c	/^typedef union header Header;$/;"	t	typeref:union:header	file:
IBLOCK	dist/fs.h	42;"	d
IBLOCK	fs.h	42;"	d
ICRHI	dist/lapic.c	31;"	d	file:
ICRHI	lapic.c	31;"	d	file:
ICRLO	dist/lapic.c	21;"	d	file:
ICRLO	lapic.c	21;"	d	file:
ID	dist/lapic.c	14;"	d	file:
ID	lapic.c	14;"	d	file:
IDE_BSY	dist/ide.c	17;"	d	file:
IDE_BSY	ide.c	17;"	d	file:
IDE_CMD_RDMUL	dist/ide.c	24;"	d	file:
IDE_CMD_RDMUL	ide.c	24;"	d	file:
IDE_CMD_READ	dist/ide.c	22;"	d	file:
IDE_CMD_READ	ide.c	22;"	d	file:
IDE_CMD_WRITE	dist/ide.c	23;"	d	file:
IDE_CMD_WRITE	ide.c	23;"	d	file:
IDE_CMD_WRMUL	dist/ide.c	25;"	d	file:
IDE_CMD_WRMUL	ide.c	25;"	d	file:
IDE_DF	dist/ide.c	19;"	d	file:
IDE_DF	ide.c	19;"	d	file:
IDE_DRDY	dist/ide.c	18;"	d	file:
IDE_DRDY	ide.c	18;"	d	file:
IDE_ERR	dist/ide.c	20;"	d	file:
IDE_ERR	ide.c	20;"	d	file:
INIT	dist/lapic.c	22;"	d	file:
INIT	lapic.c	22;"	d	file:
INPUT_BUF	console.c	181;"	d	file:
INPUT_BUF	dist/console.c	179;"	d	file:
INT_ACTIVELOW	dist/ioapic.c	22;"	d	file:
INT_ACTIVELOW	ioapic.c	22;"	d	file:
INT_DISABLED	dist/ioapic.c	20;"	d	file:
INT_DISABLED	ioapic.c	20;"	d	file:
INT_LEVEL	dist/ioapic.c	21;"	d	file:
INT_LEVEL	ioapic.c	21;"	d	file:
INT_LOGICAL	dist/ioapic.c	23;"	d	file:
INT_LOGICAL	ioapic.c	23;"	d	file:
IOAPIC	dist/ioapic.c	9;"	d	file:
IOAPIC	ioapic.c	9;"	d	file:
IO_PIC1	dist/picirq.c	6;"	d	file:
IO_PIC1	picirq.c	6;"	d	file:
IO_PIC2	dist/picirq.c	7;"	d	file:
IO_PIC2	picirq.c	7;"	d	file:
IPB	dist/fs.h	39;"	d
IPB	fs.h	39;"	d
IRQ_COM1	dist/traps.h	34;"	d
IRQ_COM1	traps.h	34;"	d
IRQ_ERROR	dist/traps.h	36;"	d
IRQ_ERROR	traps.h	36;"	d
IRQ_IDE	dist/traps.h	35;"	d
IRQ_IDE	traps.h	35;"	d
IRQ_KBD	dist/traps.h	33;"	d
IRQ_KBD	traps.h	33;"	d
IRQ_SPURIOUS	dist/traps.h	37;"	d
IRQ_SPURIOUS	traps.h	37;"	d
IRQ_TIMER	dist/traps.h	32;"	d
IRQ_TIMER	traps.h	32;"	d
KBDATAP	dist/kbd.h	5;"	d
KBDATAP	kbd.h	5;"	d
KBSTATP	dist/kbd.h	3;"	d
KBSTATP	kbd.h	3;"	d
KBS_DIB	dist/kbd.h	4;"	d
KBS_DIB	kbd.h	4;"	d
KERNBASE	dist/memlayout.h	8;"	d
KERNBASE	memlayout.h	8;"	d
KERNLINK	dist/memlayout.h	9;"	d
KERNLINK	memlayout.h	9;"	d
KEY_DEL	dist/kbd.h	29;"	d
KEY_DEL	kbd.h	29;"	d
KEY_DN	dist/kbd.h	23;"	d
KEY_DN	kbd.h	23;"	d
KEY_END	dist/kbd.h	21;"	d
KEY_END	kbd.h	21;"	d
KEY_HOME	dist/kbd.h	20;"	d
KEY_HOME	kbd.h	20;"	d
KEY_INS	dist/kbd.h	28;"	d
KEY_INS	kbd.h	28;"	d
KEY_LF	dist/kbd.h	24;"	d
KEY_LF	kbd.h	24;"	d
KEY_PGDN	dist/kbd.h	27;"	d
KEY_PGDN	kbd.h	27;"	d
KEY_PGUP	dist/kbd.h	26;"	d
KEY_PGUP	kbd.h	26;"	d
KEY_RT	dist/kbd.h	25;"	d
KEY_RT	kbd.h	25;"	d
KEY_UP	dist/kbd.h	22;"	d
KEY_UP	kbd.h	22;"	d
KSTACKSIZE	dist/param.h	2;"	d
KSTACKSIZE	param.h	2;"	d
LD	Makefile	/^LD = $(TOOLPREFIX)ld$/;"	m
LD	dist/Makefile	/^LD = $(TOOLPREFIX)ld$/;"	m
LEVEL	dist/lapic.c	27;"	d	file:
LEVEL	lapic.c	27;"	d	file:
LINT0	dist/lapic.c	36;"	d	file:
LINT0	lapic.c	36;"	d	file:
LINT1	dist/lapic.c	37;"	d	file:
LINT1	lapic.c	37;"	d	file:
LIST	dist/sh.c	11;"	d	file:
LIST	sh.c	11;"	d	file:
LOGSIZE	dist/param.h	11;"	d
LOGSIZE	param.h	11;"	d
MASKED	dist/lapic.c	39;"	d	file:
MASKED	lapic.c	39;"	d	file:
MAXARG	dist/param.h	9;"	d
MAXARG	param.h	9;"	d
MAXARGS	dist/sh.c	14;"	d	file:
MAXARGS	sh.c	14;"	d	file:
MAXFILE	dist/fs.h	26;"	d
MAXFILE	fs.h	26;"	d
MAXOPBLOCKS	dist/param.h	10;"	d
MAXOPBLOCKS	param.h	10;"	d
MEMFSOBJS	Makefile	/^MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o$/;"	m
MEMFSOBJS	dist/Makefile	/^MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o$/;"	m
MINS	dist/lapic.c	167;"	d	file:
MINS	lapic.c	168;"	d	file:
MONTH	dist/lapic.c	170;"	d	file:
MONTH	lapic.c	171;"	d	file:
MPBOOT	dist/mp.h	34;"	d
MPBOOT	mp.h	34;"	d
MPBUS	dist/mp.h	50;"	d
MPBUS	mp.h	50;"	d
MPIOAPIC	dist/mp.h	51;"	d
MPIOAPIC	mp.h	51;"	d
MPIOINTR	dist/mp.h	52;"	d
MPIOINTR	mp.h	52;"	d
MPLINTR	dist/mp.h	53;"	d
MPLINTR	mp.h	53;"	d
MPPROC	dist/mp.h	49;"	d
MPPROC	mp.h	49;"	d
N	dist/forktest.c	8;"	d	file:
N	forktest.c	8;"	d	file:
NBUF	dist/param.h	12;"	d
NBUF	param.h	12;"	d
NCPU	dist/param.h	3;"	d
NCPU	param.h	3;"	d
NDEV	dist/param.h	7;"	d
NDEV	param.h	7;"	d
NDIRECT	dist/fs.h	24;"	d
NDIRECT	fs.h	24;"	d
NELEM	defs.h	199;"	d
NELEM	dist/defs.h	198;"	d
NFILE	dist/param.h	5;"	d
NFILE	param.h	5;"	d
NINDIRECT	dist/fs.h	25;"	d
NINDIRECT	fs.h	25;"	d
NINODE	dist/param.h	6;"	d
NINODE	param.h	6;"	d
NINODES	dist/mkfs.c	18;"	d	file:
NINODES	mkfs.c	18;"	d	file:
NO	dist/kbd.h	7;"	d
NO	kbd.h	7;"	d
NOFILE	dist/param.h	4;"	d
NOFILE	param.h	4;"	d
NPDENTRIES	dist/mmu.h	83;"	d
NPDENTRIES	mmu.h	83;"	d
NPROC	dist/param.h	1;"	d
NPROC	param.h	1;"	d
NPTENTRIES	dist/mmu.h	84;"	d
NPTENTRIES	mmu.h	84;"	d
NSEGS	dist/mmu.h	22;"	d
NSEGS	mmu.h	22;"	d
NUMLOCK	dist/kbd.h	14;"	d
NUMLOCK	kbd.h	14;"	d
OBJCOPY	Makefile	/^OBJCOPY = $(TOOLPREFIX)objcopy$/;"	m
OBJCOPY	dist/Makefile	/^OBJCOPY = $(TOOLPREFIX)objcopy$/;"	m
OBJDUMP	Makefile	/^OBJDUMP = $(TOOLPREFIX)objdump$/;"	m
OBJDUMP	dist/Makefile	/^OBJDUMP = $(TOOLPREFIX)objdump$/;"	m
OBJS	Makefile	/^OBJS = \\$/;"	m
OBJS	dist/Makefile	/^OBJS = \\$/;"	m
O_CREATE	dist/fcntl.h	4;"	d
O_CREATE	fcntl.h	4;"	d
O_RDONLY	dist/fcntl.h	1;"	d
O_RDONLY	fcntl.h	1;"	d
O_RDWR	dist/fcntl.h	3;"	d
O_RDWR	fcntl.h	3;"	d
O_WRONLY	dist/fcntl.h	2;"	d
O_WRONLY	fcntl.h	2;"	d
P2V	dist/memlayout.h	12;"	d
P2V	memlayout.h	12;"	d
P2V_WO	dist/memlayout.h	15;"	d
P2V_WO	memlayout.h	15;"	d
PCINT	dist/lapic.c	35;"	d	file:
PCINT	lapic.c	35;"	d	file:
PDX	dist/mmu.h	74;"	d
PDX	mmu.h	74;"	d
PDXSHIFT	dist/mmu.h	88;"	d
PDXSHIFT	mmu.h	88;"	d
PERIODIC	dist/lapic.c	34;"	d	file:
PERIODIC	lapic.c	34;"	d	file:
PGADDR	dist/mmu.h	80;"	d
PGADDR	mmu.h	80;"	d
PGROUNDDOWN	dist/mmu.h	91;"	d
PGROUNDDOWN	mmu.h	91;"	d
PGROUNDUP	dist/mmu.h	90;"	d
PGROUNDUP	mmu.h	90;"	d
PGSIZE	dist/mmu.h	85;"	d
PGSIZE	mmu.h	85;"	d
PHYSTOP	dist/memlayout.h	4;"	d
PHYSTOP	memlayout.h	4;"	d
PIPE	dist/sh.c	10;"	d	file:
PIPE	sh.c	10;"	d	file:
PIPESIZE	dist/pipe.c	11;"	d	file:
PIPESIZE	pipe.c	11;"	d	file:
PRINT	Makefile	/^PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)$/;"	m
PRINT	dist/Makefile	/^PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)$/;"	m
PTE_ADDR	dist/mmu.h	100;"	d
PTE_ADDR	mmu.h	100;"	d
PTE_FLAGS	dist/mmu.h	101;"	d
PTE_FLAGS	mmu.h	101;"	d
PTE_P	dist/mmu.h	94;"	d
PTE_P	mmu.h	94;"	d
PTE_PS	dist/mmu.h	97;"	d
PTE_PS	mmu.h	97;"	d
PTE_U	dist/mmu.h	96;"	d
PTE_U	mmu.h	96;"	d
PTE_W	dist/mmu.h	95;"	d
PTE_W	mmu.h	95;"	d
PTX	dist/mmu.h	77;"	d
PTX	mmu.h	77;"	d
PTXSHIFT	dist/mmu.h	87;"	d
PTXSHIFT	mmu.h	87;"	d
QEMU	Makefile	/^QEMU = $(shell if which qemu > \/dev\/null; \\$/;"	m
QEMU	dist/Makefile	/^QEMU = $(shell if which qemu > \/dev\/null; \\$/;"	m
QEMUGDB	Makefile	/^QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \\$/;"	m
QEMUGDB	dist/Makefile	/^QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \\$/;"	m
QEMUOPTS	Makefile	/^QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)$/;"	m
QEMUOPTS	dist/Makefile	/^QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)$/;"	m
REDIR	dist/sh.c	9;"	d	file:
REDIR	sh.c	9;"	d	file:
REG_ID	dist/ioapic.c	11;"	d	file:
REG_ID	ioapic.c	11;"	d	file:
REG_TABLE	dist/ioapic.c	13;"	d	file:
REG_TABLE	ioapic.c	13;"	d	file:
REG_VER	dist/ioapic.c	12;"	d	file:
REG_VER	ioapic.c	12;"	d	file:
ROOTDEV	dist/param.h	8;"	d
ROOTDEV	param.h	8;"	d
ROOTINO	dist/fs.h	5;"	d
ROOTINO	fs.h	5;"	d
RTC_ADDR	dist/usertests.c	1701;"	d	file:
RTC_ADDR	usertests.c	1701;"	d	file:
RTC_DATA	dist/usertests.c	1702;"	d	file:
RTC_DATA	usertests.c	1702;"	d	file:
RUNNABLE	dist/proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
RUNNABLE	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
RUNNING	dist/proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
RUNNING	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
SCROLLLOCK	dist/kbd.h	15;"	d
SCROLLLOCK	kbd.h	15;"	d
SECS	dist/lapic.c	166;"	d	file:
SECS	lapic.c	167;"	d	file:
SECTOR_SIZE	dist/ide.c	16;"	d	file:
SECTOR_SIZE	ide.c	16;"	d	file:
SECTSIZE	bootmain.c	13;"	d	file:
SECTSIZE	dist/bootmain.c	13;"	d	file:
SEG	dist/mmu.h	43;"	d
SEG	mmu.h	43;"	d
SEG16	dist/mmu.h	47;"	d
SEG16	mmu.h	47;"	d
SEG_ASM	asm.h	11;"	d
SEG_ASM	dist/asm.h	11;"	d
SEG_KCODE	dist/mmu.h	15;"	d
SEG_KCODE	mmu.h	15;"	d
SEG_KDATA	dist/mmu.h	16;"	d
SEG_KDATA	mmu.h	16;"	d
SEG_NULLASM	asm.h	5;"	d
SEG_NULLASM	dist/asm.h	5;"	d
SEG_TSS	dist/mmu.h	19;"	d
SEG_TSS	mmu.h	19;"	d
SEG_UCODE	dist/mmu.h	17;"	d
SEG_UCODE	mmu.h	17;"	d
SEG_UDATA	dist/mmu.h	18;"	d
SEG_UDATA	mmu.h	18;"	d
SETGATE	dist/mmu.h	168;"	d
SETGATE	mmu.h	168;"	d
SHIFT	dist/kbd.h	9;"	d
SHIFT	kbd.h	9;"	d
SLEEPING	dist/proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
SLEEPING	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
STARTUP	dist/lapic.c	23;"	d	file:
STARTUP	lapic.c	23;"	d	file:
STA_R	asm.h	18;"	d
STA_R	dist/asm.h	18;"	d
STA_R	dist/mmu.h	58;"	d
STA_R	mmu.h	58;"	d
STA_W	asm.h	17;"	d
STA_W	dist/asm.h	17;"	d
STA_W	dist/mmu.h	57;"	d
STA_W	mmu.h	57;"	d
STA_X	asm.h	16;"	d
STA_X	dist/asm.h	16;"	d
STA_X	dist/mmu.h	56;"	d
STA_X	mmu.h	56;"	d
STS_IG32	dist/mmu.h	62;"	d
STS_IG32	mmu.h	62;"	d
STS_T32A	dist/mmu.h	61;"	d
STS_T32A	mmu.h	61;"	d
STS_TG32	dist/mmu.h	63;"	d
STS_TG32	mmu.h	63;"	d
SVR	dist/lapic.c	18;"	d	file:
SVR	lapic.c	18;"	d	file:
SWAPBASE	dist/fs.c	667;"	d	file:
SWAPBASE	fs.c	673;"	d	file:
SWAPBASE	kernel.asm	/^#define SWAPBASE	500$/;"	d
SWAPMAX	dist/fs.c	668;"	d	file:
SWAPMAX	fs.c	674;"	d	file:
SWAPMAX	kernel.asm	/^#define SWAPMAX		(100000 - SWAPBASE)$/;"	d
SYSCALL	dist/usys.S	/^#define SYSCALL(name) \\$/;"	d
SYSCALL	usys.S	/^#define SYSCALL(name) \\$/;"	d
SYS_chdir	dist/syscall.h	10;"	d
SYS_chdir	syscall.h	10;"	d
SYS_close	dist/syscall.h	22;"	d
SYS_close	syscall.h	22;"	d
SYS_dup	dist/syscall.h	11;"	d
SYS_dup	syscall.h	11;"	d
SYS_exec	dist/syscall.h	8;"	d
SYS_exec	syscall.h	8;"	d
SYS_exit	dist/syscall.h	3;"	d
SYS_exit	syscall.h	3;"	d
SYS_fork	dist/syscall.h	2;"	d
SYS_fork	syscall.h	2;"	d
SYS_fstat	dist/syscall.h	9;"	d
SYS_fstat	syscall.h	9;"	d
SYS_getnice	dist/syscall.h	27;"	d
SYS_getnice	syscall.h	27;"	d
SYS_getpid	dist/syscall.h	12;"	d
SYS_getpid	syscall.h	12;"	d
SYS_kill	dist/syscall.h	7;"	d
SYS_kill	syscall.h	7;"	d
SYS_link	dist/syscall.h	20;"	d
SYS_link	syscall.h	20;"	d
SYS_mkdir	dist/syscall.h	21;"	d
SYS_mkdir	syscall.h	21;"	d
SYS_mknod	dist/syscall.h	18;"	d
SYS_mknod	syscall.h	18;"	d
SYS_open	dist/syscall.h	16;"	d
SYS_open	syscall.h	16;"	d
SYS_pipe	dist/syscall.h	5;"	d
SYS_pipe	syscall.h	5;"	d
SYS_ps	dist/syscall.h	29;"	d
SYS_ps	syscall.h	29;"	d
SYS_read	dist/syscall.h	6;"	d
SYS_read	syscall.h	6;"	d
SYS_sbrk	dist/syscall.h	13;"	d
SYS_sbrk	syscall.h	13;"	d
SYS_setnice	dist/syscall.h	26;"	d
SYS_setnice	syscall.h	26;"	d
SYS_sleep	dist/syscall.h	14;"	d
SYS_sleep	syscall.h	14;"	d
SYS_swapread	dist/syscall.h	23;"	d
SYS_swapread	syscall.h	23;"	d
SYS_swapwrite	dist/syscall.h	24;"	d
SYS_swapwrite	syscall.h	24;"	d
SYS_unlink	dist/syscall.h	19;"	d
SYS_unlink	syscall.h	19;"	d
SYS_uptime	dist/syscall.h	15;"	d
SYS_uptime	syscall.h	15;"	d
SYS_wait	dist/syscall.h	4;"	d
SYS_wait	syscall.h	4;"	d
SYS_write	dist/syscall.h	17;"	d
SYS_write	syscall.h	17;"	d
SYS_yield	dist/syscall.h	28;"	d
SYS_yield	syscall.h	28;"	d
TCCR	dist/lapic.c	41;"	d	file:
TCCR	lapic.c	41;"	d	file:
TDCR	dist/lapic.c	42;"	d	file:
TDCR	lapic.c	42;"	d	file:
TICR	dist/lapic.c	40;"	d	file:
TICR	lapic.c	40;"	d	file:
TIMER	dist/lapic.c	32;"	d	file:
TIMER	lapic.c	32;"	d	file:
TOOLPREFIX	Makefile	/^TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >\/dev\/null 2>&1; \\$/;"	m
TOOLPREFIX	dist/Makefile	/^TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >\/dev\/null 2>&1; \\$/;"	m
TPR	dist/lapic.c	16;"	d	file:
TPR	lapic.c	16;"	d	file:
T_ALIGN	dist/traps.h	21;"	d
T_ALIGN	traps.h	21;"	d
T_BOUND	dist/traps.h	9;"	d
T_BOUND	traps.h	9;"	d
T_BRKPT	dist/traps.h	7;"	d
T_BRKPT	traps.h	7;"	d
T_DBLFLT	dist/traps.h	12;"	d
T_DBLFLT	traps.h	12;"	d
T_DEBUG	dist/traps.h	5;"	d
T_DEBUG	traps.h	5;"	d
T_DEFAULT	dist/traps.h	28;"	d
T_DEFAULT	traps.h	28;"	d
T_DEV	dist/stat.h	3;"	d
T_DEV	stat.h	3;"	d
T_DEVICE	dist/traps.h	11;"	d
T_DEVICE	traps.h	11;"	d
T_DIR	dist/stat.h	1;"	d
T_DIR	stat.h	1;"	d
T_DIVIDE	dist/traps.h	4;"	d
T_DIVIDE	traps.h	4;"	d
T_FILE	dist/stat.h	2;"	d
T_FILE	stat.h	2;"	d
T_FPERR	dist/traps.h	20;"	d
T_FPERR	traps.h	20;"	d
T_GPFLT	dist/traps.h	17;"	d
T_GPFLT	traps.h	17;"	d
T_ILLOP	dist/traps.h	10;"	d
T_ILLOP	traps.h	10;"	d
T_IRQ0	dist/traps.h	30;"	d
T_IRQ0	traps.h	30;"	d
T_MCHK	dist/traps.h	22;"	d
T_MCHK	traps.h	22;"	d
T_NMI	dist/traps.h	6;"	d
T_NMI	traps.h	6;"	d
T_OFLOW	dist/traps.h	8;"	d
T_OFLOW	traps.h	8;"	d
T_PGFLT	dist/traps.h	18;"	d
T_PGFLT	traps.h	18;"	d
T_SEGNP	dist/traps.h	15;"	d
T_SEGNP	traps.h	15;"	d
T_SIMDERR	dist/traps.h	23;"	d
T_SIMDERR	traps.h	23;"	d
T_STACK	dist/traps.h	16;"	d
T_STACK	traps.h	16;"	d
T_SYSCALL	dist/traps.h	27;"	d
T_SYSCALL	traps.h	27;"	d
T_TSS	dist/traps.h	14;"	d
T_TSS	traps.h	14;"	d
ULIB	Makefile	/^ULIB = ulib.o usys.o printf.o umalloc.o$/;"	m
ULIB	dist/Makefile	/^ULIB = ulib.o usys.o printf.o umalloc.o$/;"	m
UNUSED	dist/proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
UNUSED	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
UPROGS	Makefile	/^UPROGS=\\$/;"	m
UPROGS	dist/Makefile	/^UPROGS=\\$/;"	m
V2P	dist/memlayout.h	11;"	d
V2P	memlayout.h	11;"	d
V2P_WO	dist/memlayout.h	14;"	d
V2P_WO	memlayout.h	14;"	d
VER	dist/lapic.c	15;"	d	file:
VER	lapic.c	15;"	d	file:
X1	dist/lapic.c	33;"	d	file:
X1	lapic.c	33;"	d	file:
YEAR	dist/lapic.c	171;"	d	file:
YEAR	lapic.c	172;"	d	file:
ZOMBIE	dist/proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
ZOMBIE	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
_cat	cat.asm	/^_cat:     file format elf32-i386$/;"	l
_echo	echo.asm	/^_echo:     file format elf32-i386$/;"	l
_forktest	forktest.asm	/^_forktest:     file format elf32-i386$/;"	l
_getnice	getnice.asm	/^_getnice:     file format elf32-i386$/;"	l
_grep	grep.asm	/^_grep:     file format elf32-i386$/;"	l
_init	init.asm	/^_init:     file format elf32-i386$/;"	l
_kill	kill.asm	/^_kill:     file format elf32-i386$/;"	l
_ln	ln.asm	/^_ln:     file format elf32-i386$/;"	l
_ls	ls.asm	/^_ls:     file format elf32-i386$/;"	l
_mkdir	mkdir.asm	/^_mkdir:     file format elf32-i386$/;"	l
_ps	ps.asm	/^_ps:     file format elf32-i386$/;"	l
_rm	rm.asm	/^_rm:     file format elf32-i386$/;"	l
_setnice	setnice.asm	/^_setnice:     file format elf32-i386$/;"	l
_sh	sh.asm	/^_sh:     file format elf32-i386$/;"	l
_start	dist/entry.S	/^_start = V2P_WO(entry)$/;"	d
_start	entry.S	/^_start = V2P_WO(entry)$/;"	d
_stressfs	stressfs.asm	/^_stressfs:     file format elf32-i386$/;"	l
_swaptest	swaptest.asm	/^_swaptest:     file format elf32-i386$/;"	l
_test1	test1.asm	/^_test1:     file format elf32-i386$/;"	l
_test2	test2.asm	/^_test2:     file format elf32-i386$/;"	l
_testcase1	testcase1.asm	/^_testcase1:     file format elf32-i386$/;"	l
_testcase2	testcase2.asm	/^_testcase2:     file format elf32-i386$/;"	l
_usertests	usertests.asm	/^_usertests:     file format elf32-i386$/;"	l
_wc	wc.asm	/^_wc:     file format elf32-i386$/;"	l
_zombie	zombie.asm	/^_zombie:     file format elf32-i386$/;"	l
a	forktest.asm	/^   a:	e8 41 00 00 00       	call   50 <forktest>$/;"	l
a	initcode.asm	/^   a:	6a 00                	push   $0x0$/;"	l
a	kernel.asm	/^      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;$/;"	d
a	kernel.asm	/^    a = (uint*)bp->data;$/;"	d
a	kernel.asm	/^  a = (char*)PGROUNDDOWN((uint)va);$/;"	d
a	kernel.asm	/^  a = PGROUNDUP(newsz);$/;"	d
a	kernel.asm	/^  a = PGROUNDUP(oldsz);$/;"	d
a	ps.asm	/^   a:	e8 3c 03 00 00       	call   34b <ps>$/;"	l
a	usertests.asm	/^    a = b + 1;$/;"	d
a	usertests.asm	/^  a = sbrk(0);$/;"	d
a0	cat.asm	/^  a0:	83 ec 04             	sub    $0x4,%esp$/;"	l
a0	echo.asm	/^  a0:	5b                   	pop    %ebx$/;"	l
a0	forktest.asm	/^  a0:	e8 16 03 00 00       	call   3bb <wait>$/;"	l
a0	init.asm	/^  a0:	e8 e6 02 00 00       	call   38b <wait>$/;"	l
a0	kill.asm	/^  a0:	f3 0f 1e fb          	endbr32 $/;"	l
a0	ls.asm	/^  a0:	77 4a                	ja     ec <fmtname+0x8c>$/;"	l
a0	mkdir.asm	/^  a0:	5b                   	pop    %ebx$/;"	l
a0	ps.asm	/^  a0:	f3 0f 1e fb          	endbr32 $/;"	l
a0	rm.asm	/^  a0:	5b                   	pop    %ebx$/;"	l
a0	test2.asm	/^  a0:	dc c1                	fadd   %st,%st(1)$/;"	d
a0	testcase2.asm	/^  a0:	dc c1                	fadd   %st,%st(1)$/;"	d
a0	wc.asm	/^  a0:	f3 0f 1e fb          	endbr32 $/;"	l
a0	zombie.asm	/^  a0:	31 c0                	xor    %eax,%eax$/;"	l
a00	grep.asm	/^ a00:	83 c4 10             	add    $0x10,%esp$/;"	l
a00	ls.asm	/^ a00:	83 c4 10             	add    $0x10,%esp$/;"	l
a00	sh.asm	/^     a00:	f3 0f 1e fb          	endbr32 $/;"	l
a01	usertests.asm	/^     a01:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
a03	grep.asm	/^ a03:	83 f8 ff             	cmp    $0xffffffff,%eax$/;"	l
a03	ls.asm	/^ a03:	83 f8 ff             	cmp    $0xffffffff,%eax$/;"	l
a04	sh.asm	/^     a04:	55                   	push   %ebp$/;"	l
a05	sh.asm	/^     a05:	89 e5                	mov    %esp,%ebp$/;"	l
a06	grep.asm	/^ a06:	74 1b                	je     a23 <malloc+0x93>$/;"	l
a06	ls.asm	/^ a06:	74 1b                	je     a23 <malloc+0x93>$/;"	l
a07	sh.asm	/^     a07:	53                   	push   %ebx$/;"	l
a08	grep.asm	/^ a08:	89 58 04             	mov    %ebx,0x4(%eax)$/;"	l
a08	ls.asm	/^ a08:	89 58 04             	mov    %ebx,0x4(%eax)$/;"	l
a08	sh.asm	/^     a08:	83 ec 04             	sub    $0x4,%esp$/;"	l
a08	usertests.asm	/^     a08:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
a0b	grep.asm	/^ a0b:	83 ec 0c             	sub    $0xc,%esp$/;"	l
a0b	ls.asm	/^ a0b:	83 ec 0c             	sub    $0xc,%esp$/;"	l
a0b	sh.asm	/^     a0b:	8b 5d 08             	mov    0x8(%ebp),%ebx$/;"	l
a0e	grep.asm	/^ a0e:	83 c0 08             	add    $0x8,%eax$/;"	l
a0e	ls.asm	/^ a0e:	83 c0 08             	add    $0x8,%eax$/;"	l
a0e	sh.asm	/^     a0e:	85 db                	test   %ebx,%ebx$/;"	l
a0f	usertests.asm	/^     a0f:	90                   	nop$/;"	l
a1	echo.asm	/^  a1:	5d                   	pop    %ebp$/;"	l
a1	getnice.asm	/^  a1:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
a1	ln.asm	/^  a1:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
a1	mkdir.asm	/^  a1:	5d                   	pop    %ebp$/;"	l
a1	rm.asm	/^  a1:	5d                   	pop    %ebp$/;"	l
a1	setnice.asm	/^  a1:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
a1	stressfs.asm	/^  a1:	68 02 02 00 00       	push   $0x202$/;"	l
a1	swaptest.asm	/^  a1:	e8 6d 02 00 00       	call   313 <exit>$/;"	l
a10	sh.asm	/^     a10:	0f 84 9a 00 00 00    	je     ab0 <nulterminate+0xb0>$/;"	l
a10	usertests.asm	/^     a10:	f3 0f 1e fb          	endbr32 $/;"	l
a11	grep.asm	/^ a11:	50                   	push   %eax$/;"	l
a11	ls.asm	/^ a11:	50                   	push   %eax$/;"	l
a12	grep.asm	/^ a12:	e8 e9 fe ff ff       	call   900 <free>$/;"	l
a12	ls.asm	/^ a12:	e8 e9 fe ff ff       	call   900 <free>$/;"	l
a14	usertests.asm	/^     a14:	55                   	push   %ebp$/;"	l
a15	usertests.asm	/^     a15:	89 e5                	mov    %esp,%ebp$/;"	l
a16	sh.asm	/^     a16:	83 3b 05             	cmpl   $0x5,(%ebx)$/;"	l
a17	grep.asm	/^ a17:	a1 80 0e 00 00       	mov    0xe80,%eax$/;"	l
a17	ls.asm	/^ a17:	a1 24 0e 00 00       	mov    0xe24,%eax$/;"	l
a17	usertests.asm	/^     a17:	83 ec 10             	sub    $0x10,%esp$/;"	l
a19	sh.asm	/^     a19:	77 6d                	ja     a88 <nulterminate+0x88>$/;"	l
a1a	usertests.asm	/^     a1a:	68 94 41 00 00       	push   $0x4194$/;"	l
a1b	sh.asm	/^     a1b:	8b 03                	mov    (%ebx),%eax$/;"	l
a1c	grep.asm	/^ a1c:	83 c4 10             	add    $0x10,%esp$/;"	l
a1c	ls.asm	/^ a1c:	83 c4 10             	add    $0x10,%esp$/;"	l
a1d	sh.asm	/^     a1d:	3e ff 24 85 58 13 00 	notrack jmp *0x1358(,%eax,4)$/;"	l
a1f	grep.asm	/^ a1f:	85 c0                	test   %eax,%eax$/;"	l
a1f	ls.asm	/^ a1f:	85 c0                	test   %eax,%eax$/;"	l
a1f	usertests.asm	/^     a1f:	ff 35 10 5f 00 00    	pushl  0x5f10$/;"	l
a2	echo.asm	/^  a2:	c3                   	ret    $/;"	l
a2	ls.asm	/^  a2:	83 ec 0c             	sub    $0xc,%esp$/;"	l
a2	mkdir.asm	/^  a2:	c3                   	ret    $/;"	l
a2	rm.asm	/^  a2:	c3                   	ret    $/;"	l
a2	sh.asm	/^      a2:	83 ec 0c             	sub    $0xc,%esp$/;"	l
a2	test1.asm	/^  a2:	0f 84 b8 01 00 00    	je     260 <test_p1_1+0x220>$/;"	l
a2	test2.asm	/^  a2:	d9 05 98 08 00 00    	flds   0x898$/;"	d
a2	testcase1.asm	/^  a2:	0f 84 b8 01 00 00    	je     260 <test_p1_1+0x220>$/;"	l
a2	testcase2.asm	/^  a2:	d9 05 98 08 00 00    	flds   0x898$/;"	d
a2	zombie.asm	/^  a2:	29 d8                	sub    %ebx,%eax$/;"	l
a21	grep.asm	/^ a21:	75 bd                	jne    9e0 <malloc+0x50>$/;"	l
a21	ls.asm	/^ a21:	75 bd                	jne    9e0 <malloc+0x50>$/;"	l
a23	grep.asm	/^ a23:	8d 65 f4             	lea    -0xc(%ebp),%esp$/;"	l
a23	ls.asm	/^ a23:	8d 65 f4             	lea    -0xc(%ebp),%esp$/;"	l
a24	sh.asm	/^     a24:	00 $/;"	l
a25	sh.asm	/^     a25:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
a25	usertests.asm	/^     a25:	e8 e6 30 00 00       	call   3b10 <printf>$/;"	l
a26	grep.asm	/^ a26:	31 c0                	xor    %eax,%eax$/;"	l
a26	ls.asm	/^ a26:	31 c0                	xor    %eax,%eax$/;"	l
a28	grep.asm	/^ a28:	5b                   	pop    %ebx$/;"	l
a28	ls.asm	/^ a28:	5b                   	pop    %ebx$/;"	l
a28	sh.asm	/^     a28:	83 ec 0c             	sub    $0xc,%esp$/;"	l
a29	grep.asm	/^ a29:	5e                   	pop    %esi$/;"	l
a29	ls.asm	/^ a29:	5e                   	pop    %esi$/;"	l
a2a	grep.asm	/^ a2a:	5f                   	pop    %edi$/;"	l
a2a	ls.asm	/^ a2a:	5f                   	pop    %edi$/;"	l
a2a	usertests.asm	/^     a2a:	5a                   	pop    %edx$/;"	l
a2b	grep.asm	/^ a2b:	5d                   	pop    %ebp$/;"	l
a2b	ls.asm	/^ a2b:	5d                   	pop    %ebp$/;"	l
a2b	sh.asm	/^     a2b:	ff 73 04             	pushl  0x4(%ebx)$/;"	l
a2b	usertests.asm	/^     a2b:	59                   	pop    %ecx$/;"	l
a2c	grep.asm	/^ a2c:	c3                   	ret    $/;"	l
a2c	ls.asm	/^ a2c:	c3                   	ret    $/;"	l
a2c	usertests.asm	/^     a2c:	68 14 5f 00 00       	push   $0x5f14$/;"	l
a2d	grep.asm	/^ a2d:	89 c2                	mov    %eax,%edx$/;"	l
a2d	ls.asm	/^ a2d:	89 c2                	mov    %eax,%edx$/;"	l
a2e	sh.asm	/^     a2e:	e8 cd ff ff ff       	call   a00 <nulterminate>$/;"	l
a2f	grep.asm	/^ a2f:	89 f8                	mov    %edi,%eax$/;"	l
a2f	ls.asm	/^ a2f:	89 f8                	mov    %edi,%eax$/;"	l
a3	cat.asm	/^  a3:	53                   	push   %ebx$/;"	l
a3	echo.asm	/^  a3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
a3	grep.asm	/^  a3:	52                   	push   %edx$/;"	l
a3	mkdir.asm	/^  a3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
a3	rm.asm	/^  a3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
a3	usertests.asm	/^      a3:	e8 08 04 00 00       	call   4b0 <writetest>$/;"	l
a31	grep.asm	/^ a31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
a31	ls.asm	/^ a31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
a31	usertests.asm	/^     a31:	68 5d 3f 00 00       	push   $0x3f5d$/;"	l
a33	sh.asm	/^     a33:	58                   	pop    %eax$/;"	l
a34	sh.asm	/^     a34:	ff 73 08             	pushl  0x8(%ebx)$/;"	l
a36	usertests.asm	/^     a36:	e8 80 2f 00 00       	call   39bb <exec>$/;"	l
a37	sh.asm	/^     a37:	e8 c4 ff ff ff       	call   a00 <nulterminate>$/;"	l
a38	grep.asm	/^ a38:	39 ce                	cmp    %ecx,%esi$/;"	l
a38	ls.asm	/^ a38:	39 ce                	cmp    %ecx,%esi$/;"	l
a3a	grep.asm	/^ a3a:	74 54                	je     a90 <malloc+0x100>$/;"	l
a3a	ls.asm	/^ a3a:	74 54                	je     a90 <malloc+0x100>$/;"	l
a3b	usertests.asm	/^     a3b:	83 c4 10             	add    $0x10,%esp$/;"	l
a3c	grep.asm	/^ a3c:	29 f1                	sub    %esi,%ecx$/;"	l
a3c	ls.asm	/^ a3c:	29 f1                	sub    %esi,%ecx$/;"	l
a3c	sh.asm	/^     a3c:	83 c4 10             	add    $0x10,%esp$/;"	l
a3e	grep.asm	/^ a3e:	89 4a 04             	mov    %ecx,0x4(%edx)$/;"	l
a3e	ls.asm	/^ a3e:	89 4a 04             	mov    %ecx,0x4(%edx)$/;"	l
a3e	usertests.asm	/^     a3e:	85 c0                	test   %eax,%eax$/;"	l
a3f	sh.asm	/^     a3f:	89 d8                	mov    %ebx,%eax$/;"	l
a4	cat.asm	/^  a4:	68 c0 0b 00 00       	push   $0xbc0$/;"	l
a4	getnice.asm	/^  a4:	84 c0                	test   %al,%al$/;"	l
a4	grep.asm	/^  a4:	52                   	push   %edx$/;"	l
a4	kill.asm	/^  a4:	55                   	push   %ebp$/;"	l
a4	ln.asm	/^  a4:	84 c0                	test   %al,%al$/;"	l
a4	ps.asm	/^  a4:	55                   	push   %ebp$/;"	l
a4	setnice.asm	/^  a4:	84 c0                	test   %al,%al$/;"	l
a4	wc.asm	/^  a4:	55                   	push   %ebp$/;"	l
a4	zombie.asm	/^  a4:	5b                   	pop    %ebx$/;"	l
a40	usertests.asm	/^     a40:	78 02                	js     a44 <exectest+0x34>$/;"	l
a41	grep.asm	/^ a41:	8d 14 ca             	lea    (%edx,%ecx,8),%edx$/;"	l
a41	ls.asm	/^ a41:	8d 14 ca             	lea    (%edx,%ecx,8),%edx$/;"	l
a41	sh.asm	/^     a41:	8b 5d fc             	mov    -0x4(%ebp),%ebx$/;"	l
a42	usertests.asm	/^     a42:	c9                   	leave  $/;"	l
a43	usertests.asm	/^     a43:	c3                   	ret    $/;"	l
a44	grep.asm	/^ a44:	89 72 04             	mov    %esi,0x4(%edx)$/;"	l
a44	ls.asm	/^ a44:	89 72 04             	mov    %esi,0x4(%edx)$/;"	l
a44	sh.asm	/^     a44:	c9                   	leave  $/;"	l
a44	usertests.asm	/^     a44:	50                   	push   %eax$/;"	l
a45	sh.asm	/^     a45:	c3                   	ret    $/;"	l
a45	usertests.asm	/^     a45:	50                   	push   %eax$/;"	l
a46	sh.asm	/^     a46:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
a46	usertests.asm	/^     a46:	68 9f 41 00 00       	push   $0x419f$/;"	l
a47	grep.asm	/^ a47:	a3 80 0e 00 00       	mov    %eax,0xe80$/;"	l
a47	ls.asm	/^ a47:	a3 24 0e 00 00       	mov    %eax,0xe24$/;"	l
a4b	usertests.asm	/^     a4b:	ff 35 10 5f 00 00    	pushl  0x5f10$/;"	l
a4c	grep.asm	/^ a4c:	8d 65 f4             	lea    -0xc(%ebp),%esp$/;"	l
a4c	ls.asm	/^ a4c:	8d 65 f4             	lea    -0xc(%ebp),%esp$/;"	l
a4d	sh.asm	/^     a4d:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
a4f	grep.asm	/^ a4f:	8d 42 08             	lea    0x8(%edx),%eax$/;"	l
a4f	ls.asm	/^ a4f:	8d 42 08             	lea    0x8(%edx),%eax$/;"	l
a5	forktest.asm	/^  a5:	85 c0                	test   %eax,%eax$/;"	l
a5	grep.asm	/^  a5:	6a 00                	push   $0x0$/;"	l
a5	init.asm	/^  a5:	85 c0                	test   %eax,%eax$/;"	l
a5	kill.asm	/^  a5:	89 e5                	mov    %esp,%ebp$/;"	l
a5	ls.asm	/^  a5:	53                   	push   %ebx$/;"	l
a5	ps.asm	/^  a5:	89 e5                	mov    %esp,%ebp$/;"	l
a5	sh.asm	/^      a5:	68 60 19 00 00       	push   $0x1960$/;"	l
a5	wc.asm	/^  a5:	89 e5                	mov    %esp,%ebp$/;"	l
a5	zombie.asm	/^  a5:	5d                   	pop    %ebp$/;"	l
a50	sh.asm	/^     a50:	83 ec 0c             	sub    $0xc,%esp$/;"	l
a51	usertests.asm	/^     a51:	e8 ba 30 00 00       	call   3b10 <printf>$/;"	l
a52	grep.asm	/^ a52:	5b                   	pop    %ebx$/;"	l
a52	ls.asm	/^ a52:	5b                   	pop    %ebx$/;"	l
a53	grep.asm	/^ a53:	5e                   	pop    %esi$/;"	l
a53	ls.asm	/^ a53:	5e                   	pop    %esi$/;"	l
a53	sh.asm	/^     a53:	ff 73 04             	pushl  0x4(%ebx)$/;"	l
a54	grep.asm	/^ a54:	5f                   	pop    %edi$/;"	l
a54	ls.asm	/^ a54:	5f                   	pop    %edi$/;"	l
a55	grep.asm	/^ a55:	5d                   	pop    %ebp$/;"	l
a55	ls.asm	/^ a55:	5d                   	pop    %ebp$/;"	l
a56	grep.asm	/^ a56:	c3                   	ret    $/;"	l
a56	ls.asm	/^ a56:	c3                   	ret    $/;"	l
a56	sh.asm	/^     a56:	e8 a5 ff ff ff       	call   a00 <nulterminate>$/;"	l
a56	usertests.asm	/^     a56:	e8 28 2f 00 00       	call   3983 <exit>$/;"	l
a57	grep.asm	/^ a57:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
a57	ls.asm	/^ a57:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
a5b	sh.asm	/^     a5b:	89 d8                	mov    %ebx,%eax$/;"	l
a5b	usertests.asm	/^     a5b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
a5d	sh.asm	/^     a5d:	83 c4 10             	add    $0x10,%esp$/;"	l
a5e	grep.asm	/^ a5e:	66 90                	xchg   %ax,%ax$/;"	l
a5e	ls.asm	/^ a5e:	66 90                	xchg   %ax,%ax$/;"	l
a5f	usertests.asm	/^     a5f:	90                   	nop$/;"	l
a6	getnice.asm	/^  a6:	75 19                	jne    c1 <strcmp+0x31>$/;"	l
a6	ln.asm	/^  a6:	75 19                	jne    c1 <strcmp+0x31>$/;"	l
a6	ls.asm	/^  a6:	e8 15 03 00 00       	call   3c0 <strlen>$/;"	l
a6	setnice.asm	/^  a6:	75 19                	jne    c1 <strcmp+0x31>$/;"	l
a6	stressfs.asm	/^  a6:	50                   	push   %eax$/;"	l
a6	swaptest.asm	/^  a6:	66 90                	xchg   %ax,%ax$/;"	l
a6	zombie.asm	/^  a6:	c3                   	ret    $/;"	l
a60	grep.asm	/^ a60:	c7 05 80 0e 00 00 84 	movl   $0xe84,0xe80$/;"	l
a60	ls.asm	/^ a60:	c7 05 24 0e 00 00 28 	movl   $0xe28,0xe24$/;"	l
a60	sh.asm	/^     a60:	8b 5d fc             	mov    -0x4(%ebp),%ebx$/;"	l
a60	usertests.asm	/^     a60:	f3 0f 1e fb          	endbr32 $/;"	l
a63	sh.asm	/^     a63:	c9                   	leave  $/;"	l
a64	sh.asm	/^     a64:	c3                   	ret    $/;"	l
a64	usertests.asm	/^     a64:	55                   	push   %ebp$/;"	l
a65	sh.asm	/^     a65:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
a65	usertests.asm	/^     a65:	89 e5                	mov    %esp,%ebp$/;"	l
a67	grep.asm	/^ a67:	0e 00 00 $/;"	l
a67	ls.asm	/^ a67:	0e 00 00 $/;"	l
a67	usertests.asm	/^     a67:	57                   	push   %edi$/;"	l
a68	sh.asm	/^     a68:	8b 4b 04             	mov    0x4(%ebx),%ecx$/;"	l
a68	usertests.asm	/^     a68:	56                   	push   %esi$/;"	l
a69	usertests.asm	/^     a69:	8d 45 e0             	lea    -0x20(%ebp),%eax$/;"	l
a6a	grep.asm	/^ a6a:	bf 84 0e 00 00       	mov    $0xe84,%edi$/;"	l
a6a	ls.asm	/^ a6a:	bf 28 0e 00 00       	mov    $0xe28,%edi$/;"	l
a6b	sh.asm	/^     a6b:	8d 43 08             	lea    0x8(%ebx),%eax$/;"	l
a6c	usertests.asm	/^     a6c:	53                   	push   %ebx$/;"	l
a6d	usertests.asm	/^     a6d:	83 ec 38             	sub    $0x38,%esp$/;"	l
a6e	sh.asm	/^     a6e:	85 c9                	test   %ecx,%ecx$/;"	l
a6f	grep.asm	/^ a6f:	c7 05 84 0e 00 00 84 	movl   $0xe84,0xe84$/;"	l
a6f	ls.asm	/^ a6f:	c7 05 28 0e 00 00 28 	movl   $0xe28,0xe28$/;"	l
a7	forktest.asm	/^  a7:	78 36                	js     df <forktest+0x8f>$/;"	l
a7	grep.asm	/^  a7:	50                   	push   %eax$/;"	l
a7	init.asm	/^  a7:	78 a7                	js     50 <main+0x50>$/;"	l
a7	kill.asm	/^  a7:	53                   	push   %ebx$/;"	l
a7	ps.asm	/^  a7:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
a7	stressfs.asm	/^  a7:	e8 37 03 00 00       	call   3e3 <open>$/;"	l
a7	wc.asm	/^  a7:	57                   	push   %edi$/;"	l
a7	zombie.asm	/^  a7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
a70	sh.asm	/^     a70:	74 16                	je     a88 <nulterminate+0x88>$/;"	l
a70	usertests.asm	/^     a70:	50                   	push   %eax$/;"	l
a71	usertests.asm	/^     a71:	e8 1d 2f 00 00       	call   3993 <pipe>$/;"	l
a72	sh.asm	/^     a72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
a76	grep.asm	/^ a76:	0e 00 00 $/;"	l
a76	ls.asm	/^ a76:	0e 00 00 $/;"	l
a76	usertests.asm	/^     a76:	83 c4 10             	add    $0x10,%esp$/;"	l
a78	sh.asm	/^     a78:	8b 50 24             	mov    0x24(%eax),%edx$/;"	l
a79	grep.asm	/^ a79:	89 f8                	mov    %edi,%eax$/;"	l
a79	ls.asm	/^ a79:	89 f8                	mov    %edi,%eax$/;"	l
a79	usertests.asm	/^     a79:	85 c0                	test   %eax,%eax$/;"	l
a7b	grep.asm	/^ a7b:	c7 05 88 0e 00 00 00 	movl   $0x0,0xe88$/;"	l
a7b	ls.asm	/^ a7b:	c7 05 2c 0e 00 00 00 	movl   $0x0,0xe2c$/;"	l
a7b	sh.asm	/^     a7b:	83 c0 04             	add    $0x4,%eax$/;"	l
a7b	usertests.asm	/^     a7b:	0f 85 38 01 00 00    	jne    bb9 <pipe1+0x159>$/;"	l
a7e	sh.asm	/^     a7e:	c6 02 00             	movb   $0x0,(%edx)$/;"	l
a8	getnice.asm	/^  a8:	eb 26                	jmp    d0 <strcmp+0x40>$/;"	l
a8	grep.asm	/^  a8:	e8 83 01 00 00       	call   230 <grep>$/;"	l
a8	kill.asm	/^  a8:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
a8	ln.asm	/^  a8:	eb 26                	jmp    d0 <strcmp+0x40>$/;"	l
a8	setnice.asm	/^  a8:	eb 26                	jmp    d0 <strcmp+0x40>$/;"	l
a8	swaptest.asm	/^  a8:	66 90                	xchg   %ax,%ax$/;"	l
a8	test1.asm	/^  a8:	83 ec 08             	sub    $0x8,%esp$/;"	l
a8	test2.asm	/^  a8:	df f2                	fcomip %st(2),%st$/;"	d
a8	testcase1.asm	/^  a8:	83 ec 08             	sub    $0x8,%esp$/;"	l
a8	testcase2.asm	/^  a8:	df f2                	fcomip %st(2),%st$/;"	d
a8	usertests.asm	/^      a8:	e8 e3 05 00 00       	call   690 <writetest1>$/;"	l
a8	wc.asm	/^  a8:	56                   	push   %esi$/;"	l
a81	sh.asm	/^     a81:	8b 50 fc             	mov    -0x4(%eax),%edx$/;"	l
a81	usertests.asm	/^     a81:	e8 f5 2e 00 00       	call   397b <fork>$/;"	l
a82	grep.asm	/^ a82:	00 00 00 $/;"	l
a82	ls.asm	/^ a82:	00 00 00 $/;"	l
a84	sh.asm	/^     a84:	85 d2                	test   %edx,%edx$/;"	l
a85	grep.asm	/^ a85:	e9 36 ff ff ff       	jmp    9c0 <malloc+0x30>$/;"	l
a85	ls.asm	/^ a85:	e9 36 ff ff ff       	jmp    9c0 <malloc+0x30>$/;"	l
a86	sh.asm	/^     a86:	75 f0                	jne    a78 <nulterminate+0x78>$/;"	l
a86	usertests.asm	/^     a86:	85 c0                	test   %eax,%eax$/;"	l
a88	sh.asm	/^     a88:	89 d8                	mov    %ebx,%eax$/;"	l
a88	usertests.asm	/^     a88:	0f 84 8d 00 00 00    	je     b1b <pipe1+0xbb>$/;"	l
a8a	grep.asm	/^ a8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
a8a	ls.asm	/^ a8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
a8a	sh.asm	/^     a8a:	8b 5d fc             	mov    -0x4(%ebp),%ebx$/;"	l
a8d	sh.asm	/^     a8d:	c9                   	leave  $/;"	l
a8e	sh.asm	/^     a8e:	c3                   	ret    $/;"	l
a8e	usertests.asm	/^     a8e:	0f 8e 38 01 00 00    	jle    bcc <pipe1+0x16c>$/;"	l
a8f	sh.asm	/^     a8f:	90                   	nop$/;"	l
a9	cat.asm	/^  a9:	6a 01                	push   $0x1$/;"	l
a9	forktest.asm	/^  a9:	83 eb 01             	sub    $0x1,%ebx$/;"	l
a9	init.asm	/^  a9:	39 c3                	cmp    %eax,%ebx$/;"	l
a9	wc.asm	/^  a9:	53                   	push   %ebx$/;"	l
a90	grep.asm	/^ a90:	8b 0a                	mov    (%edx),%ecx$/;"	l
a90	ls.asm	/^ a90:	8b 0a                	mov    (%edx),%ecx$/;"	l
a90	sh.asm	/^     a90:	83 ec 0c             	sub    $0xc,%esp$/;"	l
a92	grep.asm	/^ a92:	89 08                	mov    %ecx,(%eax)$/;"	l
a92	ls.asm	/^ a92:	89 08                	mov    %ecx,(%eax)$/;"	l
a93	sh.asm	/^     a93:	ff 73 04             	pushl  0x4(%ebx)$/;"	l
a94	grep.asm	/^ a94:	eb b1                	jmp    a47 <malloc+0xb7>$/;"	l
a94	ls.asm	/^ a94:	eb b1                	jmp    a47 <malloc+0xb7>$/;"	l
a94	usertests.asm	/^     a94:	83 ec 0c             	sub    $0xc,%esp$/;"	l
a96	sh.asm	/^     a96:	e8 65 ff ff ff       	call   a00 <nulterminate>$/;"	l
a97	usertests.asm	/^     a97:	ff 75 e4             	pushl  -0x1c(%ebp)$/;"	l
a9a	usertests.asm	/^     a9a:	31 db                	xor    %ebx,%ebx$/;"	l
a9b	sh.asm	/^     a9b:	8b 43 0c             	mov    0xc(%ebx),%eax$/;"	l
a9c	usertests.asm	/^     a9c:	be 01 00 00 00       	mov    $0x1,%esi$/;"	l
a9e	sh.asm	/^     a9e:	83 c4 10             	add    $0x10,%esp$/;"	l
aa	echo.asm	/^  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
aa	getnice.asm	/^  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
aa	ln.asm	/^  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
aa	mkdir.asm	/^  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
aa	ps.asm	/^  aa:	80 3a 00             	cmpb   $0x0,(%edx)$/;"	l
aa	rm.asm	/^  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
aa	setnice.asm	/^  aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
aa	sh.asm	/^      aa:	e8 01 0b 00 00       	call   bb0 <strlen>$/;"	l
aa	swaptest.asm	/^  aa:	66 90                	xchg   %ax,%ax$/;"	l
aa	test2.asm	/^  aa:	77 f4                	ja     a0 <test_p1_2+0x60>$/;"	l
aa	testcase2.asm	/^  aa:	77 f4                	ja     a0 <test_p1_2+0x60>$/;"	l
aa	wc.asm	/^  aa:	31 db                	xor    %ebx,%ebx$/;"	l
aa1	sh.asm	/^     aa1:	c6 00 00             	movb   $0x0,(%eax)$/;"	l
aa1	usertests.asm	/^     aa1:	e8 05 2f 00 00       	call   39ab <close>$/;"	l
aa4	sh.asm	/^     aa4:	89 d8                	mov    %ebx,%eax$/;"	l
aa6	sh.asm	/^     aa6:	8b 5d fc             	mov    -0x4(%ebp),%ebx$/;"	l
aa6	usertests.asm	/^     aa6:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)$/;"	l
aa9	sh.asm	/^     aa9:	c9                   	leave  $/;"	l
aaa	sh.asm	/^     aaa:	c3                   	ret    $/;"	l
aab	sh.asm	/^     aab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
aad	usertests.asm	/^     aad:	83 c4 10             	add    $0x10,%esp$/;"	l
aaf	sh.asm	/^     aaf:	90                   	nop$/;"	l
ab	cat.asm	/^  ab:	e8 e3 02 00 00       	call   393 <write>$/;"	l
ab	init.asm	/^  ab:	74 a3                	je     50 <main+0x50>$/;"	l
ab	kill.asm	/^  ab:	8b 55 0c             	mov    0xc(%ebp),%edx$/;"	l
ab	ls.asm	/^  ab:	83 c4 0c             	add    $0xc,%esp$/;"	l
ab	test1.asm	/^  ab:	68 1b 0b 00 00       	push   $0xb1b$/;"	l
ab	testcase1.asm	/^  ab:	68 1b 0b 00 00       	push   $0xb1b$/;"	l
ab0	sh.asm	/^     ab0:	31 c0                	xor    %eax,%eax$/;"	l
ab0	usertests.asm	/^     ab0:	83 ec 04             	sub    $0x4,%esp$/;"	l
ab2	sh.asm	/^     ab2:	eb 8d                	jmp    a41 <nulterminate+0x41>$/;"	l
ab3	usertests.asm	/^     ab3:	56                   	push   %esi$/;"	l
ab4	sh.asm	/^     ab4:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
ab4	usertests.asm	/^     ab4:	68 00 87 00 00       	push   $0x8700$/;"	l
ab9	usertests.asm	/^     ab9:	ff 75 e0             	pushl  -0x20(%ebp)$/;"	l
abb	sh.asm	/^     abb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
abc	usertests.asm	/^     abc:	e8 da 2e 00 00       	call   399b <read>$/;"	l
abf	sh.asm	/^     abf:	90                   	nop$/;"	l
ac	forktest.asm	/^  ac:	75 f2                	jne    a0 <forktest+0x50>$/;"	l
ac	stressfs.asm	/^  ac:	83 c4 10             	add    $0x10,%esp$/;"	l
ac	swaptest.asm	/^  ac:	66 90                	xchg   %ax,%ax$/;"	l
ac	test2.asm	/^  ac:	dd d8                	fstp   %st(0)$/;"	d
ac	testcase2.asm	/^  ac:	dd d8                	fstp   %st(0)$/;"	d
ac	wc.asm	/^  ac:	83 ec 1c             	sub    $0x1c,%esp$/;"	l
ac0	sh.asm	/^     ac0:	f3 0f 1e fb          	endbr32 $/;"	l
ac1	usertests.asm	/^     ac1:	83 c4 10             	add    $0x10,%esp$/;"	l
ac4	sh.asm	/^     ac4:	55                   	push   %ebp$/;"	l
ac4	usertests.asm	/^     ac4:	89 c7                	mov    %eax,%edi$/;"	l
ac5	sh.asm	/^     ac5:	89 e5                	mov    %esp,%ebp$/;"	l
ac6	usertests.asm	/^     ac6:	85 c0                	test   %eax,%eax$/;"	l
ac7	sh.asm	/^     ac7:	56                   	push   %esi$/;"	l
ac8	sh.asm	/^     ac8:	53                   	push   %ebx$/;"	l
ac8	usertests.asm	/^     ac8:	0f 8e a7 00 00 00    	jle    b75 <pipe1+0x115>$/;"	l
ac9	sh.asm	/^     ac9:	8b 5d 08             	mov    0x8(%ebp),%ebx$/;"	l
acc	sh.asm	/^     acc:	83 ec 0c             	sub    $0xc,%esp$/;"	l
ace	usertests.asm	/^     ace:	8d 0c 3b             	lea    (%ebx,%edi,1),%ecx$/;"	l
acf	sh.asm	/^     acf:	53                   	push   %ebx$/;"	l
acquire	dist/spinlock.c	/^acquire(struct spinlock *lk)$/;"	f
acquire	spinlock.c	/^acquire(struct spinlock *lk)$/;"	f
acquiresleep	dist/sleeplock.c	/^acquiresleep(struct sleeplock *lk)$/;"	f
acquiresleep	sleeplock.c	/^acquiresleep(struct sleeplock *lk)$/;"	f
ad	grep.asm	/^  ad:	e8 f1 04 00 00       	call   5a3 <exit>$/;"	l
ad	init.asm	/^  ad:	83 ec 08             	sub    $0x8,%esp$/;"	l
ad	ps.asm	/^  ad:	74 21                	je     d0 <strlen+0x30>$/;"	l
ad	usertests.asm	/^      ad:	e8 ae 07 00 00       	call   860 <createtest>$/;"	l
ad0	sh.asm	/^     ad0:	e8 db 00 00 00       	call   bb0 <strlen>$/;"	l
ad1	usertests.asm	/^     ad1:	31 c0                	xor    %eax,%eax$/;"	l
ad3	usertests.asm	/^     ad3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
ad5	sh.asm	/^     ad5:	59                   	pop    %ecx$/;"	l
ad6	sh.asm	/^     ad6:	5e                   	pop    %esi$/;"	l
ad7	sh.asm	/^     ad7:	01 c3                	add    %eax,%ebx$/;"	l
ad7	usertests.asm	/^     ad7:	90                   	nop$/;"	l
ad8	usertests.asm	/^     ad8:	89 da                	mov    %ebx,%edx$/;"	l
ad9	sh.asm	/^     ad9:	8d 45 08             	lea    0x8(%ebp),%eax$/;"	l
ada	usertests.asm	/^     ada:	83 c3 01             	add    $0x1,%ebx$/;"	l
adc	sh.asm	/^     adc:	53                   	push   %ebx$/;"	l
add	sh.asm	/^     add:	50                   	push   %eax$/;"	l
add	usertests.asm	/^     add:	38 90 00 87 00 00    	cmp    %dl,0x8700(%eax)$/;"	l
addr	dist/mp.h	/^  uint *addr;                  \/\/ I\/O APIC address$/;"	m	struct:mpioapic
addr	kernel.asm	/^  addr = P2V(a);$/;"	d
addr	kernel.asm	/^  addr = myproc()->sz;$/;"	d
addr	mp.h	/^  uint *addr;                  \/\/ I\/O APIC address$/;"	m	struct:mpioapic
addrs	dist/file.h	/^  uint addrs[NDIRECT+1];$/;"	m	struct:inode
addrs	dist/fs.h	/^  uint addrs[NDIRECT+1];   \/\/ Data block addresses$/;"	m	struct:dinode
addrs	file.h	/^  uint addrs[NDIRECT+1];$/;"	m	struct:inode
addrs	fs.h	/^  uint addrs[NDIRECT+1];   \/\/ Data block addresses$/;"	m	struct:dinode
ade	sh.asm	/^     ade:	e8 dd fd ff ff       	call   8c0 <parseline>$/;"	l
ae	forktest.asm	/^  ae:	e8 08 03 00 00       	call   3bb <wait>$/;"	l
ae	kill.asm	/^  ae:	0f b6 01             	movzbl (%ecx),%eax$/;"	l
ae	ls.asm	/^  ae:	50                   	push   %eax$/;"	l
ae	swaptest.asm	/^  ae:	66 90                	xchg   %ax,%ax$/;"	l
ae	test2.asm	/^  ae:	dd d8                	fstp   %st(0)$/;"	d
ae	testcase2.asm	/^  ae:	dd d8                	fstp   %st(0)$/;"	d
ae	zombie.asm	/^  ae:	66 90                	xchg   %ax,%ax$/;"	l
ae3	sh.asm	/^     ae3:	83 c4 0c             	add    $0xc,%esp$/;"	l
ae3	usertests.asm	/^     ae3:	75 1c                	jne    b01 <pipe1+0xa1>$/;"	l
ae5	usertests.asm	/^     ae5:	83 c0 01             	add    $0x1,%eax$/;"	l
ae6	sh.asm	/^     ae6:	89 c6                	mov    %eax,%esi$/;"	l
ae8	sh.asm	/^     ae8:	8d 45 08             	lea    0x8(%ebp),%eax$/;"	l
ae8	usertests.asm	/^     ae8:	39 d9                	cmp    %ebx,%ecx$/;"	l
aea	usertests.asm	/^     aea:	75 ec                	jne    ad8 <pipe1+0x78>$/;"	l
aeb	sh.asm	/^     aeb:	68 a1 12 00 00       	push   $0x12a1$/;"	l
aec	usertests.asm	/^     aec:	01 f6                	add    %esi,%esi$/;"	l
aee	usertests.asm	/^     aee:	01 7d d4             	add    %edi,-0x2c(%ebp)$/;"	l
af	ls.asm	/^  af:	53                   	push   %ebx$/;"	l
af	ps.asm	/^  af:	31 c0                	xor    %eax,%eax$/;"	l
af	sh.asm	/^      af:	c7 04 24 63 19 00 00 	movl   $0x1963,(%esp)$/;"	l
af	stressfs.asm	/^  af:	89 c7                	mov    %eax,%edi$/;"	l
af	wc.asm	/^  af:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)$/;"	l
af0	sh.asm	/^     af0:	53                   	push   %ebx$/;"	l
af1	sh.asm	/^     af1:	50                   	push   %eax$/;"	l
af1	usertests.asm	/^     af1:	b8 00 20 00 00       	mov    $0x2000,%eax$/;"	l
af2	sh.asm	/^     af2:	e8 19 fb ff ff       	call   610 <peek>$/;"	l
af6	usertests.asm	/^     af6:	81 fe 00 20 00 00    	cmp    $0x2000,%esi$/;"	l
af7	sh.asm	/^     af7:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
afa	sh.asm	/^     afa:	83 c4 10             	add    $0x10,%esp$/;"	l
afc	usertests.asm	/^     afc:	0f 4f f0             	cmovg  %eax,%esi$/;"	l
afd	sh.asm	/^     afd:	39 d8                	cmp    %ebx,%eax$/;"	l
aff	sh.asm	/^     aff:	75 12                	jne    b13 <parsecmd+0x53>$/;"	l
aff	usertests.asm	/^     aff:	eb af                	jmp    ab0 <pipe1+0x50>$/;"	l
align	dist/elf.h	/^  uint align;$/;"	m	struct:proghdr
align	elf.h	/^  uint align;$/;"	m	struct:proghdr
allocproc	dist/proc.c	/^allocproc(void)$/;"	f	file:
allocproc	proc.c	/^allocproc(void)$/;"	f	file:
allocuvm	dist/vm.c	/^allocuvm(pde_t *pgdir, uint oldsz, uint newsz)$/;"	f
allocuvm	vm.c	/^allocuvm(pde_t *pgdir, uint oldsz, uint newsz)$/;"	f
alltraps	dist/trapasm.S	/^alltraps:$/;"	l
alltraps	trapasm.S	/^alltraps:$/;"	l
amt	usertests.asm	/^  amt = (BIG) - (uint)a;$/;"	d
ap	cat.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	echo.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	getnice.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	grep.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	init.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	kill.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	ln.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	ls.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	mkdir.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	ps.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	rm.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	setnice.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	sh.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	stressfs.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	swaptest.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	test1.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	test2.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	testcase1.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	testcase2.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	usertests.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	wc.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	zombie.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
apicid	dist/mp.h	/^  uchar apicid;                 \/\/ local APIC id$/;"	m	struct:mpproc
apicid	dist/proc.h	/^  uchar apicid;                \/\/ Local APIC ID$/;"	m	struct:cpu
apicid	kernel.asm	/^  apicid = lapicid();$/;"	d
apicid	mp.h	/^  uchar apicid;                 \/\/ local APIC id$/;"	m	struct:mpproc
apicid	proc.h	/^  uchar apicid;                \/\/ Local APIC ID$/;"	m	struct:cpu
apicno	dist/mp.h	/^  uchar apicno;                 \/\/ I\/O APIC id$/;"	m	struct:mpioapic
apicno	mp.h	/^  uchar apicno;                 \/\/ I\/O APIC id$/;"	m	struct:mpioapic
argc	sh.asm	/^  argc = 0;$/;"	d
argfd	dist/sysfile.c	/^argfd(int n, int *pfd, struct file **pf)$/;"	f	file:
argfd	sysfile.c	/^argfd(int n, int *pfd, struct file **pf)$/;"	f	file:
argint	dist/syscall.c	/^argint(int n, int *ip)$/;"	f
argint	syscall.c	/^argint(int n, int *ip)$/;"	f
argp	kernel.asm	/^  argp = (uint*)(void*)(&fmt + 1);$/;"	d
argptest	dist/usertests.c	/^void argptest()$/;"	f
argptest	usertests.c	/^void argptest()$/;"	f
argptr	dist/syscall.c	/^argptr(int n, char **pp, int size)$/;"	f
argptr	syscall.c	/^argptr(int n, char **pp, int size)$/;"	f
args	dist/mmu.h	/^  uint args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:gatedesc
args	mmu.h	/^  uint args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:gatedesc
argstr	dist/syscall.c	/^argstr(int n, char **pp)$/;"	f
argstr	syscall.c	/^argstr(int n, char **pp)$/;"	f
argv	dist/init.c	/^char *argv[] = { "sh", 0 };$/;"	v
argv	dist/initcode.S	/^argv:$/;"	l
argv	dist/sh.c	/^  char *argv[MAXARGS];$/;"	m	struct:execcmd	file:
argv	init.c	/^char *argv[] = { "sh", 0 };$/;"	v
argv	initcode.S	/^argv:$/;"	l
argv	sh.c	/^  char *argv[MAXARGS];$/;"	m	struct:execcmd	file:
atoi	dist/ulib.c	/^atoi(const char *s)$/;"	f
atoi	ulib.c	/^atoi(const char *s)$/;"	f
avl	dist/mmu.h	/^  uint avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:segdesc
avl	mmu.h	/^  uint avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:segdesc
b	cat.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	echo.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	getnice.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	grep.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	init.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	kernel.asm	/^  b = bget(dev, blockno);$/;"	d
b	kill.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	ln.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	ls.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	mkdir.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	rm.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	setnice.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	sh.asm	/^       b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	stressfs.asm	/^   b:	b8 30 00 00 00       	mov    $0x30,%eax$/;"	l
b	swaptest.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	test1.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	test2.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	testcase1.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	testcase2.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	usertests.asm	/^       b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	usertests.asm	/^    b = sbrk(1);$/;"	d
b	wc.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b	zombie.asm	/^   b:	ff 71 fc             	pushl  -0x4(%ecx)$/;"	l
b0	cat.asm	/^  b0:	83 c4 10             	add    $0x10,%esp$/;"	l
b0	echo.asm	/^  b0:	f3 0f 1e fb          	endbr32 $/;"	l
b0	getnice.asm	/^  b0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax$/;"	l
b0	init.asm	/^  b0:	68 ed 08 00 00       	push   $0x8ed$/;"	l
b0	ln.asm	/^  b0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax$/;"	l
b0	ls.asm	/^  b0:	68 14 0e 00 00       	push   $0xe14$/;"	l
b0	mkdir.asm	/^  b0:	f3 0f 1e fb          	endbr32 $/;"	l
b0	rm.asm	/^  b0:	f3 0f 1e fb          	endbr32 $/;"	l
b0	setnice.asm	/^  b0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax$/;"	l
b0	swaptest.asm	/^  b0:	f3 0f 1e fb          	endbr32 $/;"	l
b0	test1.asm	/^  b0:	6a 01                	push   $0x1$/;"	l
b0	test2.asm	/^  b0:	e8 76 03 00 00       	call   42b <ps>$/;"	l
b0	testcase1.asm	/^  b0:	6a 01                	push   $0x1$/;"	l
b0	testcase2.asm	/^  b0:	e8 76 03 00 00       	call   42b <ps>$/;"	l
b0	zombie.asm	/^  b0:	f3 0f 1e fb          	endbr32 $/;"	l
b01	sh.asm	/^     b01:	83 ec 0c             	sub    $0xc,%esp$/;"	l
b01	usertests.asm	/^     b01:	83 ec 08             	sub    $0x8,%esp$/;"	l
b04	sh.asm	/^     b04:	56                   	push   %esi$/;"	l
b04	usertests.asm	/^     b04:	68 ce 41 00 00       	push   $0x41ce$/;"	l
b05	sh.asm	/^     b05:	e8 f6 fe ff ff       	call   a00 <nulterminate>$/;"	l
b09	usertests.asm	/^     b09:	6a 01                	push   $0x1$/;"	l
b0a	sh.asm	/^     b0a:	8d 65 f8             	lea    -0x8(%ebp),%esp$/;"	l
b0b	usertests.asm	/^     b0b:	e8 00 30 00 00       	call   3b10 <printf>$/;"	l
b0d	sh.asm	/^     b0d:	89 f0                	mov    %esi,%eax$/;"	l
b0f	sh.asm	/^     b0f:	5b                   	pop    %ebx$/;"	l
b1	kill.asm	/^  b1:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
b1	ps.asm	/^  b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
b1	stressfs.asm	/^  b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
b10	sh.asm	/^     b10:	5e                   	pop    %esi$/;"	l
b10	usertests.asm	/^     b10:	83 c4 10             	add    $0x10,%esp$/;"	l
b11	sh.asm	/^     b11:	5d                   	pop    %ebp$/;"	l
b12	sh.asm	/^     b12:	c3                   	ret    $/;"	l
b13	sh.asm	/^     b13:	52                   	push   %edx$/;"	l
b13	usertests.asm	/^     b13:	8d 65 f4             	lea    -0xc(%ebp),%esp$/;"	l
b14	sh.asm	/^     b14:	50                   	push   %eax$/;"	l
b15	sh.asm	/^     b15:	68 1a 13 00 00       	push   $0x131a$/;"	l
b16	usertests.asm	/^     b16:	5b                   	pop    %ebx$/;"	l
b17	usertests.asm	/^     b17:	5e                   	pop    %esi$/;"	l
b18	usertests.asm	/^     b18:	5f                   	pop    %edi$/;"	l
b19	usertests.asm	/^     b19:	5d                   	pop    %ebp$/;"	l
b1a	sh.asm	/^     b1a:	6a 02                	push   $0x2$/;"	l
b1a	usertests.asm	/^     b1a:	c3                   	ret    $/;"	l
b1b	usertests.asm	/^     b1b:	83 ec 0c             	sub    $0xc,%esp$/;"	l
b1c	sh.asm	/^     b1c:	e8 ff 03 00 00       	call   f20 <printf>$/;"	l
b1e	usertests.asm	/^     b1e:	ff 75 e0             	pushl  -0x20(%ebp)$/;"	l
b2	grep.asm	/^  b2:	66 90                	xchg   %ax,%ax$/;"	l
b2	test1.asm	/^  b2:	e8 d9 05 00 00       	call   690 <printf>$/;"	l
b2	testcase1.asm	/^  b2:	e8 d9 05 00 00       	call   690 <printf>$/;"	l
b2	usertests.asm	/^      b2:	e8 59 02 00 00       	call   310 <openiputtest>$/;"	l
b21	sh.asm	/^     b21:	c7 04 24 de 12 00 00 	movl   $0x12de,(%esp)$/;"	l
b21	usertests.asm	/^     b21:	31 db                	xor    %ebx,%ebx$/;"	l
b23	usertests.asm	/^     b23:	e8 83 2e 00 00       	call   39ab <close>$/;"	l
b28	sh.asm	/^     b28:	e8 33 f6 ff ff       	call   160 <panic>$/;"	l
b28	usertests.asm	/^     b28:	83 c4 10             	add    $0x10,%esp$/;"	l
b2b	usertests.asm	/^     b2b:	31 c0                	xor    %eax,%eax$/;"	l
b2d	sh.asm	/^     b2d:	66 90                	xchg   %ax,%ax$/;"	l
b2d	usertests.asm	/^     b2d:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
b2f	sh.asm	/^     b2f:	90                   	nop$/;"	l
b3	cat.asm	/^  b3:	39 d8                	cmp    %ebx,%eax$/;"	l
b3	forktest.asm	/^  b3:	83 f8 ff             	cmp    $0xffffffff,%eax$/;"	l
b30	sh.asm	/^     b30:	f3 0f 1e fb          	endbr32 $/;"	l
b30	usertests.asm	/^     b30:	8d 14 18             	lea    (%eax,%ebx,1),%edx$/;"	l
b33	usertests.asm	/^     b33:	83 c0 01             	add    $0x1,%eax$/;"	l
b34	sh.asm	/^     b34:	55                   	push   %ebp$/;"	l
b35	sh.asm	/^     b35:	31 c0                	xor    %eax,%eax$/;"	l
b36	usertests.asm	/^     b36:	88 90 ff 86 00 00    	mov    %dl,0x86ff(%eax)$/;"	l
b37	sh.asm	/^     b37:	89 e5                	mov    %esp,%ebp$/;"	l
b39	sh.asm	/^     b39:	53                   	push   %ebx$/;"	l
b3a	sh.asm	/^     b3a:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
b3c	usertests.asm	/^     b3c:	3d 09 04 00 00       	cmp    $0x409,%eax$/;"	l
b3d	sh.asm	/^     b3d:	8b 5d 0c             	mov    0xc(%ebp),%ebx$/;"	l
b4	echo.asm	/^  b4:	55                   	push   %ebp$/;"	l
b4	getnice.asm	/^  b4:	83 c1 01             	add    $0x1,%ecx$/;"	l
b4	grep.asm	/^  b4:	66 90                	xchg   %ax,%ax$/;"	l
b4	kill.asm	/^  b4:	84 c0                	test   %al,%al$/;"	l
b4	ln.asm	/^  b4:	83 c1 01             	add    $0x1,%ecx$/;"	l
b4	mkdir.asm	/^  b4:	55                   	push   %ebp$/;"	l
b4	rm.asm	/^  b4:	55                   	push   %ebp$/;"	l
b4	setnice.asm	/^  b4:	83 c1 01             	add    $0x1,%ecx$/;"	l
b4	swaptest.asm	/^  b4:	55                   	push   %ebp$/;"	l
b4	zombie.asm	/^  b4:	55                   	push   %ebp$/;"	l
b40	sh.asm	/^     b40:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx$/;"	l
b41	usertests.asm	/^     b41:	75 ed                	jne    b30 <pipe1+0xd0>$/;"	l
b43	usertests.asm	/^     b43:	83 ec 04             	sub    $0x4,%esp$/;"	l
b44	sh.asm	/^     b44:	88 14 01             	mov    %dl,(%ecx,%eax,1)$/;"	l
b46	usertests.asm	/^     b46:	81 c3 09 04 00 00    	add    $0x409,%ebx$/;"	l
b47	sh.asm	/^     b47:	83 c0 01             	add    $0x1,%eax$/;"	l
b4a	sh.asm	/^     b4a:	84 d2                	test   %dl,%dl$/;"	l
b4c	sh.asm	/^     b4c:	75 f2                	jne    b40 <strcpy+0x10>$/;"	l
b4c	usertests.asm	/^     b4c:	68 09 04 00 00       	push   $0x409$/;"	l
b4e	sh.asm	/^     b4e:	89 c8                	mov    %ecx,%eax$/;"	l
b5	cat.asm	/^  b5:	75 25                	jne    dc <cat+0x4c>$/;"	l
b5	echo.asm	/^  b5:	89 e5                	mov    %esp,%ebp$/;"	l
b5	init.asm	/^  b5:	6a 01                	push   $0x1$/;"	l
b5	ls.asm	/^  b5:	e8 b6 04 00 00       	call   570 <memmove>$/;"	l
b5	mkdir.asm	/^  b5:	89 e5                	mov    %esp,%ebp$/;"	l
b5	rm.asm	/^  b5:	89 e5                	mov    %esp,%ebp$/;"	l
b5	swaptest.asm	/^  b5:	31 c0                	xor    %eax,%eax$/;"	l
b5	test2.asm	/^  b5:	e8 69 03 00 00       	call   423 <yield>$/;"	l
b5	testcase2.asm	/^  b5:	e8 69 03 00 00       	call   423 <yield>$/;"	l
b5	zombie.asm	/^  b5:	89 e5                	mov    %esp,%ebp$/;"	l
b50	sh.asm	/^     b50:	5b                   	pop    %ebx$/;"	l
b51	sh.asm	/^     b51:	5d                   	pop    %ebp$/;"	l
b51	usertests.asm	/^     b51:	68 00 87 00 00       	push   $0x8700$/;"	l
b52	sh.asm	/^     b52:	c3                   	ret    $/;"	l
b53	sh.asm	/^     b53:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
b56	usertests.asm	/^     b56:	ff 75 e4             	pushl  -0x1c(%ebp)$/;"	l
b59	usertests.asm	/^     b59:	e8 45 2e 00 00       	call   39a3 <write>$/;"	l
b5a	sh.asm	/^     b5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
b5e	usertests.asm	/^     b5e:	83 c4 10             	add    $0x10,%esp$/;"	l
b6	forktest.asm	/^  b6:	75 49                	jne    101 <forktest+0xb1>$/;"	l
b6	grep.asm	/^  b6:	66 90                	xchg   %ax,%ax$/;"	l
b6	kill.asm	/^  b6:	75 19                	jne    d1 <strcmp+0x31>$/;"	l
b6	sh.asm	/^      b6:	c6 80 5f 19 00 00 00 	movb   $0x0,0x195f(%eax)$/;"	l
b6	wc.asm	/^  b6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)$/;"	l
b60	sh.asm	/^     b60:	f3 0f 1e fb          	endbr32 $/;"	l
b61	usertests.asm	/^     b61:	3d 09 04 00 00       	cmp    $0x409,%eax$/;"	l
b64	sh.asm	/^     b64:	55                   	push   %ebp$/;"	l
b65	sh.asm	/^     b65:	89 e5                	mov    %esp,%ebp$/;"	l
b66	usertests.asm	/^     b66:	75 77                	jne    bdf <pipe1+0x17f>$/;"	l
b67	sh.asm	/^     b67:	53                   	push   %ebx$/;"	l
b68	sh.asm	/^     b68:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
b68	usertests.asm	/^     b68:	81 fb 2d 14 00 00    	cmp    $0x142d,%ebx$/;"	l
b6b	sh.asm	/^     b6b:	8b 55 0c             	mov    0xc(%ebp),%edx$/;"	l
b6e	sh.asm	/^     b6e:	0f b6 01             	movzbl (%ecx),%eax$/;"	l
b6e	usertests.asm	/^     b6e:	75 bb                	jne    b2b <pipe1+0xcb>$/;"	l
b7	cat.asm	/^  b7:	83 ec 04             	sub    $0x4,%esp$/;"	l
b7	echo.asm	/^  b7:	53                   	push   %ebx$/;"	l
b7	getnice.asm	/^  b7:	83 c2 01             	add    $0x1,%edx$/;"	l
b7	init.asm	/^  b7:	e8 54 04 00 00       	call   510 <printf>$/;"	l
b7	ln.asm	/^  b7:	83 c2 01             	add    $0x1,%edx$/;"	l
b7	mkdir.asm	/^  b7:	53                   	push   %ebx$/;"	l
b7	rm.asm	/^  b7:	53                   	push   %ebx$/;"	l
b7	setnice.asm	/^  b7:	83 c2 01             	add    $0x1,%edx$/;"	l
b7	swaptest.asm	/^  b7:	89 e5                	mov    %esp,%ebp$/;"	l
b7	test1.asm	/^  b7:	83 c4 10             	add    $0x10,%esp$/;"	l
b7	testcase1.asm	/^  b7:	83 c4 10             	add    $0x10,%esp$/;"	l
b7	usertests.asm	/^      b7:	e8 54 01 00 00       	call   210 <exitiputtest>$/;"	l
b7	zombie.asm	/^  b7:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
b70	usertests.asm	/^     b70:	e8 0e 2e 00 00       	call   3983 <exit>$/;"	l
b71	sh.asm	/^     b71:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
b74	sh.asm	/^     b74:	84 c0                	test   %al,%al$/;"	l
b75	usertests.asm	/^     b75:	81 7d d4 2d 14 00 00 	cmpl   $0x142d,-0x2c(%ebp)$/;"	l
b76	sh.asm	/^     b76:	75 19                	jne    b91 <strcmp+0x31>$/;"	l
b78	sh.asm	/^     b78:	eb 26                	jmp    ba0 <strcmp+0x40>$/;"	l
b7a	sh.asm	/^     b7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
b7c	usertests.asm	/^     b7c:	75 26                	jne    ba4 <pipe1+0x144>$/;"	l
b7e	usertests.asm	/^     b7e:	83 ec 0c             	sub    $0xc,%esp$/;"	l
b8	echo.asm	/^  b8:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
b8	forktest.asm	/^  b8:	83 ec 0c             	sub    $0xc,%esp$/;"	l
b8	grep.asm	/^  b8:	66 90                	xchg   %ax,%ax$/;"	l
b8	kill.asm	/^  b8:	eb 26                	jmp    e0 <strcmp+0x40>$/;"	l
b8	mkdir.asm	/^  b8:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
b8	ps.asm	/^  b8:	83 c0 01             	add    $0x1,%eax$/;"	l
b8	rm.asm	/^  b8:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
b8	stressfs.asm	/^  b8:	83 ec 04             	sub    $0x4,%esp$/;"	l
b80	sh.asm	/^     b80:	0f b6 41 01          	movzbl 0x1(%ecx),%eax$/;"	l
b81	usertests.asm	/^     b81:	ff 75 e0             	pushl  -0x20(%ebp)$/;"	l
b84	sh.asm	/^     b84:	83 c1 01             	add    $0x1,%ecx$/;"	l
b84	usertests.asm	/^     b84:	e8 22 2e 00 00       	call   39ab <close>$/;"	l
b87	sh.asm	/^     b87:	83 c2 01             	add    $0x1,%edx$/;"	l
b89	usertests.asm	/^     b89:	e8 fd 2d 00 00       	call   398b <wait>$/;"	l
b8a	sh.asm	/^     b8a:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
b8d	sh.asm	/^     b8d:	84 c0                	test   %al,%al$/;"	l
b8e	usertests.asm	/^     b8e:	5a                   	pop    %edx$/;"	l
b8f	sh.asm	/^     b8f:	74 0f                	je     ba0 <strcmp+0x40>$/;"	l
b8f	usertests.asm	/^     b8f:	59                   	pop    %ecx$/;"	l
b9	swaptest.asm	/^  b9:	53                   	push   %ebx$/;"	l
b90	usertests.asm	/^     b90:	68 f3 41 00 00       	push   $0x41f3$/;"	l
b91	sh.asm	/^     b91:	38 d8                	cmp    %bl,%al$/;"	l
b93	sh.asm	/^     b93:	74 eb                	je     b80 <strcmp+0x20>$/;"	l
b95	sh.asm	/^     b95:	29 d8                	sub    %ebx,%eax$/;"	l
b95	usertests.asm	/^     b95:	6a 01                	push   $0x1$/;"	l
b97	sh.asm	/^     b97:	5b                   	pop    %ebx$/;"	l
b97	usertests.asm	/^     b97:	e8 74 2f 00 00       	call   3b10 <printf>$/;"	l
b98	sh.asm	/^     b98:	5d                   	pop    %ebp$/;"	l
b99	sh.asm	/^     b99:	c3                   	ret    $/;"	l
b9a	sh.asm	/^     b9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
b9c	usertests.asm	/^     b9c:	83 c4 10             	add    $0x10,%esp$/;"	l
b9f	usertests.asm	/^     b9f:	e9 6f ff ff ff       	jmp    b13 <pipe1+0xb3>$/;"	l
ba	cat.asm	/^  ba:	68 00 02 00 00       	push   $0x200$/;"	l
ba	getnice.asm	/^  ba:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
ba	grep.asm	/^  ba:	66 90                	xchg   %ax,%ax$/;"	l
ba	kill.asm	/^  ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
ba	ln.asm	/^  ba:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
ba	ls.asm	/^  ba:	89 1c 24             	mov    %ebx,(%esp)$/;"	l
ba	setnice.asm	/^  ba:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
ba	swaptest.asm	/^  ba:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
ba	test1.asm	/^  ba:	83 ec 08             	sub    $0x8,%esp$/;"	l
ba	test2.asm	/^  ba:	c9                   	leave  $/;"	l
ba	testcase1.asm	/^  ba:	83 ec 08             	sub    $0x8,%esp$/;"	l
ba	testcase2.asm	/^  ba:	c9                   	leave  $/;"	l
ba	zombie.asm	/^  ba:	80 3a 00             	cmpb   $0x0,(%edx)$/;"	l
ba0	sh.asm	/^     ba0:	31 c0                	xor    %eax,%eax$/;"	l
ba2	sh.asm	/^     ba2:	29 d8                	sub    %ebx,%eax$/;"	l
ba4	sh.asm	/^     ba4:	5b                   	pop    %ebx$/;"	l
ba4	usertests.asm	/^     ba4:	53                   	push   %ebx$/;"	l
ba5	sh.asm	/^     ba5:	5d                   	pop    %ebp$/;"	l
ba5	usertests.asm	/^     ba5:	ff 75 d4             	pushl  -0x2c(%ebp)$/;"	l
ba6	sh.asm	/^     ba6:	c3                   	ret    $/;"	l
ba7	sh.asm	/^     ba7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
ba8	usertests.asm	/^     ba8:	68 dc 41 00 00       	push   $0x41dc$/;"	l
backcmd	dist/sh.c	/^backcmd(struct cmd *subcmd)$/;"	f
backcmd	dist/sh.c	/^struct backcmd {$/;"	s	file:
backcmd	sh.c	/^backcmd(struct cmd *subcmd)$/;"	f
backcmd	sh.c	/^struct backcmd {$/;"	s	file:
bad	kernel.asm	/^ bad:$/;"	l
bad	kernel.asm	/^bad:$/;"	l
bad	usertests.asm	/^     bad:	6a 01                	push   $0x1$/;"	l
bae	sh.asm	/^     bae:	66 90                	xchg   %ax,%ax$/;"	l
baf	usertests.asm	/^     baf:	e8 5c 2f 00 00       	call   3b10 <printf>$/;"	l
balloc	dist/fs.c	/^balloc(uint dev)$/;"	f	file:
balloc	dist/mkfs.c	/^balloc(int used)$/;"	f
balloc	fs.c	/^balloc(uint dev)$/;"	f	file:
balloc	mkfs.c	/^balloc(int used)$/;"	f
base	dist/umalloc.c	/^static Header base;$/;"	v	file:
base	umalloc.c	/^static Header base;$/;"	v	file:
base_15_0	dist/mmu.h	/^  uint base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:segdesc
base_15_0	mmu.h	/^  uint base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:segdesc
base_23_16	dist/mmu.h	/^  uint base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:segdesc
base_23_16	mmu.h	/^  uint base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:segdesc
base_31_24	dist/mmu.h	/^  uint base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:segdesc
base_31_24	mmu.h	/^  uint base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:segdesc
bb	echo.asm	/^  bb:	8b 55 0c             	mov    0xc(%ebp),%edx$/;"	l
bb	forktest.asm	/^  bb:	68 b6 04 00 00       	push   $0x4b6$/;"	l
bb	mkdir.asm	/^  bb:	8b 55 0c             	mov    0xc(%ebp),%edx$/;"	l
bb	ps.asm	/^  bb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)$/;"	l
bb	rm.asm	/^  bb:	8b 55 0c             	mov    0xc(%ebp),%edx$/;"	l
bb	stressfs.asm	/^  bb:	68 00 02 00 00       	push   $0x200$/;"	l
bb	test2.asm	/^  bb:	e9 ab 02 00 00       	jmp    36b <wait>$/;"	l
bb	testcase2.asm	/^  bb:	e9 ab 02 00 00       	jmp    36b <wait>$/;"	l
bb0	sh.asm	/^     bb0:	f3 0f 1e fb          	endbr32 $/;"	l
bb4	sh.asm	/^     bb4:	55                   	push   %ebp$/;"	l
bb4	usertests.asm	/^     bb4:	e8 ca 2d 00 00       	call   3983 <exit>$/;"	l
bb5	sh.asm	/^     bb5:	89 e5                	mov    %esp,%ebp$/;"	l
bb7	sh.asm	/^     bb7:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
bb9	usertests.asm	/^     bb9:	57                   	push   %edi$/;"	l
bba	sh.asm	/^     bba:	80 3a 00             	cmpb   $0x0,(%edx)$/;"	l
bba	usertests.asm	/^     bba:	57                   	push   %edi$/;"	l
bbb	usertests.asm	/^     bbb:	68 b1 41 00 00       	push   $0x41b1$/;"	l
bbd	sh.asm	/^     bbd:	74 21                	je     be0 <strlen+0x30>$/;"	l
bbf	sh.asm	/^     bbf:	31 c0                	xor    %eax,%eax$/;"	l
bc	grep.asm	/^  bc:	66 90                	xchg   %ax,%ax$/;"	l
bc	init.asm	/^  bc:	83 c4 10             	add    $0x10,%esp$/;"	l
bc	usertests.asm	/^      bc:	e8 5f 00 00 00       	call   120 <iputtest>$/;"	l
bc0	usertests.asm	/^     bc0:	6a 01                	push   $0x1$/;"	l
bc1	sh.asm	/^     bc1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
bc2	usertests.asm	/^     bc2:	e8 49 2f 00 00       	call   3b10 <printf>$/;"	l
bc7	usertests.asm	/^     bc7:	e8 b7 2d 00 00       	call   3983 <exit>$/;"	l
bc8	sh.asm	/^     bc8:	83 c0 01             	add    $0x1,%eax$/;"	l
bcache	bio.c	/^} bcache;$/;"	v	typeref:struct:__anon18
bcache	dist/bio.c	/^} bcache;$/;"	v	typeref:struct:__anon17
bcb	sh.asm	/^     bcb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)$/;"	l
bcc	usertests.asm	/^     bcc:	50                   	push   %eax$/;"	l
bcd	kernel.asm	/^  bcd = (sb & (1 << 2)) == 0;$/;"	d
bcd	usertests.asm	/^     bcd:	50                   	push   %eax$/;"	l
bce	usertests.asm	/^     bce:	68 fd 41 00 00       	push   $0x41fd$/;"	l
bcf	sh.asm	/^     bcf:	89 c1                	mov    %eax,%ecx$/;"	l
bcmd	sh.asm	/^    bcmd = (struct backcmd*)cmd;$/;"	d
bd	getnice.asm	/^  bd:	84 c0                	test   %al,%al$/;"	l
bd	ln.asm	/^  bd:	84 c0                	test   %al,%al$/;"	l
bd	ls.asm	/^  bd:	e8 fe 02 00 00       	call   3c0 <strlen>$/;"	l
bd	setnice.asm	/^  bd:	84 c0                	test   %al,%al$/;"	l
bd	sh.asm	/^      bd:	e8 41 0d 00 00       	call   e03 <chdir>$/;"	l
bd	swaptest.asm	/^  bd:	8b 5d 0c             	mov    0xc(%ebp),%ebx$/;"	l
bd	test1.asm	/^  bd:	68 58 0a 00 00       	push   $0xa58$/;"	l
bd	testcase1.asm	/^  bd:	68 58 0a 00 00       	push   $0xa58$/;"	l
bd	wc.asm	/^  bd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)$/;"	l
bd	zombie.asm	/^  bd:	74 21                	je     e0 <strlen+0x30>$/;"	l
bd1	sh.asm	/^     bd1:	75 f5                	jne    bc8 <strlen+0x18>$/;"	l
bd3	sh.asm	/^     bd3:	89 c8                	mov    %ecx,%eax$/;"	l
bd3	usertests.asm	/^     bd3:	6a 01                	push   $0x1$/;"	l
bd5	sh.asm	/^     bd5:	5d                   	pop    %ebp$/;"	l
bd5	usertests.asm	/^     bd5:	e8 36 2f 00 00       	call   3b10 <printf>$/;"	l
bd6	sh.asm	/^     bd6:	c3                   	ret    $/;"	l
bd7	sh.asm	/^     bd7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
bda	usertests.asm	/^     bda:	e8 a4 2d 00 00       	call   3983 <exit>$/;"	l
bde	sh.asm	/^     bde:	66 90                	xchg   %ax,%ax$/;"	l
bdf	usertests.asm	/^     bdf:	56                   	push   %esi$/;"	l
be	echo.asm	/^  be:	0f b6 01             	movzbl (%ecx),%eax$/;"	l
be	grep.asm	/^  be:	66 90                	xchg   %ax,%ax$/;"	l
be	mkdir.asm	/^  be:	0f b6 01             	movzbl (%ecx),%eax$/;"	l
be	rm.asm	/^  be:	0f b6 01             	movzbl (%ecx),%eax$/;"	l
be0	sh.asm	/^     be0:	31 c9                	xor    %ecx,%ecx$/;"	l
be0	usertests.asm	/^     be0:	56                   	push   %esi$/;"	l
be1	usertests.asm	/^     be1:	68 c0 41 00 00       	push   $0x41c0$/;"	l
be2	sh.asm	/^     be2:	5d                   	pop    %ebp$/;"	l
be3	sh.asm	/^     be3:	89 c8                	mov    %ecx,%eax$/;"	l
be5	sh.asm	/^     be5:	c3                   	ret    $/;"	l
be6	sh.asm	/^     be6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
be6	usertests.asm	/^     be6:	6a 01                	push   $0x1$/;"	l
be8	usertests.asm	/^     be8:	e8 23 2f 00 00       	call   3b10 <printf>$/;"	l
bed	sh.asm	/^     bed:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
bed	usertests.asm	/^     bed:	e8 91 2d 00 00       	call   3983 <exit>$/;"	l
begin_op	dist/log.c	/^begin_op(void)$/;"	f
begin_op	log.c	/^begin_op(void)$/;"	f
bf	cat.asm	/^  bf:	68 c0 0b 00 00       	push   $0xbc0$/;"	l
bf	getnice.asm	/^  bf:	74 0f                	je     d0 <strcmp+0x40>$/;"	l
bf	init.asm	/^  bf:	eb df                	jmp    a0 <main+0xa0>$/;"	l
bf	ln.asm	/^  bf:	74 0f                	je     d0 <strcmp+0x40>$/;"	l
bf	ps.asm	/^  bf:	89 c1                	mov    %eax,%ecx$/;"	l
bf	setnice.asm	/^  bf:	74 0f                	je     d0 <strcmp+0x40>$/;"	l
bf	zombie.asm	/^  bf:	31 c0                	xor    %eax,%eax$/;"	l
bf0	sh.asm	/^     bf0:	f3 0f 1e fb          	endbr32 $/;"	l
bf2	usertests.asm	/^     bf2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
bf4	sh.asm	/^     bf4:	55                   	push   %ebp$/;"	l
bf5	sh.asm	/^     bf5:	89 e5                	mov    %esp,%ebp$/;"	l
bf7	sh.asm	/^     bf7:	57                   	push   %edi$/;"	l
bf8	sh.asm	/^     bf8:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
bf9	usertests.asm	/^     bf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
bfb	sh.asm	/^     bfb:	8b 4d 10             	mov    0x10(%ebp),%ecx$/;"	l
bfe	sh.asm	/^     bfe:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
bfree	dist/fs.c	/^bfree(int dev, uint b)$/;"	f	file:
bfree	fs.c	/^bfree(int dev, uint b)$/;"	f	file:
bget	bio.c	/^bget(uint dev, uint blockno)$/;"	f	file:
bget	dist/bio.c	/^bget(uint dev, uint blockno)$/;"	f	file:
bigargtest	dist/usertests.c	/^bigargtest(void)$/;"	f
bigargtest	usertests.c	/^bigargtest(void)$/;"	f
bigdir	dist/usertests.c	/^bigdir(void)$/;"	f
bigdir	usertests.c	/^bigdir(void)$/;"	f
bigfile	dist/usertests.c	/^bigfile(void)$/;"	f
bigfile	usertests.c	/^bigfile(void)$/;"	f
bigwrite	dist/usertests.c	/^bigwrite(void)$/;"	f
bigwrite	usertests.c	/^bigwrite(void)$/;"	f
binit	bio.c	/^binit(void)$/;"	f
binit	dist/bio.c	/^binit(void)$/;"	f
blkno	swaptest.asm	/^	blkno = atoi(argv[1]);$/;"	d
block	dist/log.c	/^  int block[LOGSIZE];$/;"	m	struct:logheader	file:
block	log.c	/^  int block[LOGSIZE];$/;"	m	struct:logheader	file:
blockno	buf.h	/^  uint blockno;$/;"	m	struct:buf
blockno	dist/buf.h	/^  uint blockno;$/;"	m	struct:buf
bmap	dist/fs.c	/^bmap(struct inode *ip, uint bn)$/;"	f	file:
bmap	fs.c	/^bmap(struct inode *ip, uint bn)$/;"	f	file:
bmapstart	dist/fs.h	/^  uint bmapstart;    \/\/ Block number of first free map block$/;"	m	struct:superblock
bmapstart	fs.h	/^  uint bmapstart;    \/\/ Block number of first free map block$/;"	m	struct:superblock
bootmain	bootmain.c	/^bootmain(void)$/;"	f
bootmain	dist/bootmain.c	/^bootmain(void)$/;"	f
bp	cat.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	echo.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	getnice.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	grep.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	init.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	kernel.asm	/^		bp = bread(0, blkno + SWAPBASE + i);$/;"	d
bp	kernel.asm	/^    bp = bread(dev, BBLOCK(b, sb));$/;"	d
bp	kernel.asm	/^    bp = bread(dev, IBLOCK(inum, sb));$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, IBLOCK(ip->inum, sb));$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, addr);$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, bmap(ip, off\/BSIZE));$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, ip->addrs[NDIRECT]);$/;"	d
bp	kernel.asm	/^  bp = 0;$/;"	d
bp	kernel.asm	/^  bp = bread(dev, 1);$/;"	d
bp	kernel.asm	/^  bp = bread(dev, BBLOCK(b, sb));$/;"	d
bp	kernel.asm	/^  bp = bread(dev, bno);$/;"	d
bp	kernel.asm	/^  bp = bread(ip->dev, IBLOCK(ip->inum, sb));$/;"	d
bp	kill.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	ln.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	ls.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	mkdir.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	ps.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	rm.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	setnice.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	sh.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	stressfs.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	swaptest.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	test1.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	test2.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	testcase1.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	testcase2.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	usertests.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	wc.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	zombie.asm	/^  bp = (Header*)ap - 1;$/;"	d
bread	bio.c	/^bread(uint dev, uint blockno)$/;"	f
bread	dist/bio.c	/^bread(uint dev, uint blockno)$/;"	f
brelse	bio.c	/^brelse(struct buf *b)$/;"	f
brelse	dist/bio.c	/^brelse(struct buf *b)$/;"	f
bsstest	dist/usertests.c	/^bsstest(void)$/;"	f
bsstest	usertests.c	/^bsstest(void)$/;"	f
buf	bio.c	/^  struct buf buf[NBUF];$/;"	m	struct:__anon18	typeref:struct:__anon18::buf	file:
buf	buf.h	/^struct buf {$/;"	s
buf	cat.c	/^char buf[512];$/;"	v
buf	console.c	/^  char buf[INPUT_BUF];$/;"	m	struct:__anon6	file:
buf	dist/bio.c	/^  struct buf buf[NBUF];$/;"	m	struct:__anon17	typeref:struct:__anon17::buf	file:
buf	dist/buf.h	/^struct buf {$/;"	s
buf	dist/cat.c	/^char buf[512];$/;"	v
buf	dist/console.c	/^  char buf[INPUT_BUF];$/;"	m	struct:__anon14	file:
buf	dist/grep.c	/^char buf[1024];$/;"	v
buf	dist/usertests.c	/^char buf[8192];$/;"	v
buf	dist/wc.c	/^char buf[512];$/;"	v
buf	grep.c	/^char buf[1024];$/;"	v
buf	kernel.asm	/^  buf = (char*)p;$/;"	d
buf	usertests.c	/^char buf[8192];$/;"	v
buf	wc.c	/^char buf[512];$/;"	v
buffer1	swaptest.c	/^char buffer1[4096];$/;"	v
buffer2	swaptest.c	/^char buffer2[4096];$/;"	v
bwrite	bio.c	/^bwrite(struct buf *b)$/;"	f
bwrite	dist/bio.c	/^bwrite(struct buf *b)$/;"	f
bzero	dist/fs.c	/^bzero(int dev, int bno)$/;"	f	file:
bzero	fs.c	/^bzero(int dev, int bno)$/;"	f	file:
c	cat.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	echo.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	getnice.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	grep.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	init.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	initcode.asm	/^   c:	b8 07 00 00 00       	mov    $0x7,%eax$/;"	l
c	kernel.asm	/^        c = (c == '\\r') ? '\\n' : c;$/;"	d
c	kernel.asm	/^    c = fmt[++i] & 0xff;$/;"	d
c	kernel.asm	/^    c = input.buf[input.r++ % INPUT_BUF];$/;"	d
c	kernel.asm	/^  c = &cpus[cpuid()];$/;"	d
c	kernel.asm	/^  c = charcode[shift & (CTL | SHIFT)][data];$/;"	d
c	kernel.asm	/^  c = mycpu();$/;"	d
c	kill.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	ln.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	ls.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	mkdir.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	ps.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	rm.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	setnice.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	sh.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	stressfs.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	swaptest.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	test1.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	test2.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	testcase1.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	testcase2.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	usertests.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	usertests.asm	/^  c = sbrk(-(sbrk(0) - oldbrk));$/;"	d
c	usertests.asm	/^  c = sbrk(-4096);$/;"	d
c	usertests.asm	/^  c = sbrk(0);$/;"	d
c	usertests.asm	/^  c = sbrk(1);$/;"	d
c	usertests.asm	/^  c = sbrk(4096);$/;"	d
c	wc.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	zombie.asm	/^    c = fmt[i] & 0xff;$/;"	d
c0	forktest.asm	/^  c0:	e8 0b 01 00 00       	call   1d0 <strlen>$/;"	l
c0	grep.asm	/^  c0:	f3 0f 1e fb          	endbr32 $/;"	l
c0	kill.asm	/^  c0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax$/;"	l
c0	stressfs.asm	/^  c0:	56                   	push   %esi$/;"	l
c0	swaptest.asm	/^  c0:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx$/;"	l
c0	test2.asm	/^  c0:	dc 05 90 08 00 00    	faddl  0x890$/;"	d
c0	testcase2.asm	/^  c0:	dc 05 90 08 00 00    	faddl  0x890$/;"	d
c00	usertests.asm	/^     c00:	f3 0f 1e fb          	endbr32 $/;"	l
c01	sh.asm	/^     c01:	89 d7                	mov    %edx,%edi$/;"	l
c03	sh.asm	/^     c03:	fc                   	cld    $/;"	l
c04	sh.asm	/^     c04:	f3 aa                	rep stos %al,%es:(%edi)$/;"	l
c04	usertests.asm	/^     c04:	55                   	push   %ebp$/;"	l
c05	usertests.asm	/^     c05:	89 e5                	mov    %esp,%ebp$/;"	l
c06	sh.asm	/^     c06:	89 d0                	mov    %edx,%eax$/;"	l
c07	usertests.asm	/^     c07:	57                   	push   %edi$/;"	l
c08	sh.asm	/^     c08:	5f                   	pop    %edi$/;"	l
c08	usertests.asm	/^     c08:	56                   	push   %esi$/;"	l
c09	sh.asm	/^     c09:	5d                   	pop    %ebp$/;"	l
c09	usertests.asm	/^     c09:	53                   	push   %ebx$/;"	l
c0a	sh.asm	/^     c0a:	c3                   	ret    $/;"	l
c0a	usertests.asm	/^     c0a:	83 ec 24             	sub    $0x24,%esp$/;"	l
c0b	sh.asm	/^     c0b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
c0d	usertests.asm	/^     c0d:	68 0c 42 00 00       	push   $0x420c$/;"	l
c0f	sh.asm	/^     c0f:	90                   	nop$/;"	l
c1	echo.asm	/^  c1:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
c1	getnice.asm	/^  c1:	38 d8                	cmp    %bl,%al$/;"	l
c1	init.asm	/^  c1:	53                   	push   %ebx$/;"	l
c1	ln.asm	/^  c1:	38 d8                	cmp    %bl,%al$/;"	l
c1	mkdir.asm	/^  c1:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
c1	ps.asm	/^  c1:	75 f5                	jne    b8 <strlen+0x18>$/;"	l
c1	rm.asm	/^  c1:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
c1	setnice.asm	/^  c1:	38 d8                	cmp    %bl,%al$/;"	l
c1	stressfs.asm	/^  c1:	57                   	push   %edi$/;"	l
c1	usertests.asm	/^      c1:	e8 1a 0d 00 00       	call   de0 <mem>$/;"	l
c1	zombie.asm	/^  c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
c10	sh.asm	/^     c10:	f3 0f 1e fb          	endbr32 $/;"	l
c12	usertests.asm	/^     c12:	6a 01                	push   $0x1$/;"	l
c14	sh.asm	/^     c14:	55                   	push   %ebp$/;"	l
c14	usertests.asm	/^     c14:	e8 f7 2e 00 00       	call   3b10 <printf>$/;"	l
c15	sh.asm	/^     c15:	89 e5                	mov    %esp,%ebp$/;"	l
c17	sh.asm	/^     c17:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
c19	usertests.asm	/^     c19:	e8 5d 2d 00 00       	call   397b <fork>$/;"	l
c1a	sh.asm	/^     c1a:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx$/;"	l
c1e	sh.asm	/^     c1e:	0f b6 10             	movzbl (%eax),%edx$/;"	l
c1e	usertests.asm	/^     c1e:	83 c4 10             	add    $0x10,%esp$/;"	l
c2	init.asm	/^  c2:	53                   	push   %ebx$/;"	l
c2	ls.asm	/^  c2:	89 1c 24             	mov    %ebx,(%esp)$/;"	l
c2	sh.asm	/^      c2:	83 c4 10             	add    $0x10,%esp$/;"	l
c2	stressfs.asm	/^  c2:	e8 fc 02 00 00       	call   3c3 <write>$/;"	l
c2	test1.asm	/^  c2:	6a 01                	push   $0x1$/;"	l
c2	testcase1.asm	/^  c2:	6a 01                	push   $0x1$/;"	l
c21	sh.asm	/^     c21:	84 d2                	test   %dl,%dl$/;"	l
c21	usertests.asm	/^     c21:	85 c0                	test   %eax,%eax$/;"	l
c23	sh.asm	/^     c23:	75 16                	jne    c3b <strchr+0x2b>$/;"	l
c23	usertests.asm	/^     c23:	75 0b                	jne    c30 <preempt+0x30>$/;"	l
c25	sh.asm	/^     c25:	eb 21                	jmp    c48 <strchr+0x38>$/;"	l
c25	usertests.asm	/^     c25:	eb fe                	jmp    c25 <preempt+0x25>$/;"	l
c27	sh.asm	/^     c27:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
c27	usertests.asm	/^     c27:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
c2e	sh.asm	/^     c2e:	66 90                	xchg   %ax,%ax$/;"	l
c2e	usertests.asm	/^     c2e:	66 90                	xchg   %ax,%ax$/;"	l
c3	getnice.asm	/^  c3:	74 eb                	je     b0 <strcmp+0x20>$/;"	l
c3	init.asm	/^  c3:	68 c1 08 00 00       	push   $0x8c1$/;"	l
c3	ln.asm	/^  c3:	74 eb                	je     b0 <strcmp+0x20>$/;"	l
c3	ps.asm	/^  c3:	89 c8                	mov    %ecx,%eax$/;"	l
c3	setnice.asm	/^  c3:	74 eb                	je     b0 <strcmp+0x20>$/;"	l
c30	sh.asm	/^     c30:	0f b6 50 01          	movzbl 0x1(%eax),%edx$/;"	l
c30	usertests.asm	/^     c30:	89 c7                	mov    %eax,%edi$/;"	l
c32	usertests.asm	/^     c32:	e8 44 2d 00 00       	call   397b <fork>$/;"	l
c34	sh.asm	/^     c34:	83 c0 01             	add    $0x1,%eax$/;"	l
c37	sh.asm	/^     c37:	84 d2                	test   %dl,%dl$/;"	l
c37	usertests.asm	/^     c37:	89 c6                	mov    %eax,%esi$/;"	l
c39	sh.asm	/^     c39:	74 0d                	je     c48 <strchr+0x38>$/;"	l
c39	usertests.asm	/^     c39:	85 c0                	test   %eax,%eax$/;"	l
c3b	sh.asm	/^     c3b:	38 d1                	cmp    %dl,%cl$/;"	l
c3b	usertests.asm	/^     c3b:	75 03                	jne    c40 <preempt+0x40>$/;"	l
c3d	sh.asm	/^     c3d:	75 f1                	jne    c30 <strchr+0x20>$/;"	l
c3d	usertests.asm	/^     c3d:	eb fe                	jmp    c3d <preempt+0x3d>$/;"	l
c3f	sh.asm	/^     c3f:	5d                   	pop    %ebp$/;"	l
c3f	usertests.asm	/^     c3f:	90                   	nop$/;"	l
c4	cat.asm	/^  c4:	56                   	push   %esi$/;"	l
c4	echo.asm	/^  c4:	84 c0                	test   %al,%al$/;"	l
c4	grep.asm	/^  c4:	55                   	push   %ebp$/;"	l
c4	kill.asm	/^  c4:	83 c1 01             	add    $0x1,%ecx$/;"	l
c4	mkdir.asm	/^  c4:	84 c0                	test   %al,%al$/;"	l
c4	rm.asm	/^  c4:	84 c0                	test   %al,%al$/;"	l
c4	swaptest.asm	/^  c4:	88 14 01             	mov    %dl,(%ecx,%eax,1)$/;"	l
c4	test1.asm	/^  c4:	e8 c7 05 00 00       	call   690 <printf>$/;"	l
c4	testcase1.asm	/^  c4:	e8 c7 05 00 00       	call   690 <printf>$/;"	l
c4	wc.asm	/^  c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
c40	sh.asm	/^     c40:	c3                   	ret    $/;"	l
c40	usertests.asm	/^     c40:	83 ec 0c             	sub    $0xc,%esp$/;"	l
c41	sh.asm	/^     c41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
c43	usertests.asm	/^     c43:	8d 45 e0             	lea    -0x20(%ebp),%eax$/;"	l
c46	usertests.asm	/^     c46:	50                   	push   %eax$/;"	l
c47	usertests.asm	/^     c47:	e8 47 2d 00 00       	call   3993 <pipe>$/;"	l
c48	sh.asm	/^     c48:	31 c0                	xor    %eax,%eax$/;"	l
c4a	sh.asm	/^     c4a:	5d                   	pop    %ebp$/;"	l
c4b	sh.asm	/^     c4b:	c3                   	ret    $/;"	l
c4c	sh.asm	/^     c4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
c4c	usertests.asm	/^     c4c:	e8 2a 2d 00 00       	call   397b <fork>$/;"	l
c5	cat.asm	/^  c5:	e8 c1 02 00 00       	call   38b <read>$/;"	l
c5	forktest.asm	/^  c5:	83 c4 0c             	add    $0xc,%esp$/;"	l
c5	getnice.asm	/^  c5:	29 d8                	sub    %ebx,%eax$/;"	l
c5	grep.asm	/^  c5:	89 e5                	mov    %esp,%ebp$/;"	l
c5	ln.asm	/^  c5:	29 d8                	sub    %ebx,%eax$/;"	l
c5	ls.asm	/^  c5:	bb 14 0e 00 00       	mov    $0xe14,%ebx$/;"	l
c5	ps.asm	/^  c5:	5d                   	pop    %ebp$/;"	l
c5	setnice.asm	/^  c5:	29 d8                	sub    %ebx,%eax$/;"	l
c5	sh.asm	/^      c5:	85 c0                	test   %eax,%eax$/;"	l
c50	sh.asm	/^     c50:	f3 0f 1e fb          	endbr32 $/;"	l
c51	usertests.asm	/^     c51:	83 c4 10             	add    $0x10,%esp$/;"	l
c54	sh.asm	/^     c54:	55                   	push   %ebp$/;"	l
c54	usertests.asm	/^     c54:	89 c3                	mov    %eax,%ebx$/;"	l
c55	sh.asm	/^     c55:	89 e5                	mov    %esp,%ebp$/;"	l
c56	usertests.asm	/^     c56:	85 c0                	test   %eax,%eax$/;"	l
c57	sh.asm	/^     c57:	57                   	push   %edi$/;"	l
c58	sh.asm	/^     c58:	56                   	push   %esi$/;"	l
c58	usertests.asm	/^     c58:	75 3e                	jne    c98 <preempt+0x98>$/;"	l
c59	sh.asm	/^     c59:	31 f6                	xor    %esi,%esi$/;"	l
c5a	usertests.asm	/^     c5a:	83 ec 0c             	sub    $0xc,%esp$/;"	l
c5b	sh.asm	/^     c5b:	53                   	push   %ebx$/;"	l
c5c	sh.asm	/^     c5c:	89 f3                	mov    %esi,%ebx$/;"	l
c5d	usertests.asm	/^     c5d:	ff 75 e0             	pushl  -0x20(%ebp)$/;"	l
c5e	sh.asm	/^     c5e:	83 ec 1c             	sub    $0x1c,%esp$/;"	l
c6	echo.asm	/^  c6:	75 19                	jne    e1 <strcmp+0x31>$/;"	l
c6	mkdir.asm	/^  c6:	75 19                	jne    e1 <strcmp+0x31>$/;"	l
c6	ps.asm	/^  c6:	c3                   	ret    $/;"	l
c6	rm.asm	/^  c6:	75 19                	jne    e1 <strcmp+0x31>$/;"	l
c6	test2.asm	/^  c6:	d9 05 98 08 00 00    	flds   0x898$/;"	d
c6	testcase2.asm	/^  c6:	d9 05 98 08 00 00    	flds   0x898$/;"	d
c6	usertests.asm	/^      c6:	e8 95 09 00 00       	call   a60 <pipe1>$/;"	l
c60	usertests.asm	/^     c60:	e8 46 2d 00 00       	call   39ab <close>$/;"	l
c61	sh.asm	/^     c61:	8b 7d 08             	mov    0x8(%ebp),%edi$/;"	l
c64	sh.asm	/^     c64:	eb 33                	jmp    c99 <gets+0x49>$/;"	l
c65	usertests.asm	/^     c65:	83 c4 0c             	add    $0xc,%esp$/;"	l
c66	sh.asm	/^     c66:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
c68	usertests.asm	/^     c68:	6a 01                	push   $0x1$/;"	l
c6a	usertests.asm	/^     c6a:	68 d1 47 00 00       	push   $0x47d1$/;"	l
c6d	sh.asm	/^     c6d:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
c6f	usertests.asm	/^     c6f:	ff 75 e4             	pushl  -0x1c(%ebp)$/;"	l
c7	getnice.asm	/^  c7:	5b                   	pop    %ebx$/;"	l
c7	grep.asm	/^  c7:	57                   	push   %edi$/;"	l
c7	kill.asm	/^  c7:	83 c2 01             	add    $0x1,%edx$/;"	l
c7	ln.asm	/^  c7:	5b                   	pop    %ebx$/;"	l
c7	ps.asm	/^  c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
c7	setnice.asm	/^  c7:	5b                   	pop    %ebx$/;"	l
c7	sh.asm	/^      c7:	79 aa                	jns    73 <main+0x73>$/;"	l
c7	stressfs.asm	/^  c7:	83 c4 10             	add    $0x10,%esp$/;"	l
c7	swaptest.asm	/^  c7:	83 c0 01             	add    $0x1,%eax$/;"	l
c70	sh.asm	/^     c70:	83 ec 04             	sub    $0x4,%esp$/;"	l
c72	usertests.asm	/^     c72:	e8 2c 2d 00 00       	call   39a3 <write>$/;"	l
c73	sh.asm	/^     c73:	8d 45 e7             	lea    -0x19(%ebp),%eax$/;"	l
c76	sh.asm	/^     c76:	6a 01                	push   $0x1$/;"	l
c77	usertests.asm	/^     c77:	83 c4 10             	add    $0x10,%esp$/;"	l
c78	sh.asm	/^     c78:	50                   	push   %eax$/;"	l
c79	sh.asm	/^     c79:	6a 00                	push   $0x0$/;"	l
c7a	usertests.asm	/^     c7a:	83 f8 01             	cmp    $0x1,%eax$/;"	l
c7b	sh.asm	/^     c7b:	e8 2b 01 00 00       	call   dab <read>$/;"	l
c7d	usertests.asm	/^     c7d:	0f 85 a4 00 00 00    	jne    d27 <preempt+0x127>$/;"	l
c8	echo.asm	/^  c8:	eb 26                	jmp    f0 <strcmp+0x40>$/;"	l
c8	forktest.asm	/^  c8:	50                   	push   %eax$/;"	l
c8	getnice.asm	/^  c8:	5d                   	pop    %ebp$/;"	l
c8	grep.asm	/^  c8:	56                   	push   %esi$/;"	l
c8	init.asm	/^  c8:	6a 01                	push   $0x1$/;"	l
c8	ln.asm	/^  c8:	5d                   	pop    %ebp$/;"	l
c8	mkdir.asm	/^  c8:	eb 26                	jmp    f0 <strcmp+0x40>$/;"	l
c8	rm.asm	/^  c8:	eb 26                	jmp    f0 <strcmp+0x40>$/;"	l
c8	setnice.asm	/^  c8:	5d                   	pop    %ebp$/;"	l
c8	wc.asm	/^  c8:	83 ec 04             	sub    $0x4,%esp$/;"	l
c8	zombie.asm	/^  c8:	83 c0 01             	add    $0x1,%eax$/;"	l
c80	sh.asm	/^     c80:	83 c4 10             	add    $0x10,%esp$/;"	l
c83	sh.asm	/^     c83:	85 c0                	test   %eax,%eax$/;"	l
c83	usertests.asm	/^     c83:	83 ec 0c             	sub    $0xc,%esp$/;"	l
c85	sh.asm	/^     c85:	7e 1c                	jle    ca3 <gets+0x53>$/;"	l
c86	usertests.asm	/^     c86:	ff 75 e4             	pushl  -0x1c(%ebp)$/;"	l
c87	sh.asm	/^     c87:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax$/;"	l
c89	usertests.asm	/^     c89:	e8 1d 2d 00 00       	call   39ab <close>$/;"	l
c8b	sh.asm	/^     c8b:	83 c7 01             	add    $0x1,%edi$/;"	l
c8e	sh.asm	/^     c8e:	88 47 ff             	mov    %al,-0x1(%edi)$/;"	l
c8e	usertests.asm	/^     c8e:	83 c4 10             	add    $0x10,%esp$/;"	l
c9	forktest.asm	/^  c9:	68 b6 04 00 00       	push   $0x4b6$/;"	l
c9	getnice.asm	/^  c9:	c3                   	ret    $/;"	l
c9	grep.asm	/^  c9:	53                   	push   %ebx$/;"	l
c9	ln.asm	/^  c9:	c3                   	ret    $/;"	l
c9	setnice.asm	/^  c9:	c3                   	ret    $/;"	l
c9	sh.asm	/^      c9:	50                   	push   %eax$/;"	l
c9	test1.asm	/^  c9:	e8 b5 04 00 00       	call   583 <getpid>$/;"	l
c9	testcase1.asm	/^  c9:	e8 b5 04 00 00       	call   583 <getpid>$/;"	l
c91	sh.asm	/^     c91:	3c 0a                	cmp    $0xa,%al$/;"	l
c91	usertests.asm	/^     c91:	eb fe                	jmp    c91 <preempt+0x91>$/;"	l
c93	sh.asm	/^     c93:	74 23                	je     cb8 <gets+0x68>$/;"	l
c93	usertests.asm	/^     c93:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
c95	sh.asm	/^     c95:	3c 0d                	cmp    $0xd,%al$/;"	l
c97	sh.asm	/^     c97:	74 1f                	je     cb8 <gets+0x68>$/;"	l
c97	usertests.asm	/^     c97:	90                   	nop$/;"	l
c98	usertests.asm	/^     c98:	83 ec 0c             	sub    $0xc,%esp$/;"	l
c99	sh.asm	/^     c99:	83 c3 01             	add    $0x1,%ebx$/;"	l
c9b	usertests.asm	/^     c9b:	ff 75 e4             	pushl  -0x1c(%ebp)$/;"	l
c9c	sh.asm	/^     c9c:	89 fe                	mov    %edi,%esi$/;"	l
c9e	sh.asm	/^     c9e:	3b 5d 0c             	cmp    0xc(%ebp),%ebx$/;"	l
c9e	usertests.asm	/^     c9e:	e8 08 2d 00 00       	call   39ab <close>$/;"	l
ca	cat.asm	/^  ca:	83 c4 10             	add    $0x10,%esp$/;"	l
ca	echo.asm	/^  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
ca	getnice.asm	/^  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
ca	grep.asm	/^  ca:	83 ec 0c             	sub    $0xc,%esp$/;"	l
ca	init.asm	/^  ca:	e8 41 04 00 00       	call   510 <printf>$/;"	l
ca	kill.asm	/^  ca:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
ca	ln.asm	/^  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
ca	ls.asm	/^  ca:	89 c6                	mov    %eax,%esi$/;"	l
ca	mkdir.asm	/^  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
ca	rm.asm	/^  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
ca	setnice.asm	/^  ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
ca	sh.asm	/^      ca:	68 63 19 00 00       	push   $0x1963$/;"	l
ca	stressfs.asm	/^  ca:	83 eb 01             	sub    $0x1,%ebx$/;"	l
ca	swaptest.asm	/^  ca:	84 d2                	test   %dl,%dl$/;"	l
ca1	sh.asm	/^     ca1:	7c cd                	jl     c70 <gets+0x20>$/;"	l
ca3	sh.asm	/^     ca3:	89 f3                	mov    %esi,%ebx$/;"	l
ca3	usertests.asm	/^     ca3:	83 c4 0c             	add    $0xc,%esp$/;"	l
ca5	sh.asm	/^     ca5:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ca6	usertests.asm	/^     ca6:	68 00 20 00 00       	push   $0x2000$/;"	l
ca8	sh.asm	/^     ca8:	c6 03 00             	movb   $0x0,(%ebx)$/;"	l
cab	sh.asm	/^     cab:	8d 65 f4             	lea    -0xc(%ebp),%esp$/;"	l
cab	usertests.asm	/^     cab:	68 00 87 00 00       	push   $0x8700$/;"	l
cae	sh.asm	/^     cae:	5b                   	pop    %ebx$/;"	l
caf	sh.asm	/^     caf:	5e                   	pop    %esi$/;"	l
cat	cat.c	/^cat(int fd)$/;"	f
cat	dist/cat.c	/^cat(int fd)$/;"	f
cb	usertests.asm	/^      cb:	e8 30 0b 00 00       	call   c00 <preempt>$/;"	l
cb	wc.asm	/^  cb:	68 00 02 00 00       	push   $0x200$/;"	l
cb	zombie.asm	/^  cb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)$/;"	l
cb0	sh.asm	/^     cb0:	5f                   	pop    %edi$/;"	l
cb0	usertests.asm	/^     cb0:	ff 75 e0             	pushl  -0x20(%ebp)$/;"	l
cb1	sh.asm	/^     cb1:	5d                   	pop    %ebp$/;"	l
cb2	sh.asm	/^     cb2:	c3                   	ret    $/;"	l
cb3	sh.asm	/^     cb3:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
cb3	usertests.asm	/^     cb3:	e8 e3 2c 00 00       	call   399b <read>$/;"	l
cb7	sh.asm	/^     cb7:	90                   	nop$/;"	l
cb8	sh.asm	/^     cb8:	8b 75 08             	mov    0x8(%ebp),%esi$/;"	l
cb8	usertests.asm	/^     cb8:	83 c4 10             	add    $0x10,%esp$/;"	l
cbb	sh.asm	/^     cbb:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
cbb	usertests.asm	/^     cbb:	83 f8 01             	cmp    $0x1,%eax$/;"	l
cbe	sh.asm	/^     cbe:	01 de                	add    %ebx,%esi$/;"	l
cbe	usertests.asm	/^     cbe:	75 7e                	jne    d3e <preempt+0x13e>$/;"	l
cc	cat.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	echo.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	forktest.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	getnice.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	grep.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	init.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	kill.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	ln.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	ls.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	ls.asm	/^  cc:	e8 ef 02 00 00       	call   3c0 <strlen>$/;"	l
cc	mkdir.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	ps.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	rm.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	setnice.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	sh.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	stressfs.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	swaptest.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	swaptest.asm	/^  cc:	75 f2                	jne    c0 <strcpy+0x10>$/;"	l
cc	test1.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	test2.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	test2.asm	/^  cc:	df f1                	fcomip %st(1),%st$/;"	d
cc	testcase1.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	testcase2.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	testcase2.asm	/^  cc:	df f1                	fcomip %st(1),%st$/;"	d
cc	usertests.asm	/^      cc = cc * 2;$/;"	d
cc	usertests.asm	/^    cc = 1;$/;"	d
cc	usertests.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	usertests.asm	/^    cc = read(fd, buf, 300);$/;"	d
cc	usertests.asm	/^  cc = read(fd, buf, sizeof(buf));$/;"	d
cc	wc.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	zombie.asm	/^    cc = read(0, &c, 1);$/;"	d
cc0	sh.asm	/^     cc0:	89 f3                	mov    %esi,%ebx$/;"	l
cc0	usertests.asm	/^     cc0:	83 ec 0c             	sub    $0xc,%esp$/;"	l
cc2	sh.asm	/^     cc2:	c6 03 00             	movb   $0x0,(%ebx)$/;"	l
cc3	usertests.asm	/^     cc3:	ff 75 e0             	pushl  -0x20(%ebp)$/;"	l
cc5	sh.asm	/^     cc5:	8d 65 f4             	lea    -0xc(%ebp),%esp$/;"	l
cc6	usertests.asm	/^     cc6:	e8 e0 2c 00 00       	call   39ab <close>$/;"	l
cc8	sh.asm	/^     cc8:	5b                   	pop    %ebx$/;"	l
cc9	sh.asm	/^     cc9:	5e                   	pop    %esi$/;"	l
cca	sh.asm	/^     cca:	5f                   	pop    %edi$/;"	l
ccb	sh.asm	/^     ccb:	5d                   	pop    %ebp$/;"	l
ccb	usertests.asm	/^     ccb:	58                   	pop    %eax$/;"	l
ccc	sh.asm	/^     ccc:	c3                   	ret    $/;"	l
ccc	usertests.asm	/^     ccc:	5a                   	pop    %edx$/;"	l
ccd	sh.asm	/^     ccd:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
ccd	usertests.asm	/^     ccd:	68 3d 42 00 00       	push   $0x423d$/;"	l
cd	cat.asm	/^  cd:	89 c3                	mov    %eax,%ebx$/;"	l
cd	grep.asm	/^  cd:	8b 5d 08             	mov    0x8(%ebp),%ebx$/;"	l
cd	kill.asm	/^  cd:	84 c0                	test   %al,%al$/;"	l
cd	stressfs.asm	/^  cd:	75 e9                	jne    b8 <main+0xb8>$/;"	l
cd0	sh.asm	/^     cd0:	f3 0f 1e fb          	endbr32 $/;"	l
cd2	usertests.asm	/^     cd2:	6a 01                	push   $0x1$/;"	l
cd4	sh.asm	/^     cd4:	55                   	push   %ebp$/;"	l
cd4	usertests.asm	/^     cd4:	e8 37 2e 00 00       	call   3b10 <printf>$/;"	l
cd5	sh.asm	/^     cd5:	89 e5                	mov    %esp,%ebp$/;"	l
cd7	sh.asm	/^     cd7:	56                   	push   %esi$/;"	l
cd8	sh.asm	/^     cd8:	53                   	push   %ebx$/;"	l
cd9	sh.asm	/^     cd9:	83 ec 08             	sub    $0x8,%esp$/;"	l
cd9	usertests.asm	/^     cd9:	89 3c 24             	mov    %edi,(%esp)$/;"	l
cdc	sh.asm	/^     cdc:	6a 00                	push   $0x0$/;"	l
cdc	usertests.asm	/^     cdc:	e8 d2 2c 00 00       	call   39b3 <kill>$/;"	l
cde	sh.asm	/^     cde:	ff 75 08             	pushl  0x8(%ebp)$/;"	l
ce	forktest.asm	/^  ce:	6a 01                	push   $0x1$/;"	l
ce	ps.asm	/^  ce:	66 90                	xchg   %ax,%ax$/;"	l
ce	swaptest.asm	/^  ce:	89 c8                	mov    %ecx,%eax$/;"	l
ce	test1.asm	/^  ce:	89 c3                	mov    %eax,%ebx$/;"	l
ce	test2.asm	/^  ce:	77 f0                	ja     c0 <test_p1_2+0x80>$/;"	l
ce	testcase1.asm	/^  ce:	89 c3                	mov    %eax,%ebx$/;"	l
ce	testcase2.asm	/^  ce:	77 f0                	ja     c0 <test_p1_2+0x80>$/;"	l
ce1	sh.asm	/^     ce1:	e8 ed 00 00 00       	call   dd3 <open>$/;"	l
ce1	usertests.asm	/^     ce1:	89 34 24             	mov    %esi,(%esp)$/;"	l
ce4	usertests.asm	/^     ce4:	e8 ca 2c 00 00       	call   39b3 <kill>$/;"	l
ce6	sh.asm	/^     ce6:	83 c4 10             	add    $0x10,%esp$/;"	l
ce9	sh.asm	/^     ce9:	85 c0                	test   %eax,%eax$/;"	l
ce9	usertests.asm	/^     ce9:	89 1c 24             	mov    %ebx,(%esp)$/;"	l
ceb	sh.asm	/^     ceb:	78 2b                	js     d18 <stat+0x48>$/;"	l
cec	usertests.asm	/^     cec:	e8 c2 2c 00 00       	call   39b3 <kill>$/;"	l
ced	sh.asm	/^     ced:	83 ec 08             	sub    $0x8,%esp$/;"	l
cf	cat.asm	/^  cf:	85 c0                	test   %eax,%eax$/;"	l
cf	init.asm	/^  cf:	e8 af 02 00 00       	call   383 <exit>$/;"	l
cf	kill.asm	/^  cf:	74 0f                	je     e0 <strcmp+0x40>$/;"	l
cf	sh.asm	/^      cf:	68 31 13 00 00       	push   $0x1331$/;"	l
cf	stressfs.asm	/^  cf:	83 ec 0c             	sub    $0xc,%esp$/;"	l
cf	zombie.asm	/^  cf:	89 c1                	mov    %eax,%ecx$/;"	l
cf0	sh.asm	/^     cf0:	ff 75 0c             	pushl  0xc(%ebp)$/;"	l
cf1	usertests.asm	/^     cf1:	59                   	pop    %ecx$/;"	l
cf2	usertests.asm	/^     cf2:	5b                   	pop    %ebx$/;"	l
cf3	sh.asm	/^     cf3:	89 c3                	mov    %eax,%ebx$/;"	l
cf3	usertests.asm	/^     cf3:	68 46 42 00 00       	push   $0x4246$/;"	l
cf5	sh.asm	/^     cf5:	50                   	push   %eax$/;"	l
cf6	sh.asm	/^     cf6:	e8 f0 00 00 00       	call   deb <fstat>$/;"	l
cf8	usertests.asm	/^     cf8:	6a 01                	push   $0x1$/;"	l
cfa	usertests.asm	/^     cfa:	e8 11 2e 00 00       	call   3b10 <printf>$/;"	l
cfb	sh.asm	/^     cfb:	89 1c 24             	mov    %ebx,(%esp)$/;"	l
cfe	sh.asm	/^     cfe:	89 c6                	mov    %eax,%esi$/;"	l
cff	usertests.asm	/^     cff:	e8 87 2c 00 00       	call   398b <wait>$/;"	l
cgaputc	console.c	/^cgaputc(int c)$/;"	f	file:
cgaputc	dist/console.c	/^cgaputc(int c)$/;"	f	file:
chan	dist/proc.h	/^  void *chan;                  \/\/ If non-zero, sleeping on chan$/;"	m	struct:proc
chan	proc.h	/^  void *chan;                  \/\/ If non-zero, sleeping on chan$/;"	m	struct:proc
char	init.asm	/^char *argv[] = { "sh", 0 };$/;"	l
char	sh.asm	/^char symbols[] = "<|>&;()";$/;"	l
char	sh.asm	/^char whitespace[] = " \\t\\r\\n\\v";$/;"	l
char	swaptest.asm	/^char buffer1[4096];$/;"	l
char	swaptest.asm	/^char buffer2[4096];$/;"	l
checksum	dist/mp.h	/^  uchar checksum;               \/\/ all bytes must add up to 0$/;"	m	struct:mp
checksum	dist/mp.h	/^  uchar checksum;               \/\/ all bytes must add up to 0$/;"	m	struct:mpconf
checksum	mp.h	/^  uchar checksum;               \/\/ all bytes must add up to 0$/;"	m	struct:mp
checksum	mp.h	/^  uchar checksum;               \/\/ all bytes must add up to 0$/;"	m	struct:mpconf
clearpteu	dist/vm.c	/^clearpteu(pde_t *pgdir, char *uva)$/;"	f
clearpteu	vm.c	/^clearpteu(pde_t *pgdir, char *uva)$/;"	f
cli	dist/x86.h	/^cli(void)$/;"	f
cli	x86.h	/^cli(void)$/;"	f
cmd	dist/sh.c	/^  struct cmd *cmd;$/;"	m	struct:backcmd	typeref:struct:backcmd::cmd	file:
cmd	dist/sh.c	/^  struct cmd *cmd;$/;"	m	struct:redircmd	typeref:struct:redircmd::cmd	file:
cmd	dist/sh.c	/^struct cmd {$/;"	s	file:
cmd	sh.asm	/^      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);$/;"	d
cmd	sh.asm	/^      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);$/;"	d
cmd	sh.asm	/^    cmd = backcmd(cmd);$/;"	d
cmd	sh.asm	/^    cmd = listcmd(cmd, parseline(ps, es));$/;"	d
cmd	sh.asm	/^    cmd = pipecmd(cmd, parsepipe(ps, es));$/;"	d
cmd	sh.asm	/^  cmd = (struct execcmd*)ret;$/;"	d
cmd	sh.asm	/^  cmd = malloc(sizeof(*cmd));$/;"	d
cmd	sh.asm	/^  cmd = parseexec(ps, es);$/;"	d
cmd	sh.asm	/^  cmd = parseline(&s, es);$/;"	d
cmd	sh.asm	/^  cmd = parseline(ps, es);$/;"	d
cmd	sh.asm	/^  cmd = parsepipe(ps, es);$/;"	d
cmd	sh.asm	/^  cmd = parseredirs(cmd, ps, es);$/;"	d
cmd	sh.c	/^  struct cmd *cmd;$/;"	m	struct:backcmd	typeref:struct:backcmd::cmd	file:
cmd	sh.c	/^  struct cmd *cmd;$/;"	m	struct:redircmd	typeref:struct:redircmd::cmd	file:
cmd	sh.c	/^struct cmd {$/;"	s	file:
cmos_read	dist/lapic.c	/^cmos_read(uint reg)$/;"	f	file:
cmos_read	lapic.c	/^cmos_read(uint reg)$/;"	f	file:
cmostime	dist/lapic.c	/^cmostime(struct rtcdate *r)$/;"	f
cmostime	lapic.c	/^cmostime(struct rtcdate *r)$/;"	f
code	kernel.asm	/^  code = P2V(0x7000);$/;"	d
commit	dist/log.c	/^commit()$/;"	f	file:
commit	log.c	/^commit()$/;"	f	file:
committing	dist/log.c	/^  int committing;  \/\/ in commit(), please wait.$/;"	m	struct:log	file:
committing	log.c	/^  int committing;  \/\/ in commit(), please wait.$/;"	m	struct:log	file:
concreate	dist/usertests.c	/^concreate(void)$/;"	f
concreate	usertests.c	/^concreate(void)$/;"	f
conf	kernel.asm	/^  conf = (struct mpconf*) P2V((uint) mp->physaddr);$/;"	d
cons	console.c	/^} cons;$/;"	v	typeref:struct:__anon5	file:
cons	dist/console.c	/^} cons;$/;"	v	typeref:struct:__anon13	file:
consoleinit	console.c	/^consoleinit(void)$/;"	f
consoleinit	dist/console.c	/^consoleinit(void)$/;"	f
consoleintr	console.c	/^consoleintr(int (*getc)(void))$/;"	f
consoleintr	dist/console.c	/^consoleintr(int (*getc)(void))$/;"	f
consoleread	console.c	/^consoleread(struct inode *ip, char *dst, int n)$/;"	f
consoleread	dist/console.c	/^consoleread(struct inode *ip, char *dst, int n)$/;"	f
consolewrite	console.c	/^consolewrite(struct inode *ip, char *buf, int n)$/;"	f
consolewrite	dist/console.c	/^consolewrite(struct inode *ip, char *buf, int n)$/;"	f
consputc	console.c	/^consputc(int c)$/;"	f
consputc	dist/console.c	/^consputc(int c)$/;"	f
context	dist/proc.h	/^  struct context *context;     \/\/ swtch() here to run process$/;"	m	struct:proc	typeref:struct:proc::context
context	dist/proc.h	/^struct context {$/;"	s
context	proc.h	/^  struct context *context;     \/\/ swtch() here to run process$/;"	m	struct:proc	typeref:struct:proc::context
context	proc.h	/^struct context {$/;"	s
copyout	dist/vm.c	/^copyout(pde_t *pgdir, uint va, void *p, uint len)$/;"	f
copyout	vm.c	/^copyout(pde_t *pgdir, uint va, void *p, uint len)$/;"	f
copyuvm	dist/vm.c	/^copyuvm(pde_t *pgdir, uint sz)$/;"	f
copyuvm	vm.c	/^copyuvm(pde_t *pgdir, uint sz)$/;"	f
cprintf	console.c	/^cprintf(char *fmt, ...)$/;"	f
cprintf	dist/console.c	/^cprintf(char *fmt, ...)$/;"	f
cpu	dist/proc.h	/^struct cpu {$/;"	s
cpu	dist/spinlock.h	/^  struct cpu *cpu;   \/\/ The cpu holding the lock.$/;"	m	struct:spinlock	typeref:struct:spinlock::cpu
cpu	proc.h	/^struct cpu {$/;"	s
cpu	spinlock.h	/^  struct cpu *cpu;   \/\/ The cpu holding the lock.$/;"	m	struct:spinlock	typeref:struct:spinlock::cpu
cpuid	dist/proc.c	/^cpuid() {$/;"	f
cpuid	proc.c	/^cpuid() {$/;"	f
cpus	dist/mp.c	/^struct cpu cpus[NCPU];$/;"	v	typeref:struct:cpu
cpus	mp.c	/^struct cpu cpus[NCPU];$/;"	v	typeref:struct:cpu
cr3	dist/mmu.h	/^  void *cr3;         \/\/ Page directory base$/;"	m	struct:taskstate
cr3	mmu.h	/^  void *cr3;         \/\/ Page directory base$/;"	m	struct:taskstate
create	dist/sysfile.c	/^create(char *path, short type, short major, short minor)$/;"	f	file:
create	sysfile.c	/^create(char *path, short type, short major, short minor)$/;"	f	file:
createdelete	dist/usertests.c	/^createdelete(void)$/;"	f
createdelete	usertests.c	/^createdelete(void)$/;"	f
createtest	dist/usertests.c	/^createtest(void)$/;"	f
createtest	usertests.c	/^createtest(void)$/;"	f
crt	console.c	/^static ushort *crt = (ushort*)P2V(0xb8000);  \/\/ CGA memory$/;"	v	file:
crt	dist/console.c	/^static ushort *crt = (ushort*)P2V(0xb8000);  \/\/ CGA memory$/;"	v	file:
cs	dist/mmu.h	/^  uint cs : 16;         \/\/ code segment selector$/;"	m	struct:gatedesc
cs	dist/mmu.h	/^  ushort cs;$/;"	m	struct:taskstate
cs	dist/x86.h	/^  ushort cs;$/;"	m	struct:trapframe
cs	mmu.h	/^  uint cs : 16;         \/\/ code segment selector$/;"	m	struct:gatedesc
cs	mmu.h	/^  ushort cs;$/;"	m	struct:taskstate
cs	x86.h	/^  ushort cs;$/;"	m	struct:trapframe
ctlmap	dist/kbd.h	/^static uchar ctlmap[256] =$/;"	v
ctlmap	kbd.h	/^static uchar ctlmap[256] =$/;"	v
cwd	dist/proc.h	/^  struct inode *cwd;           \/\/ Current directory$/;"	m	struct:proc	typeref:struct:proc::inode
cwd	proc.h	/^  struct inode *cwd;           \/\/ Current directory$/;"	m	struct:proc	typeref:struct:proc::inode
d0	echo.asm	/^  d0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax$/;"	l
d0	forktest.asm	/^  d0:	e8 fe 02 00 00       	call   3d3 <write>$/;"	l
d0	getnice.asm	/^  d0:	31 c0                	xor    %eax,%eax$/;"	l
d0	grep.asm	/^  d0:	8b 75 0c             	mov    0xc(%ebp),%esi$/;"	l
d0	ln.asm	/^  d0:	31 c0                	xor    %eax,%eax$/;"	l
d0	mkdir.asm	/^  d0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax$/;"	l
d0	ps.asm	/^  d0:	31 c9                	xor    %ecx,%ecx$/;"	l
d0	rm.asm	/^  d0:	0f b6 41 01          	movzbl 0x1(%ecx),%eax$/;"	l
d0	setnice.asm	/^  d0:	31 c0                	xor    %eax,%eax$/;"	l
d0	swaptest.asm	/^  d0:	5b                   	pop    %ebx$/;"	l
d0	test1.asm	/^  d0:	58                   	pop    %eax$/;"	l
d0	test2.asm	/^  d0:	dd d8                	fstp   %st(0)$/;"	d
d0	testcase1.asm	/^  d0:	58                   	pop    %eax$/;"	l
d0	testcase2.asm	/^  d0:	dd d8                	fstp   %st(0)$/;"	d
d0	usertests.asm	/^      d0:	e8 8b 0c 00 00       	call   d60 <exitwait>$/;"	l
d0	wc.asm	/^  d0:	68 40 0c 00 00       	push   $0xc40$/;"	l
d00	sh.asm	/^     d00:	e8 b6 00 00 00       	call   dbb <close>$/;"	l
d04	usertests.asm	/^     d04:	e8 82 2c 00 00       	call   398b <wait>$/;"	l
d05	sh.asm	/^     d05:	83 c4 10             	add    $0x10,%esp$/;"	l
d08	sh.asm	/^     d08:	8d 65 f8             	lea    -0x8(%ebp),%esp$/;"	l
d09	usertests.asm	/^     d09:	e8 7d 2c 00 00       	call   398b <wait>$/;"	l
d0b	sh.asm	/^     d0b:	89 f0                	mov    %esi,%eax$/;"	l
d0d	sh.asm	/^     d0d:	5b                   	pop    %ebx$/;"	l
d0e	sh.asm	/^     d0e:	5e                   	pop    %esi$/;"	l
d0e	usertests.asm	/^     d0e:	5e                   	pop    %esi$/;"	l
d0f	sh.asm	/^     d0f:	5d                   	pop    %ebp$/;"	l
d0f	usertests.asm	/^     d0f:	5f                   	pop    %edi$/;"	l
d1	cat.asm	/^  d1:	7f cd                	jg     a0 <cat+0x10>$/;"	l
d1	kill.asm	/^  d1:	38 d8                	cmp    %bl,%al$/;"	l
d1	ls.asm	/^  d1:	ba 0e 00 00 00       	mov    $0xe,%edx$/;"	l
d1	swaptest.asm	/^  d1:	5d                   	pop    %ebp$/;"	l
d1	test1.asm	/^  d1:	5a                   	pop    %edx$/;"	l
d1	testcase1.asm	/^  d1:	5a                   	pop    %edx$/;"	l
d1	zombie.asm	/^  d1:	75 f5                	jne    c8 <strlen+0x18>$/;"	l
d10	sh.asm	/^     d10:	c3                   	ret    $/;"	l
d10	usertests.asm	/^     d10:	68 4f 42 00 00       	push   $0x424f$/;"	l
d11	sh.asm	/^     d11:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
d15	usertests.asm	/^     d15:	6a 01                	push   $0x1$/;"	l
d17	usertests.asm	/^     d17:	e8 f4 2d 00 00       	call   3b10 <printf>$/;"	l
d18	sh.asm	/^     d18:	be ff ff ff ff       	mov    $0xffffffff,%esi$/;"	l
d1c	usertests.asm	/^     d1c:	83 c4 10             	add    $0x10,%esp$/;"	l
d1d	sh.asm	/^     d1d:	eb e9                	jmp    d08 <stat+0x38>$/;"	l
d1f	sh.asm	/^     d1f:	90                   	nop$/;"	l
d1f	usertests.asm	/^     d1f:	8d 65 f4             	lea    -0xc(%ebp),%esp$/;"	l
d2	getnice.asm	/^  d2:	29 d8                	sub    %ebx,%eax$/;"	l
d2	ln.asm	/^  d2:	29 d8                	sub    %ebx,%eax$/;"	l
d2	ps.asm	/^  d2:	5d                   	pop    %ebp$/;"	l
d2	setnice.asm	/^  d2:	29 d8                	sub    %ebx,%eax$/;"	l
d2	stressfs.asm	/^  d2:	57                   	push   %edi$/;"	l
d2	swaptest.asm	/^  d2:	c3                   	ret    $/;"	l
d2	test1.asm	/^  d2:	6a 03                	push   $0x3$/;"	l
d2	test2.asm	/^  d2:	e8 54 03 00 00       	call   42b <ps>$/;"	l
d2	testcase1.asm	/^  d2:	6a 03                	push   $0x3$/;"	l
d2	testcase2.asm	/^  d2:	e8 54 03 00 00       	call   42b <ps>$/;"	l
d20	sh.asm	/^     d20:	f3 0f 1e fb          	endbr32 $/;"	l
d22	usertests.asm	/^     d22:	5b                   	pop    %ebx$/;"	l
d23	usertests.asm	/^     d23:	5e                   	pop    %esi$/;"	l
d24	sh.asm	/^     d24:	55                   	push   %ebp$/;"	l
d24	usertests.asm	/^     d24:	5f                   	pop    %edi$/;"	l
d25	sh.asm	/^     d25:	89 e5                	mov    %esp,%ebp$/;"	l
d25	usertests.asm	/^     d25:	5d                   	pop    %ebp$/;"	l
d26	usertests.asm	/^     d26:	c3                   	ret    $/;"	l
d27	sh.asm	/^     d27:	53                   	push   %ebx$/;"	l
d27	usertests.asm	/^     d27:	83 ec 08             	sub    $0x8,%esp$/;"	l
d28	sh.asm	/^     d28:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
d2a	usertests.asm	/^     d2a:	68 16 42 00 00       	push   $0x4216$/;"	l
d2b	sh.asm	/^     d2b:	0f be 02             	movsbl (%edx),%eax$/;"	l
d2e	sh.asm	/^     d2e:	8d 48 d0             	lea    -0x30(%eax),%ecx$/;"	l
d2f	usertests.asm	/^     d2f:	6a 01                	push   $0x1$/;"	l
d3	cat.asm	/^  d3:	75 1b                	jne    f0 <cat+0x60>$/;"	l
d3	grep.asm	/^  d3:	8b 7d 10             	mov    0x10(%ebp),%edi$/;"	l
d3	kill.asm	/^  d3:	74 eb                	je     c0 <strcmp+0x20>$/;"	l
d3	ps.asm	/^  d3:	89 c8                	mov    %ecx,%eax$/;"	l
d3	stressfs.asm	/^  d3:	e8 f3 02 00 00       	call   3cb <close>$/;"	l
d3	swaptest.asm	/^  d3:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
d3	zombie.asm	/^  d3:	89 c8                	mov    %ecx,%eax$/;"	l
d31	sh.asm	/^     d31:	80 f9 09             	cmp    $0x9,%cl$/;"	l
d31	usertests.asm	/^     d31:	e8 da 2d 00 00       	call   3b10 <printf>$/;"	l
d34	sh.asm	/^     d34:	b9 00 00 00 00       	mov    $0x0,%ecx$/;"	l
d36	usertests.asm	/^     d36:	83 c4 10             	add    $0x10,%esp$/;"	l
d39	sh.asm	/^     d39:	77 1a                	ja     d55 <atoi+0x35>$/;"	l
d39	usertests.asm	/^     d39:	e9 45 ff ff ff       	jmp    c83 <preempt+0x83>$/;"	l
d3b	sh.asm	/^     d3b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
d3e	usertests.asm	/^     d3e:	83 ec 08             	sub    $0x8,%esp$/;"	l
d3f	sh.asm	/^     d3f:	90                   	nop$/;"	l
d4	echo.asm	/^  d4:	83 c1 01             	add    $0x1,%ecx$/;"	l
d4	getnice.asm	/^  d4:	5b                   	pop    %ebx$/;"	l
d4	init.asm	/^  d4:	50                   	push   %eax$/;"	l
d4	ln.asm	/^  d4:	5b                   	pop    %ebx$/;"	l
d4	mkdir.asm	/^  d4:	83 c1 01             	add    $0x1,%ecx$/;"	l
d4	rm.asm	/^  d4:	83 c1 01             	add    $0x1,%ecx$/;"	l
d4	setnice.asm	/^  d4:	5b                   	pop    %ebx$/;"	l
d4	sh.asm	/^      d4:	6a 02                	push   $0x2$/;"	l
d4	test1.asm	/^  d4:	53                   	push   %ebx$/;"	l
d4	testcase1.asm	/^  d4:	53                   	push   %ebx$/;"	l
d40	sh.asm	/^     d40:	83 c2 01             	add    $0x1,%edx$/;"	l
d41	usertests.asm	/^     d41:	68 2a 42 00 00       	push   $0x422a$/;"	l
d43	sh.asm	/^     d43:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx$/;"	l
d46	sh.asm	/^     d46:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx$/;"	l
d46	usertests.asm	/^     d46:	6a 01                	push   $0x1$/;"	l
d48	usertests.asm	/^     d48:	e8 c3 2d 00 00       	call   3b10 <printf>$/;"	l
d4a	sh.asm	/^     d4a:	0f be 02             	movsbl (%edx),%eax$/;"	l
d4d	sh.asm	/^     d4d:	8d 58 d0             	lea    -0x30(%eax),%ebx$/;"	l
d4d	usertests.asm	/^     d4d:	83 c4 10             	add    $0x10,%esp$/;"	l
d5	cat.asm	/^  d5:	8d 65 f8             	lea    -0x8(%ebp),%esp$/;"	l
d5	forktest.asm	/^  d5:	8b 5d fc             	mov    -0x4(%ebp),%ebx$/;"	l
d5	getnice.asm	/^  d5:	5d                   	pop    %ebp$/;"	l
d5	init.asm	/^  d5:	50                   	push   %eax$/;"	l
d5	kill.asm	/^  d5:	29 d8                	sub    %ebx,%eax$/;"	l
d5	ln.asm	/^  d5:	5d                   	pop    %ebp$/;"	l
d5	ps.asm	/^  d5:	c3                   	ret    $/;"	l
d5	setnice.asm	/^  d5:	5d                   	pop    %ebp$/;"	l
d5	test1.asm	/^  d5:	e8 d9 04 00 00       	call   5b3 <setnice>$/;"	l
d5	testcase1.asm	/^  d5:	e8 d9 04 00 00       	call   5b3 <setnice>$/;"	l
d5	usertests.asm	/^      d5:	e8 a6 27 00 00       	call   2880 <rmdot>$/;"	l
d5	wc.asm	/^  d5:	ff 75 08             	pushl  0x8(%ebp)$/;"	l
d5	zombie.asm	/^  d5:	5d                   	pop    %ebp$/;"	l
d50	sh.asm	/^     d50:	80 fb 09             	cmp    $0x9,%bl$/;"	l
d50	usertests.asm	/^     d50:	eb cd                	jmp    d1f <preempt+0x11f>$/;"	l
d52	usertests.asm	/^     d52:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
d53	sh.asm	/^     d53:	76 eb                	jbe    d40 <atoi+0x20>$/;"	l
d55	sh.asm	/^     d55:	89 c8                	mov    %ecx,%eax$/;"	l
d57	sh.asm	/^     d57:	5b                   	pop    %ebx$/;"	l
d58	sh.asm	/^     d58:	5d                   	pop    %ebp$/;"	l
d59	sh.asm	/^     d59:	c3                   	ret    $/;"	l
d59	usertests.asm	/^     d59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
d5a	sh.asm	/^     d5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
d6	getnice.asm	/^  d6:	c3                   	ret    $/;"	l
d6	grep.asm	/^  d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
d6	init.asm	/^  d6:	68 cc 0b 00 00       	push   $0xbcc$/;"	l
d6	ln.asm	/^  d6:	c3                   	ret    $/;"	l
d6	ls.asm	/^  d6:	83 c4 0c             	add    $0xc,%esp$/;"	l
d6	ps.asm	/^  d6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
d6	setnice.asm	/^  d6:	c3                   	ret    $/;"	l
d6	sh.asm	/^      d6:	e8 45 0e 00 00       	call   f20 <printf>$/;"	l
d6	zombie.asm	/^  d6:	c3                   	ret    $/;"	l
d60	sh.asm	/^     d60:	f3 0f 1e fb          	endbr32 $/;"	l
d60	usertests.asm	/^     d60:	f3 0f 1e fb          	endbr32 $/;"	l
d64	sh.asm	/^     d64:	55                   	push   %ebp$/;"	l
d64	usertests.asm	/^     d64:	55                   	push   %ebp$/;"	l
d65	sh.asm	/^     d65:	89 e5                	mov    %esp,%ebp$/;"	l
d65	usertests.asm	/^     d65:	89 e5                	mov    %esp,%ebp$/;"	l
d67	sh.asm	/^     d67:	57                   	push   %edi$/;"	l
d67	usertests.asm	/^     d67:	56                   	push   %esi$/;"	l
d68	sh.asm	/^     d68:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
d68	usertests.asm	/^     d68:	be 64 00 00 00       	mov    $0x64,%esi$/;"	l
d6b	sh.asm	/^     d6b:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
d6d	usertests.asm	/^     d6d:	53                   	push   %ebx$/;"	l
d6e	sh.asm	/^     d6e:	56                   	push   %esi$/;"	l
d6e	usertests.asm	/^     d6e:	eb 10                	jmp    d80 <exitwait+0x20>$/;"	l
d6f	sh.asm	/^     d6f:	8b 75 0c             	mov    0xc(%ebp),%esi$/;"	l
d7	echo.asm	/^  d7:	83 c2 01             	add    $0x1,%edx$/;"	l
d7	getnice.asm	/^  d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
d7	kill.asm	/^  d7:	5b                   	pop    %ebx$/;"	l
d7	ln.asm	/^  d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
d7	mkdir.asm	/^  d7:	83 c2 01             	add    $0x1,%edx$/;"	l
d7	rm.asm	/^  d7:	83 c2 01             	add    $0x1,%edx$/;"	l
d7	setnice.asm	/^  d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
d7	test2.asm	/^  d7:	e8 47 03 00 00       	call   423 <yield>$/;"	l
d7	testcase2.asm	/^  d7:	e8 47 03 00 00       	call   423 <yield>$/;"	l
d7	zombie.asm	/^  d7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
d70	usertests.asm	/^     d70:	74 68                	je     dda <exitwait+0x7a>$/;"	l
d72	sh.asm	/^     d72:	85 c0                	test   %eax,%eax$/;"	l
d72	usertests.asm	/^     d72:	e8 14 2c 00 00       	call   398b <wait>$/;"	l
d74	sh.asm	/^     d74:	7e 0f                	jle    d85 <memmove+0x25>$/;"	l
d76	sh.asm	/^     d76:	01 d0                	add    %edx,%eax$/;"	l
d77	usertests.asm	/^     d77:	39 d8                	cmp    %ebx,%eax$/;"	l
d78	sh.asm	/^     d78:	89 d7                	mov    %edx,%edi$/;"	l
d79	usertests.asm	/^     d79:	75 2d                	jne    da8 <exitwait+0x48>$/;"	l
d7a	sh.asm	/^     d7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
d7b	usertests.asm	/^     d7b:	83 ee 01             	sub    $0x1,%esi$/;"	l
d7e	usertests.asm	/^     d7e:	74 41                	je     dc1 <exitwait+0x61>$/;"	l
d8	cat.asm	/^  d8:	5b                   	pop    %ebx$/;"	l
d8	forktest.asm	/^  d8:	c9                   	leave  $/;"	l
d8	kill.asm	/^  d8:	5d                   	pop    %ebp$/;"	l
d8	stressfs.asm	/^  d8:	58                   	pop    %eax$/;"	l
d8	wc.asm	/^  d8:	e8 2e 03 00 00       	call   40b <read>$/;"	l
d80	sh.asm	/^     d80:	a4                   	movsb  %ds:(%esi),%es:(%edi)$/;"	l
d80	usertests.asm	/^     d80:	e8 f6 2b 00 00       	call   397b <fork>$/;"	l
d81	sh.asm	/^     d81:	39 f8                	cmp    %edi,%eax$/;"	l
d83	sh.asm	/^     d83:	75 fb                	jne    d80 <memmove+0x20>$/;"	l
d85	sh.asm	/^     d85:	5e                   	pop    %esi$/;"	l
d85	usertests.asm	/^     d85:	89 c3                	mov    %eax,%ebx$/;"	l
d86	sh.asm	/^     d86:	89 d0                	mov    %edx,%eax$/;"	l
d87	usertests.asm	/^     d87:	85 c0                	test   %eax,%eax$/;"	l
d88	sh.asm	/^     d88:	5f                   	pop    %edi$/;"	l
d89	sh.asm	/^     d89:	5d                   	pop    %ebp$/;"	l
d89	usertests.asm	/^     d89:	79 e5                	jns    d70 <exitwait+0x10>$/;"	l
d8a	sh.asm	/^     d8a:	c3                   	ret    $/;"	l
d8b	sh.asm	/^     d8b:	b8 01 00 00 00       	mov    $0x1,%eax$/;"	l
d8b	usertests.asm	/^     d8b:	83 ec 08             	sub    $0x8,%esp$/;"	l
d8e	usertests.asm	/^     d8e:	68 b9 4d 00 00       	push   $0x4db9$/;"	l
d9	cat.asm	/^  d9:	5e                   	pop    %esi$/;"	l
d9	forktest.asm	/^  d9:	c3                   	ret    $/;"	l
d9	kill.asm	/^  d9:	c3                   	ret    $/;"	l
d9	ls.asm	/^  d9:	29 f2                	sub    %esi,%edx$/;"	l
d9	stressfs.asm	/^  d9:	5a                   	pop    %edx$/;"	l
d90	sh.asm	/^     d90:	cd 40                	int    $0x40$/;"	l
d92	sh.asm	/^     d92:	c3                   	ret    $/;"	l
d93	sh.asm	/^     d93:	b8 02 00 00 00       	mov    $0x2,%eax$/;"	l
d93	usertests.asm	/^     d93:	6a 01                	push   $0x1$/;"	l
d95	usertests.asm	/^     d95:	e8 76 2d 00 00       	call   3b10 <printf>$/;"	l
d98	sh.asm	/^     d98:	cd 40                	int    $0x40$/;"	l
d9a	sh.asm	/^     d9a:	c3                   	ret    $/;"	l
d9a	usertests.asm	/^     d9a:	83 c4 10             	add    $0x10,%esp$/;"	l
d9b	sh.asm	/^     d9b:	b8 03 00 00 00       	mov    $0x3,%eax$/;"	l
d9d	usertests.asm	/^     d9d:	8d 65 f8             	lea    -0x8(%ebp),%esp$/;"	l
da	cat.asm	/^  da:	5d                   	pop    %ebp$/;"	l
da	echo.asm	/^  da:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
da	forktest.asm	/^  da:	e8 d4 02 00 00       	call   3b3 <exit>$/;"	l
da	kill.asm	/^  da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
da	mkdir.asm	/^  da:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
da	rm.asm	/^  da:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
da	stressfs.asm	/^  da:	68 b5 08 00 00       	push   $0x8b5$/;"	l
da	swaptest.asm	/^  da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
da	test1.asm	/^  da:	89 1c 24             	mov    %ebx,(%esp)$/;"	l
da	testcase1.asm	/^  da:	89 1c 24             	mov    %ebx,(%esp)$/;"	l
da	usertests.asm	/^      da:	e8 61 26 00 00       	call   2740 <fourteen>$/;"	l
da0	sh.asm	/^     da0:	cd 40                	int    $0x40$/;"	l
da0	usertests.asm	/^     da0:	5b                   	pop    %ebx$/;"	l
da1	usertests.asm	/^     da1:	5e                   	pop    %esi$/;"	l
da2	sh.asm	/^     da2:	c3                   	ret    $/;"	l
da2	usertests.asm	/^     da2:	5d                   	pop    %ebp$/;"	l
da3	sh.asm	/^     da3:	b8 04 00 00 00       	mov    $0x4,%eax$/;"	l
da3	usertests.asm	/^     da3:	c3                   	ret    $/;"	l
da4	usertests.asm	/^     da4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
da8	sh.asm	/^     da8:	cd 40                	int    $0x40$/;"	l
da8	usertests.asm	/^     da8:	83 ec 08             	sub    $0x8,%esp$/;"	l
daa	sh.asm	/^     daa:	c3                   	ret    $/;"	l
dab	sh.asm	/^     dab:	b8 05 00 00 00       	mov    $0x5,%eax$/;"	l
dab	usertests.asm	/^     dab:	68 5b 42 00 00       	push   $0x425b$/;"	l
data	buf.h	/^  uchar data[BSIZE];$/;"	m	struct:buf
data	dist/buf.h	/^  uchar data[BSIZE];$/;"	m	struct:buf
data	dist/ioapic.c	/^  uint data;$/;"	m	struct:ioapic	file:
data	dist/pipe.c	/^  char data[PIPESIZE];$/;"	m	struct:pipe	file:
data	ioapic.c	/^  uint data;$/;"	m	struct:ioapic	file:
data	kernel.asm	/^    data = (shift & E0ESC ? data : data & 0x7F);$/;"	d
data	kernel.asm	/^  data = inb(KBDATAP);$/;"	d
data	pipe.c	/^  char data[PIPESIZE];$/;"	m	struct:pipe	file:
day	date.h	/^  uint day;$/;"	m	struct:rtcdate
day	dist/date.h	/^  uint day;$/;"	m	struct:rtcdate
db	cat.asm	/^  db:	c3                   	ret    $/;"	l
db	dist/mmu.h	/^  uint db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:segdesc
db	init.asm	/^  db:	68 d4 08 00 00       	push   $0x8d4$/;"	l
db	ls.asm	/^  db:	05 14 0e 00 00       	add    $0xe14,%eax$/;"	l
db	mmu.h	/^  uint db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:segdesc
db	sh.asm	/^      db:	83 c4 10             	add    $0x10,%esp$/;"	l
db0	sh.asm	/^     db0:	cd 40                	int    $0x40$/;"	l
db0	usertests.asm	/^     db0:	6a 01                	push   $0x1$/;"	l
db2	sh.asm	/^     db2:	c3                   	ret    $/;"	l
db2	usertests.asm	/^     db2:	e8 59 2d 00 00       	call   3b10 <printf>$/;"	l
db3	sh.asm	/^     db3:	b8 10 00 00 00       	mov    $0x10,%eax$/;"	l
db7	usertests.asm	/^     db7:	83 c4 10             	add    $0x10,%esp$/;"	l
db8	sh.asm	/^     db8:	cd 40                	int    $0x40$/;"	l
dba	sh.asm	/^     dba:	c3                   	ret    $/;"	l
dba	usertests.asm	/^     dba:	8d 65 f8             	lea    -0x8(%ebp),%esp$/;"	l
dbb	sh.asm	/^     dbb:	b8 15 00 00 00       	mov    $0x15,%eax$/;"	l
dbd	usertests.asm	/^     dbd:	5b                   	pop    %ebx$/;"	l
dbe	usertests.asm	/^     dbe:	5e                   	pop    %esi$/;"	l
dbf	usertests.asm	/^     dbf:	5d                   	pop    %ebp$/;"	l
dc	cat.asm	/^  dc:	83 ec 08             	sub    $0x8,%esp$/;"	l
dc	test2.asm	/^  dc:	d9 ee                	fldz   $/;"	d
dc	testcase2.asm	/^  dc:	d9 ee                	fldz   $/;"	d
dc0	sh.asm	/^     dc0:	cd 40                	int    $0x40$/;"	l
dc0	usertests.asm	/^     dc0:	c3                   	ret    $/;"	l
dc1	usertests.asm	/^     dc1:	83 ec 08             	sub    $0x8,%esp$/;"	l
dc2	sh.asm	/^     dc2:	c3                   	ret    $/;"	l
dc3	sh.asm	/^     dc3:	b8 06 00 00 00       	mov    $0x6,%eax$/;"	l
dc4	usertests.asm	/^     dc4:	68 6b 42 00 00       	push   $0x426b$/;"	l
dc8	sh.asm	/^     dc8:	cd 40                	int    $0x40$/;"	l
dc9	usertests.asm	/^     dc9:	6a 01                	push   $0x1$/;"	l
dca	sh.asm	/^     dca:	c3                   	ret    $/;"	l
dcb	sh.asm	/^     dcb:	b8 07 00 00 00       	mov    $0x7,%eax$/;"	l
dcb	usertests.asm	/^     dcb:	e8 40 2d 00 00       	call   3b10 <printf>$/;"	l
dd	echo.asm	/^  dd:	84 c0                	test   %al,%al$/;"	l
dd	grep.asm	/^  dd:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
dd	mkdir.asm	/^  dd:	84 c0                	test   %al,%al$/;"	l
dd	ps.asm	/^  dd:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
dd	rm.asm	/^  dd:	84 c0                	test   %al,%al$/;"	l
dd	test1.asm	/^  dd:	e8 d9 04 00 00       	call   5bb <getnice>$/;"	l
dd	testcase1.asm	/^  dd:	e8 d9 04 00 00       	call   5bb <getnice>$/;"	l
dd	wc.asm	/^  dd:	83 c4 10             	add    $0x10,%esp$/;"	l
dd0	sh.asm	/^     dd0:	cd 40                	int    $0x40$/;"	l
dd0	usertests.asm	/^     dd0:	83 c4 10             	add    $0x10,%esp$/;"	l
dd2	sh.asm	/^     dd2:	c3                   	ret    $/;"	l
dd3	sh.asm	/^     dd3:	b8 0f 00 00 00       	mov    $0xf,%eax$/;"	l
dd3	usertests.asm	/^     dd3:	8d 65 f8             	lea    -0x8(%ebp),%esp$/;"	l
dd6	usertests.asm	/^     dd6:	5b                   	pop    %ebx$/;"	l
dd7	usertests.asm	/^     dd7:	5e                   	pop    %esi$/;"	l
dd8	sh.asm	/^     dd8:	cd 40                	int    $0x40$/;"	l
dd8	usertests.asm	/^     dd8:	5d                   	pop    %ebp$/;"	l
dd9	usertests.asm	/^     dd9:	c3                   	ret    $/;"	l
dda	sh.asm	/^     dda:	c3                   	ret    $/;"	l
dda	usertests.asm	/^     dda:	e8 a4 2b 00 00       	call   3983 <exit>$/;"	l
ddb	sh.asm	/^     ddb:	b8 11 00 00 00       	mov    $0x11,%eax$/;"	l
ddf	usertests.asm	/^     ddf:	90                   	nop$/;"	l
de	getnice.asm	/^  de:	66 90                	xchg   %ax,%ax$/;"	l
de	ln.asm	/^  de:	66 90                	xchg   %ax,%ax$/;"	l
de	setnice.asm	/^  de:	66 90                	xchg   %ax,%ax$/;"	l
de	sh.asm	/^      de:	eb 93                	jmp    73 <main+0x73>$/;"	l
de	test2.asm	/^  de:	dc 05 90 08 00 00    	faddl  0x890$/;"	d
de	testcase2.asm	/^  de:	dc 05 90 08 00 00    	faddl  0x890$/;"	d
de	zombie.asm	/^  de:	66 90                	xchg   %ax,%ax$/;"	l
de0	sh.asm	/^     de0:	cd 40                	int    $0x40$/;"	l
de0	usertests.asm	/^     de0:	f3 0f 1e fb          	endbr32 $/;"	l
de2	sh.asm	/^     de2:	c3                   	ret    $/;"	l
de3	sh.asm	/^     de3:	b8 12 00 00 00       	mov    $0x12,%eax$/;"	l
de4	usertests.asm	/^     de4:	55                   	push   %ebp$/;"	l
de5	usertests.asm	/^     de5:	89 e5                	mov    %esp,%ebp$/;"	l
de7	usertests.asm	/^     de7:	56                   	push   %esi$/;"	l
de8	sh.asm	/^     de8:	cd 40                	int    $0x40$/;"	l
de8	usertests.asm	/^     de8:	31 f6                	xor    %esi,%esi$/;"	l
dea	sh.asm	/^     dea:	c3                   	ret    $/;"	l
dea	usertests.asm	/^     dea:	53                   	push   %ebx$/;"	l
deallocuvm	dist/vm.c	/^deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)$/;"	f
deallocuvm	vm.c	/^deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)$/;"	f
deb	sh.asm	/^     deb:	b8 08 00 00 00       	mov    $0x8,%eax$/;"	l
deb	usertests.asm	/^     deb:	83 ec 08             	sub    $0x8,%esp$/;"	l
dee	usertests.asm	/^     dee:	68 78 42 00 00       	push   $0x4278$/;"	l
default	kernel.asm	/^    default:$/;"	l
default	kernel.asm	/^  default:$/;"	l
dev	buf.h	/^  uint dev;$/;"	m	struct:buf
dev	dist/buf.h	/^  uint dev;$/;"	m	struct:buf
dev	dist/file.h	/^  uint dev;           \/\/ Device number$/;"	m	struct:inode
dev	dist/log.c	/^  int dev;$/;"	m	struct:log	file:
dev	dist/stat.h	/^  int dev;     \/\/ File system's disk device$/;"	m	struct:stat
dev	file.h	/^  uint dev;           \/\/ Device number$/;"	m	struct:inode
dev	log.c	/^  int dev;$/;"	m	struct:log	file:
dev	stat.h	/^  int dev;     \/\/ File system's disk device$/;"	m	struct:stat
devsw	dist/file.c	/^struct devsw devsw[NDEV];$/;"	v	typeref:struct:devsw
devsw	dist/file.h	/^struct devsw {$/;"	s
devsw	file.c	/^struct devsw devsw[NDEV];$/;"	v	typeref:struct:devsw
devsw	file.h	/^struct devsw {$/;"	s
df	cat.asm	/^  df:	68 68 08 00 00       	push   $0x868$/;"	l
df	echo.asm	/^  df:	74 0f                	je     f0 <strcmp+0x40>$/;"	l
df	forktest.asm	/^  df:	83 ec 0c             	sub    $0xc,%esp$/;"	l
df	mkdir.asm	/^  df:	74 0f                	je     f0 <strcmp+0x40>$/;"	l
df	rm.asm	/^  df:	74 0f                	je     f0 <strcmp+0x40>$/;"	l
df	stressfs.asm	/^  df:	6a 01                	push   $0x1$/;"	l
df	usertests.asm	/^      df:	e8 8c 24 00 00       	call   2570 <bigfile>$/;"	l
df0	sh.asm	/^     df0:	cd 40                	int    $0x40$/;"	l
df2	sh.asm	/^     df2:	c3                   	ret    $/;"	l
df3	sh.asm	/^     df3:	b8 13 00 00 00       	mov    $0x13,%eax$/;"	l
df3	usertests.asm	/^     df3:	6a 01                	push   $0x1$/;"	l
df5	usertests.asm	/^     df5:	e8 16 2d 00 00       	call   3b10 <printf>$/;"	l
df8	sh.asm	/^     df8:	cd 40                	int    $0x40$/;"	l
dfa	sh.asm	/^     dfa:	c3                   	ret    $/;"	l
dfa	usertests.asm	/^     dfa:	e8 04 2c 00 00       	call   3a03 <getpid>$/;"	l
dfb	sh.asm	/^     dfb:	b8 14 00 00 00       	mov    $0x14,%eax$/;"	l
dff	usertests.asm	/^     dff:	89 c3                	mov    %eax,%ebx$/;"	l
dinode	dist/fs.h	/^struct dinode {$/;"	s
dinode	fs.h	/^struct dinode {$/;"	s
dip	kernel.asm	/^    dip = (struct dinode*)bp->data + inum%IPB;$/;"	d
dip	kernel.asm	/^    dip = (struct dinode*)bp->data + ip->inum%IPB;$/;"	d
dip	kernel.asm	/^  dip = (struct dinode*)bp->data + ip->inum%IPB;$/;"	d
dirent	dist/fs.h	/^struct dirent {$/;"	s
dirent	fs.h	/^struct dirent {$/;"	s
dirfile	dist/usertests.c	/^dirfile(void)$/;"	f
dirfile	usertests.c	/^dirfile(void)$/;"	f
dirlink	dist/fs.c	/^dirlink(struct inode *dp, char *name, uint inum)$/;"	f
dirlink	fs.c	/^dirlink(struct inode *dp, char *name, uint inum)$/;"	f
dirlookup	dist/fs.c	/^dirlookup(struct inode *dp, char *name, uint *poff)$/;"	f
dirlookup	fs.c	/^dirlookup(struct inode *dp, char *name, uint *poff)$/;"	f
dirtest	dist/usertests.c	/^void dirtest(void)$/;"	f
dirtest	usertests.c	/^void dirtest(void)$/;"	f
disksize	memide.c	/^static int disksize;$/;"	v	file:
do_commit	kernel.asm	/^    do_commit = 1;$/;"	d
dpl	dist/mmu.h	/^  uint dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:gatedesc
dpl	dist/mmu.h	/^  uint dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:segdesc
dpl	mmu.h	/^  uint dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:gatedesc
dpl	mmu.h	/^  uint dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:segdesc
ds	dist/mmu.h	/^  ushort ds;$/;"	m	struct:taskstate
ds	dist/x86.h	/^  ushort ds;$/;"	m	struct:trapframe
ds	mmu.h	/^  ushort ds;$/;"	m	struct:taskstate
ds	x86.h	/^  ushort ds;$/;"	m	struct:trapframe
dst	cat.asm	/^  dst = vdst;$/;"	d
dst	echo.asm	/^  dst = vdst;$/;"	d
dst	forktest.asm	/^  dst = vdst;$/;"	d
dst	getnice.asm	/^  dst = vdst;$/;"	d
dst	grep.asm	/^  dst = vdst;$/;"	d
dst	init.asm	/^  dst = vdst;$/;"	d
dst	kill.asm	/^  dst = vdst;$/;"	d
dst	ln.asm	/^  dst = vdst;$/;"	d
dst	ls.asm	/^  dst = vdst;$/;"	d
dst	mkdir.asm	/^  dst = vdst;$/;"	d
dst	ps.asm	/^  dst = vdst;$/;"	d
dst	rm.asm	/^  dst = vdst;$/;"	d
dst	setnice.asm	/^  dst = vdst;$/;"	d
dst	sh.asm	/^  dst = vdst;$/;"	d
dst	stressfs.asm	/^  dst = vdst;$/;"	d
dst	swaptest.asm	/^  dst = vdst;$/;"	d
dst	test1.asm	/^  dst = vdst;$/;"	d
dst	test2.asm	/^  dst = vdst;$/;"	d
dst	testcase1.asm	/^  dst = vdst;$/;"	d
dst	testcase2.asm	/^  dst = vdst;$/;"	d
dst	usertests.asm	/^  dst = vdst;$/;"	d
dst	wc.asm	/^  dst = vdst;$/;"	d
dst	zombie.asm	/^  dst = vdst;$/;"	d
e	cat.asm	/^   e:	55                   	push   %ebp$/;"	l
e	console.c	/^  uint e;  \/\/ Edit index$/;"	m	struct:__anon6	file:
e	dist/console.c	/^  uint e;  \/\/ Edit index$/;"	m	struct:__anon14	file:
e	echo.asm	/^   e:	55                   	push   %ebp$/;"	l
e	getnice.asm	/^   e:	55                   	push   %ebp$/;"	l
e	grep.asm	/^   e:	55                   	push   %ebp$/;"	l
e	init.asm	/^   e:	55                   	push   %ebp$/;"	l
e	kernel.asm	/^  e = addr+len;$/;"	d
e	kill.asm	/^   e:	55                   	push   %ebp$/;"	l
e	ln.asm	/^   e:	83 39 03             	cmpl   $0x3,(%ecx)$/;"	l
e	ls.asm	/^   e:	55                   	push   %ebp$/;"	l
e	mkdir.asm	/^   e:	55                   	push   %ebp$/;"	l
e	rm.asm	/^   e:	55                   	push   %ebp$/;"	l
e	setnice.asm	/^   e:	55                   	push   %ebp$/;"	l
e	sh.asm	/^       e:	55                   	push   %ebp$/;"	l
e	swaptest.asm	/^   e:	55                   	push   %ebp$/;"	l
e	test1.asm	/^   e:	55                   	push   %ebp$/;"	l
e	test2.asm	/^   e:	55                   	push   %ebp$/;"	l
e	testcase1.asm	/^   e:	55                   	push   %ebp$/;"	l
e	testcase2.asm	/^   e:	55                   	push   %ebp$/;"	l
e	usertests.asm	/^       e:	55                   	push   %ebp$/;"	l
e	wc.asm	/^   e:	55                   	push   %ebp$/;"	l
e	zombie.asm	/^   e:	55                   	push   %ebp$/;"	l
e0	getnice.asm	/^  e0:	f3 0f 1e fb          	endbr32 $/;"	l
e0	grep.asm	/^  e0:	83 ec 08             	sub    $0x8,%esp$/;"	l
e0	init.asm	/^  e0:	e8 d6 02 00 00       	call   3bb <exec>$/;"	l
e0	kill.asm	/^  e0:	31 c0                	xor    %eax,%eax$/;"	l
e0	ln.asm	/^  e0:	f3 0f 1e fb          	endbr32 $/;"	l
e0	ls.asm	/^  e0:	52                   	push   %edx$/;"	l
e0	ps.asm	/^  e0:	f3 0f 1e fb          	endbr32 $/;"	l
e0	setnice.asm	/^  e0:	f3 0f 1e fb          	endbr32 $/;"	l
e0	sh.asm	/^      e0:	83 ec 0c             	sub    $0xc,%esp$/;"	l
e0	swaptest.asm	/^  e0:	f3 0f 1e fb          	endbr32 $/;"	l
e0	wc.asm	/^  e0:	89 c6                	mov    %eax,%esi$/;"	l
e0	zombie.asm	/^  e0:	31 c9                	xor    %ecx,%ecx$/;"	l
e00	sh.asm	/^     e00:	cd 40                	int    $0x40$/;"	l
e01	usertests.asm	/^     e01:	e8 75 2b 00 00       	call   397b <fork>$/;"	l
e02	sh.asm	/^     e02:	c3                   	ret    $/;"	l
e03	sh.asm	/^     e03:	b8 09 00 00 00       	mov    $0x9,%eax$/;"	l
e06	usertests.asm	/^     e06:	83 c4 10             	add    $0x10,%esp$/;"	l
e08	sh.asm	/^     e08:	cd 40                	int    $0x40$/;"	l
e09	usertests.asm	/^     e09:	85 c0                	test   %eax,%eax$/;"	l
e0a	sh.asm	/^     e0a:	c3                   	ret    $/;"	l
e0b	sh.asm	/^     e0b:	b8 0a 00 00 00       	mov    $0xa,%eax$/;"	l
e0b	usertests.asm	/^     e0b:	74 0f                	je     e1c <mem+0x3c>$/;"	l
e0d	usertests.asm	/^     e0d:	e9 8e 00 00 00       	jmp    ea0 <mem+0xc0>$/;"	l
e1	echo.asm	/^  e1:	38 d8                	cmp    %bl,%al$/;"	l
e1	ls.asm	/^  e1:	6a 20                	push   $0x20$/;"	l
e1	mkdir.asm	/^  e1:	38 d8                	cmp    %bl,%al$/;"	l
e1	rm.asm	/^  e1:	38 d8                	cmp    %bl,%al$/;"	l
e1	stressfs.asm	/^  e1:	e8 4a 04 00 00       	call   530 <printf>$/;"	l
e10	sh.asm	/^     e10:	cd 40                	int    $0x40$/;"	l
e12	sh.asm	/^     e12:	c3                   	ret    $/;"	l
e12	usertests.asm	/^     e12:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
e13	sh.asm	/^     e13:	b8 0b 00 00 00       	mov    $0xb,%eax$/;"	l
e18	sh.asm	/^     e18:	cd 40                	int    $0x40$/;"	l
e18	usertests.asm	/^     e18:	89 30                	mov    %esi,(%eax)$/;"	l
e1a	sh.asm	/^     e1a:	c3                   	ret    $/;"	l
e1a	usertests.asm	/^     e1a:	89 c6                	mov    %eax,%esi$/;"	l
e1b	sh.asm	/^     e1b:	b8 0c 00 00 00       	mov    $0xc,%eax$/;"	l
e1c	usertests.asm	/^     e1c:	83 ec 0c             	sub    $0xc,%esp$/;"	l
e1f	usertests.asm	/^     e1f:	68 11 27 00 00       	push   $0x2711$/;"	l
e2	forktest.asm	/^  e2:	68 8f 04 00 00       	push   $0x48f$/;"	l
e2	kill.asm	/^  e2:	29 d8                	sub    %ebx,%eax$/;"	l
e2	test1.asm	/^  e2:	83 c4 10             	add    $0x10,%esp$/;"	l
e2	testcase1.asm	/^  e2:	83 c4 10             	add    $0x10,%esp$/;"	l
e2	wc.asm	/^  e2:	85 c0                	test   %eax,%eax$/;"	l
e2	zombie.asm	/^  e2:	5d                   	pop    %ebp$/;"	l
e20	sh.asm	/^     e20:	cd 40                	int    $0x40$/;"	l
e22	sh.asm	/^     e22:	c3                   	ret    $/;"	l
e23	sh.asm	/^     e23:	b8 0d 00 00 00       	mov    $0xd,%eax$/;"	l
e24	usertests.asm	/^     e24:	e8 47 2f 00 00       	call   3d70 <malloc>$/;"	l
e28	sh.asm	/^     e28:	cd 40                	int    $0x40$/;"	l
e29	usertests.asm	/^     e29:	83 c4 10             	add    $0x10,%esp$/;"	l
e2a	sh.asm	/^     e2a:	c3                   	ret    $/;"	l
e2b	sh.asm	/^     e2b:	b8 0e 00 00 00       	mov    $0xe,%eax$/;"	l
e2c	usertests.asm	/^     e2c:	85 c0                	test   %eax,%eax$/;"	l
e2e	usertests.asm	/^     e2e:	75 e8                	jne    e18 <mem+0x38>$/;"	l
e3	echo.asm	/^  e3:	74 eb                	je     d0 <strcmp+0x20>$/;"	l
e3	grep.asm	/^  e3:	57                   	push   %edi$/;"	l
e3	ls.asm	/^  e3:	50                   	push   %eax$/;"	l
e3	mkdir.asm	/^  e3:	74 eb                	je     d0 <strcmp+0x20>$/;"	l
e3	rm.asm	/^  e3:	74 eb                	je     d0 <strcmp+0x20>$/;"	l
e3	sh.asm	/^      e3:	50                   	push   %eax$/;"	l
e3	zombie.asm	/^  e3:	89 c8                	mov    %ecx,%eax$/;"	l
e30	sh.asm	/^     e30:	cd 40                	int    $0x40$/;"	l
e30	usertests.asm	/^     e30:	85 f6                	test   %esi,%esi$/;"	l
e32	sh.asm	/^     e32:	c3                   	ret    $/;"	l
e32	usertests.asm	/^     e32:	74 18                	je     e4c <mem+0x6c>$/;"	l
e33	sh.asm	/^     e33:	b8 16 00 00 00       	mov    $0x16,%eax$/;"	l
e34	usertests.asm	/^     e34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
e38	sh.asm	/^     e38:	cd 40                	int    $0x40$/;"	l
e38	usertests.asm	/^     e38:	89 f0                	mov    %esi,%eax$/;"	l
e3a	sh.asm	/^     e3a:	c3                   	ret    $/;"	l
e3a	usertests.asm	/^     e3a:	83 ec 0c             	sub    $0xc,%esp$/;"	l
e3b	sh.asm	/^     e3b:	b8 17 00 00 00       	mov    $0x17,%eax$/;"	l
e3d	usertests.asm	/^     e3d:	8b 36                	mov    (%esi),%esi$/;"	l
e3f	usertests.asm	/^     e3f:	50                   	push   %eax$/;"	l
e4	cat.asm	/^  e4:	6a 01                	push   $0x1$/;"	l
e4	getnice.asm	/^  e4:	55                   	push   %ebp$/;"	l
e4	grep.asm	/^  e4:	56                   	push   %esi$/;"	l
e4	kill.asm	/^  e4:	5b                   	pop    %ebx$/;"	l
e4	ln.asm	/^  e4:	55                   	push   %ebp$/;"	l
e4	ls.asm	/^  e4:	e8 17 03 00 00       	call   400 <memset>$/;"	l
e4	ps.asm	/^  e4:	55                   	push   %ebp$/;"	l
e4	setnice.asm	/^  e4:	55                   	push   %ebp$/;"	l
e4	sh.asm	/^      e4:	e8 d2 0c 00 00       	call   dbb <close>$/;"	l
e4	swaptest.asm	/^  e4:	55                   	push   %ebp$/;"	l
e4	test2.asm	/^  e4:	d9 05 98 08 00 00    	flds   0x898$/;"	d
e4	testcase2.asm	/^  e4:	d9 05 98 08 00 00    	flds   0x898$/;"	d
e4	usertests.asm	/^      e4:	e8 b7 1c 00 00       	call   1da0 <subdir>$/;"	l
e4	wc.asm	/^  e4:	7e 62                	jle    148 <wc+0xa8>$/;"	l
e40	sh.asm	/^     e40:	cd 40                	int    $0x40$/;"	l
e40	usertests.asm	/^     e40:	e8 9b 2e 00 00       	call   3ce0 <free>$/;"	l
e42	sh.asm	/^     e42:	c3                   	ret    $/;"	l
e43	sh.asm	/^     e43:	b8 18 00 00 00       	mov    $0x18,%eax$/;"	l
e45	usertests.asm	/^     e45:	83 c4 10             	add    $0x10,%esp$/;"	l
e48	sh.asm	/^     e48:	cd 40                	int    $0x40$/;"	l
e48	usertests.asm	/^     e48:	85 f6                	test   %esi,%esi$/;"	l
e4a	sh.asm	/^     e4a:	c3                   	ret    $/;"	l
e4a	usertests.asm	/^     e4a:	75 ec                	jne    e38 <mem+0x58>$/;"	l
e4b	sh.asm	/^     e4b:	b8 19 00 00 00       	mov    $0x19,%eax$/;"	l
e4c	usertests.asm	/^     e4c:	83 ec 0c             	sub    $0xc,%esp$/;"	l
e4f	usertests.asm	/^     e4f:	68 00 50 00 00       	push   $0x5000$/;"	l
e5	echo.asm	/^  e5:	29 d8                	sub    %ebx,%eax$/;"	l
e5	getnice.asm	/^  e5:	89 e5                	mov    %esp,%ebp$/;"	l
e5	grep.asm	/^  e5:	e8 36 00 00 00       	call   120 <matchhere>$/;"	l
e5	init.asm	/^  e5:	5a                   	pop    %edx$/;"	l
e5	kill.asm	/^  e5:	5d                   	pop    %ebp$/;"	l
e5	ln.asm	/^  e5:	89 e5                	mov    %esp,%ebp$/;"	l
e5	mkdir.asm	/^  e5:	29 d8                	sub    %ebx,%eax$/;"	l
e5	ps.asm	/^  e5:	89 e5                	mov    %esp,%ebp$/;"	l
e5	rm.asm	/^  e5:	29 d8                	sub    %ebx,%eax$/;"	l
e5	setnice.asm	/^  e5:	89 e5                	mov    %esp,%ebp$/;"	l
e5	swaptest.asm	/^  e5:	89 e5                	mov    %esp,%ebp$/;"	l
e5	test1.asm	/^  e5:	83 f8 03             	cmp    $0x3,%eax$/;"	l
e5	testcase1.asm	/^  e5:	83 f8 03             	cmp    $0x3,%eax$/;"	l
e5	zombie.asm	/^  e5:	c3                   	ret    $/;"	l
e50	sh.asm	/^     e50:	cd 40                	int    $0x40$/;"	l
e52	sh.asm	/^     e52:	c3                   	ret    $/;"	l
e53	sh.asm	/^     e53:	b8 1a 00 00 00       	mov    $0x1a,%eax$/;"	l
e54	usertests.asm	/^     e54:	e8 17 2f 00 00       	call   3d70 <malloc>$/;"	l
e58	sh.asm	/^     e58:	cd 40                	int    $0x40$/;"	l
e59	usertests.asm	/^     e59:	83 c4 10             	add    $0x10,%esp$/;"	l
e5a	sh.asm	/^     e5a:	c3                   	ret    $/;"	l
e5b	sh.asm	/^     e5b:	b8 1b 00 00 00       	mov    $0x1b,%eax$/;"	l
e5c	usertests.asm	/^     e5c:	85 c0                	test   %eax,%eax$/;"	l
e5e	usertests.asm	/^     e5e:	74 20                	je     e80 <mem+0xa0>$/;"	l
e6	cat.asm	/^  e6:	e8 15 04 00 00       	call   500 <printf>$/;"	l
e6	init.asm	/^  e6:	59                   	pop    %ecx$/;"	l
e6	kill.asm	/^  e6:	c3                   	ret    $/;"	l
e6	stressfs.asm	/^  e6:	8d 85 de fd ff ff    	lea    -0x222(%ebp),%eax$/;"	l
e6	wc.asm	/^  e6:	31 ff                	xor    %edi,%edi$/;"	l
e6	zombie.asm	/^  e6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
e60	sh.asm	/^     e60:	cd 40                	int    $0x40$/;"	l
e60	usertests.asm	/^     e60:	83 ec 0c             	sub    $0xc,%esp$/;"	l
e62	sh.asm	/^     e62:	c3                   	ret    $/;"	l
e63	sh.asm	/^     e63:	66 90                	xchg   %ax,%ax$/;"	l
e63	usertests.asm	/^     e63:	50                   	push   %eax$/;"	l
e64	usertests.asm	/^     e64:	e8 77 2e 00 00       	call   3ce0 <free>$/;"	l
e65	sh.asm	/^     e65:	66 90                	xchg   %ax,%ax$/;"	l
e67	sh.asm	/^     e67:	66 90                	xchg   %ax,%ax$/;"	l
e69	sh.asm	/^     e69:	66 90                	xchg   %ax,%ax$/;"	l
e69	usertests.asm	/^     e69:	58                   	pop    %eax$/;"	l
e6a	usertests.asm	/^     e6a:	5a                   	pop    %edx$/;"	l
e6b	sh.asm	/^     e6b:	66 90                	xchg   %ax,%ax$/;"	l
e6b	usertests.asm	/^     e6b:	68 9c 42 00 00       	push   $0x429c$/;"	l
e6d	sh.asm	/^     e6d:	66 90                	xchg   %ax,%ax$/;"	l
e6f	sh.asm	/^     e6f:	90                   	nop$/;"	l
e7	echo.asm	/^  e7:	5b                   	pop    %ebx$/;"	l
e7	forktest.asm	/^  e7:	e8 e4 00 00 00       	call   1d0 <strlen>$/;"	l
e7	getnice.asm	/^  e7:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
e7	init.asm	/^  e7:	68 d7 08 00 00       	push   $0x8d7$/;"	l
e7	kill.asm	/^  e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
e7	ln.asm	/^  e7:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
e7	mkdir.asm	/^  e7:	5b                   	pop    %ebx$/;"	l
e7	ps.asm	/^  e7:	57                   	push   %edi$/;"	l
e7	rm.asm	/^  e7:	5b                   	pop    %ebx$/;"	l
e7	setnice.asm	/^  e7:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
e7	swaptest.asm	/^  e7:	53                   	push   %ebx$/;"	l
e70	sh.asm	/^     e70:	55                   	push   %ebp$/;"	l
e70	usertests.asm	/^     e70:	6a 01                	push   $0x1$/;"	l
e71	sh.asm	/^     e71:	89 e5                	mov    %esp,%ebp$/;"	l
e72	usertests.asm	/^     e72:	e8 99 2c 00 00       	call   3b10 <printf>$/;"	l
e73	sh.asm	/^     e73:	57                   	push   %edi$/;"	l
e74	sh.asm	/^     e74:	56                   	push   %esi$/;"	l
e75	sh.asm	/^     e75:	53                   	push   %ebx$/;"	l
e76	sh.asm	/^     e76:	83 ec 3c             	sub    $0x3c,%esp$/;"	l
e77	usertests.asm	/^     e77:	e8 07 2b 00 00       	call   3983 <exit>$/;"	l
e79	sh.asm	/^     e79:	89 4d c4             	mov    %ecx,-0x3c(%ebp)$/;"	l
e7c	sh.asm	/^     e7c:	89 d1                	mov    %edx,%ecx$/;"	l
e7c	usertests.asm	/^     e7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
e7e	sh.asm	/^     e7e:	89 45 b8             	mov    %eax,-0x48(%ebp)$/;"	l
e8	echo.asm	/^  e8:	5d                   	pop    %ebp$/;"	l
e8	mkdir.asm	/^  e8:	5d                   	pop    %ebp$/;"	l
e8	ps.asm	/^  e8:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
e8	rm.asm	/^  e8:	5d                   	pop    %ebp$/;"	l
e8	swaptest.asm	/^  e8:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
e8	test1.asm	/^  e8:	0f 84 52 01 00 00    	je     240 <test_p1_1+0x200>$/;"	l
e8	testcase1.asm	/^  e8:	0f 84 52 01 00 00    	je     240 <test_p1_1+0x200>$/;"	l
e8	wc.asm	/^  e8:	eb 14                	jmp    fe <wc+0x5e>$/;"	l
e80	usertests.asm	/^     e80:	83 ec 08             	sub    $0x8,%esp$/;"	l
e81	sh.asm	/^     e81:	85 d2                	test   %edx,%edx$/;"	l
e83	sh.asm	/^     e83:	0f 89 7f 00 00 00    	jns    f08 <printint+0x98>$/;"	l
e83	usertests.asm	/^     e83:	68 82 42 00 00       	push   $0x4282$/;"	l
e88	usertests.asm	/^     e88:	6a 01                	push   $0x1$/;"	l
e89	sh.asm	/^     e89:	f6 45 08 01          	testb  $0x1,0x8(%ebp)$/;"	l
e8a	usertests.asm	/^     e8a:	e8 81 2c 00 00       	call   3b10 <printf>$/;"	l
e8d	sh.asm	/^     e8d:	74 79                	je     f08 <printint+0x98>$/;"	l
e8f	sh.asm	/^     e8f:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)$/;"	l
e8f	usertests.asm	/^     e8f:	89 1c 24             	mov    %ebx,(%esp)$/;"	l
e9	echo.asm	/^  e9:	c3                   	ret    $/;"	l
e9	ls.asm	/^  e9:	83 c4 10             	add    $0x10,%esp$/;"	l
e9	mkdir.asm	/^  e9:	c3                   	ret    $/;"	l
e9	rm.asm	/^  e9:	c3                   	ret    $/;"	l
e9	sh.asm	/^      e9:	83 c4 10             	add    $0x10,%esp$/;"	l
e9	usertests.asm	/^      e9:	e8 42 15 00 00       	call   1630 <linktest>$/;"	l
e92	usertests.asm	/^     e92:	e8 1c 2b 00 00       	call   39b3 <kill>$/;"	l
e96	sh.asm	/^     e96:	f7 d9                	neg    %ecx$/;"	l
e97	usertests.asm	/^     e97:	e8 e7 2a 00 00       	call   3983 <exit>$/;"	l
e98	sh.asm	/^     e98:	31 db                	xor    %ebx,%ebx$/;"	l
e9a	sh.asm	/^     e9a:	8d 75 d7             	lea    -0x29(%ebp),%esi$/;"	l
e9c	usertests.asm	/^     e9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
e9d	sh.asm	/^     e9d:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
ea	echo.asm	/^  ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
ea	getnice.asm	/^  ea:	80 3a 00             	cmpb   $0x0,(%edx)$/;"	l
ea	grep.asm	/^  ea:	83 c4 10             	add    $0x10,%esp$/;"	l
ea	ln.asm	/^  ea:	80 3a 00             	cmpb   $0x0,(%edx)$/;"	l
ea	mkdir.asm	/^  ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
ea	rm.asm	/^  ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
ea	setnice.asm	/^  ea:	80 3a 00             	cmpb   $0x0,(%edx)$/;"	l
ea	test2.asm	/^  ea:	df f1                	fcomip %st(1),%st$/;"	d
ea	testcase2.asm	/^  ea:	df f1                	fcomip %st(1),%st$/;"	d
ea	wc.asm	/^  ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
ea0	sh.asm	/^     ea0:	89 c8                	mov    %ecx,%eax$/;"	l
ea0	usertests.asm	/^     ea0:	8d 65 f8             	lea    -0x8(%ebp),%esp$/;"	l
ea2	sh.asm	/^     ea2:	31 d2                	xor    %edx,%edx$/;"	l
ea3	usertests.asm	/^     ea3:	5b                   	pop    %ebx$/;"	l
ea4	sh.asm	/^     ea4:	89 cf                	mov    %ecx,%edi$/;"	l
ea4	usertests.asm	/^     ea4:	5e                   	pop    %esi$/;"	l
ea5	usertests.asm	/^     ea5:	5d                   	pop    %ebp$/;"	l
ea6	sh.asm	/^     ea6:	f7 75 c4             	divl   -0x3c(%ebp)$/;"	l
ea6	usertests.asm	/^     ea6:	e9 e0 2a 00 00       	jmp    398b <wait>$/;"	l
ea9	sh.asm	/^     ea9:	0f b6 92 78 13 00 00 	movzbl 0x1378(%edx),%edx$/;"	l
eab	usertests.asm	/^     eab:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
eaf	usertests.asm	/^     eaf:	90                   	nop$/;"	l
eargv	dist/sh.c	/^  char *eargv[MAXARGS];$/;"	m	struct:execcmd	file:
eargv	sh.c	/^  char *eargv[MAXARGS];$/;"	m	struct:execcmd	file:
eax	dist/mmu.h	/^  uint eax;          \/\/ More saved state (registers)$/;"	m	struct:taskstate
eax	dist/x86.h	/^  uint eax;$/;"	m	struct:trapframe
eax	mmu.h	/^  uint eax;          \/\/ More saved state (registers)$/;"	m	struct:taskstate
eax	x86.h	/^  uint eax;$/;"	m	struct:trapframe
eb	cat.asm	/^  eb:	e8 83 02 00 00       	call   373 <exit>$/;"	l
eb	ps.asm	/^  eb:	8b 4d 10             	mov    0x10(%ebp),%ecx$/;"	l
eb	swaptest.asm	/^  eb:	8b 55 0c             	mov    0xc(%ebp),%edx$/;"	l
eb0	sh.asm	/^     eb0:	89 45 c0             	mov    %eax,-0x40(%ebp)$/;"	l
eb0	usertests.asm	/^     eb0:	f3 0f 1e fb          	endbr32 $/;"	l
eb3	sh.asm	/^     eb3:	89 d8                	mov    %ebx,%eax$/;"	l
eb4	usertests.asm	/^     eb4:	55                   	push   %ebp$/;"	l
eb5	sh.asm	/^     eb5:	8d 5b 01             	lea    0x1(%ebx),%ebx$/;"	l
eb5	usertests.asm	/^     eb5:	89 e5                	mov    %esp,%ebp$/;"	l
eb7	usertests.asm	/^     eb7:	57                   	push   %edi$/;"	l
eb8	sh.asm	/^     eb8:	8b 4d c0             	mov    -0x40(%ebp),%ecx$/;"	l
eb8	usertests.asm	/^     eb8:	56                   	push   %esi$/;"	l
eb9	usertests.asm	/^     eb9:	53                   	push   %ebx$/;"	l
eba	usertests.asm	/^     eba:	83 ec 34             	sub    $0x34,%esp$/;"	l
ebb	sh.asm	/^     ebb:	88 14 1e             	mov    %dl,(%esi,%ebx,1)$/;"	l
ebd	usertests.asm	/^     ebd:	68 a4 42 00 00       	push   $0x42a4$/;"	l
ebe	sh.asm	/^     ebe:	39 7d c4             	cmp    %edi,-0x3c(%ebp)$/;"	l
ebp	dist/mmu.h	/^  uint *ebp;$/;"	m	struct:taskstate
ebp	dist/proc.h	/^  uint ebp;$/;"	m	struct:context
ebp	dist/x86.h	/^  uint ebp;$/;"	m	struct:trapframe
ebp	kernel.asm	/^    ebp = (uint*)ebp[0]; \/\/ saved %ebp$/;"	d
ebp	kernel.asm	/^  ebp = (uint*)v - 2;$/;"	d
ebp	mmu.h	/^  uint *ebp;$/;"	m	struct:taskstate
ebp	proc.h	/^  uint ebp;$/;"	m	struct:context
ebp	x86.h	/^  uint ebp;$/;"	m	struct:trapframe
ebx	dist/mmu.h	/^  uint ebx;$/;"	m	struct:taskstate
ebx	dist/proc.h	/^  uint ebx;$/;"	m	struct:context
ebx	dist/x86.h	/^  uint ebx;$/;"	m	struct:trapframe
ebx	mmu.h	/^  uint ebx;$/;"	m	struct:taskstate
ebx	proc.h	/^  uint ebx;$/;"	m	struct:context
ebx	x86.h	/^  uint ebx;$/;"	m	struct:trapframe
ec	forktest.asm	/^  ec:	83 c4 0c             	add    $0xc,%esp$/;"	l
ec	init.asm	/^  ec:	6a 01                	push   $0x1$/;"	l
ec	ls.asm	/^  ec:	8d 65 f8             	lea    -0x8(%ebp),%esp$/;"	l
ec	sh.asm	/^      ec:	eb 85                	jmp    73 <main+0x73>$/;"	l
ec	stressfs.asm	/^  ec:	59                   	pop    %ecx$/;"	l
ec	test2.asm	/^  ec:	77 f0                	ja     de <test_p1_2+0x9e>$/;"	l
ec	testcase2.asm	/^  ec:	77 f0                	ja     de <test_p1_2+0x9e>$/;"	l
ec1	sh.asm	/^     ec1:	76 dd                	jbe    ea0 <printint+0x30>$/;"	l
ec2	usertests.asm	/^     ec2:	6a 01                	push   $0x1$/;"	l
ec3	sh.asm	/^     ec3:	8b 4d bc             	mov    -0x44(%ebp),%ecx$/;"	l
ec4	usertests.asm	/^     ec4:	e8 47 2c 00 00       	call   3b10 <printf>$/;"	l
ec6	sh.asm	/^     ec6:	85 c9                	test   %ecx,%ecx$/;"	l
ec8	sh.asm	/^     ec8:	74 0c                	je     ed6 <printint+0x66>$/;"	l
ec9	usertests.asm	/^     ec9:	c7 04 24 b3 42 00 00 	movl   $0x42b3,(%esp)$/;"	l
eca	sh.asm	/^     eca:	c6 44 1d d8 2d       	movb   $0x2d,-0x28(%ebp,%ebx,1)$/;"	l
ecf	sh.asm	/^     ecf:	89 d8                	mov    %ebx,%eax$/;"	l
echoargv	dist/usertests.c	/^char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };$/;"	v
echoargv	usertests.c	/^char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };$/;"	v
ecx	dist/mmu.h	/^  uint ecx;$/;"	m	struct:taskstate
ecx	dist/x86.h	/^  uint ecx;$/;"	m	struct:trapframe
ecx	mmu.h	/^  uint ecx;$/;"	m	struct:taskstate
ecx	x86.h	/^  uint ecx;$/;"	m	struct:trapframe
ed	getnice.asm	/^  ed:	74 21                	je     110 <strlen+0x30>$/;"	l
ed	grep.asm	/^  ed:	85 c0                	test   %eax,%eax$/;"	l
ed	ln.asm	/^  ed:	74 21                	je     110 <strlen+0x30>$/;"	l
ed	setnice.asm	/^  ed:	74 21                	je     110 <strlen+0x30>$/;"	l
ed	stressfs.asm	/^  ed:	5b                   	pop    %ebx$/;"	l
ed	zombie.asm	/^  ed:	8d 76 00             	lea    0x0(%esi),%esi$/;"	l
ed0	usertests.asm	/^     ed0:	e8 fe 2a 00 00       	call   39d3 <unlink>$/;"	l
ed1	sh.asm	/^     ed1:	ba 2d 00 00 00       	mov    $0x2d,%edx$/;"	l
ed5	usertests.asm	/^     ed5:	5b                   	pop    %ebx$/;"	l
ed6	sh.asm	/^     ed6:	8b 7d b8             	mov    -0x48(%ebp),%edi$/;"	l
ed6	usertests.asm	/^     ed6:	5e                   	pop    %esi$/;"	l
ed7	usertests.asm	/^     ed7:	68 02 02 00 00       	push   $0x202$/;"	l
ed9	sh.asm	/^     ed9:	8d 5c 05 d7          	lea    -0x29(%ebp,%eax,1),%ebx$/;"	l
edc	usertests.asm	/^     edc:	68 b3 42 00 00       	push   $0x42b3$/;"	l
edd	sh.asm	/^     edd:	eb 07                	jmp    ee6 <printint+0x76>$/;"	l
edf	sh.asm	/^     edf:	90                   	nop$/;"	l
edi	dist/mmu.h	/^  uint edi;$/;"	m	struct:taskstate
edi	dist/proc.h	/^  uint edi;$/;"	m	struct:context
edi	dist/x86.h	/^  uint edi;$/;"	m	struct:trapframe
edi	mmu.h	/^  uint edi;$/;"	m	struct:taskstate
edi	proc.h	/^  uint edi;$/;"	m	struct:context
edi	x86.h	/^  uint edi;$/;"	m	struct:trapframe
edx	dist/mmu.h	/^  uint edx;$/;"	m	struct:taskstate
edx	dist/x86.h	/^  uint edx;$/;"	m	struct:trapframe
edx	mmu.h	/^  uint edx;$/;"	m	struct:taskstate
edx	x86.h	/^  uint edx;$/;"	m	struct:trapframe
ee	init.asm	/^  ee:	e8 1d 04 00 00       	call   510 <printf>$/;"	l
ee	kill.asm	/^  ee:	66 90                	xchg   %ax,%ax$/;"	l
ee	ps.asm	/^  ee:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
ee	sh.asm	/^      ee:	83 ec 0c             	sub    $0xc,%esp$/;"	l
ee	stressfs.asm	/^  ee:	6a 00                	push   $0x0$/;"	l
ee	swaptest.asm	/^  ee:	0f b6 01             	movzbl (%ecx),%eax$/;"	l
ee	test1.asm	/^  ee:	83 ec 08             	sub    $0x8,%esp$/;"	l
ee	test2.asm	/^  ee:	dd d8                	fstp   %st(0)$/;"	d
ee	testcase1.asm	/^  ee:	83 ec 08             	sub    $0x8,%esp$/;"	l
ee	testcase2.asm	/^  ee:	dd d8                	fstp   %st(0)$/;"	d
ee	usertests.asm	/^      ee:	e8 ad 13 00 00       	call   14a0 <unlinkread>$/;"	l
ee0	sh.asm	/^     ee0:	0f b6 13             	movzbl (%ebx),%edx$/;"	l
ee1	usertests.asm	/^     ee1:	e8 dd 2a 00 00       	call   39c3 <open>$/;"	l
ee3	sh.asm	/^     ee3:	83 eb 01             	sub    $0x1,%ebx$/;"	l
ee6	sh.asm	/^     ee6:	83 ec 04             	sub    $0x4,%esp$/;"	l
ee6	usertests.asm	/^     ee6:	83 c4 10             	add    $0x10,%esp$/;"	l
ee9	sh.asm	/^     ee9:	88 55 d7             	mov    %dl,-0x29(%ebp)$/;"	l
ee9	usertests.asm	/^     ee9:	85 c0                	test   %eax,%eax$/;"	l
eeb	usertests.asm	/^     eeb:	0f 88 26 01 00 00    	js     1017 <sharedfd+0x167>$/;"	l
eec	sh.asm	/^     eec:	6a 01                	push   $0x1$/;"	l
eee	sh.asm	/^     eee:	56                   	push   %esi$/;"	l
eef	sh.asm	/^     eef:	57                   	push   %edi$/;"	l
ef	forktest.asm	/^  ef:	50                   	push   %eax$/;"	l
ef	getnice.asm	/^  ef:	31 c0                	xor    %eax,%eax$/;"	l
ef	grep.asm	/^  ef:	75 1f                	jne    110 <matchstar+0x50>$/;"	l
ef	ln.asm	/^  ef:	31 c0                	xor    %eax,%eax$/;"	l
ef	ls.asm	/^  ef:	89 d8                	mov    %ebx,%eax$/;"	l
ef	setnice.asm	/^  ef:	31 c0                	xor    %eax,%eax$/;"	l
ef0	sh.asm	/^     ef0:	e8 be fe ff ff       	call   db3 <write>$/;"	l
ef1	usertests.asm	/^     ef1:	89 c7                	mov    %eax,%edi$/;"	l
ef3	usertests.asm	/^     ef3:	8d 75 de             	lea    -0x22(%ebp),%esi$/;"	l
ef5	sh.asm	/^     ef5:	83 c4 10             	add    $0x10,%esp$/;"	l
ef6	usertests.asm	/^     ef6:	bb e8 03 00 00       	mov    $0x3e8,%ebx$/;"	l
ef8	sh.asm	/^     ef8:	39 de                	cmp    %ebx,%esi$/;"	l
efa	sh.asm	/^     efa:	75 e4                	jne    ee0 <printint+0x70>$/;"	l
efb	usertests.asm	/^     efb:	e8 7b 2a 00 00       	call   397b <fork>$/;"	l
efc	sh.asm	/^     efc:	8d 65 f4             	lea    -0xc(%ebp),%esp$/;"	l
eff	sh.asm	/^     eff:	5b                   	pop    %ebx$/;"	l
efile	dist/sh.c	/^  char *efile;$/;"	m	struct:redircmd	file:
efile	sh.c	/^  char *efile;$/;"	m	struct:redircmd	file:
eflags	dist/mmu.h	/^  uint eflags;$/;"	m	struct:taskstate
eflags	dist/x86.h	/^  uint eflags;$/;"	m	struct:trapframe
eflags	kernel.asm	/^  eflags = readeflags();$/;"	d
eflags	mmu.h	/^  uint eflags;$/;"	m	struct:taskstate
eflags	x86.h	/^  uint eflags;$/;"	m	struct:trapframe
ehsize	dist/elf.h	/^  ushort ehsize;$/;"	m	struct:elfhdr
ehsize	elf.h	/^  ushort ehsize;$/;"	m	struct:elfhdr
eip	dist/mmu.h	/^  uint *eip;         \/\/ Saved state from last task switch$/;"	m	struct:taskstate
eip	dist/proc.h	/^  uint eip;$/;"	m	struct:context
eip	dist/x86.h	/^  uint eip;$/;"	m	struct:trapframe
eip	mmu.h	/^  uint *eip;         \/\/ Saved state from last task switch$/;"	m	struct:taskstate
eip	proc.h	/^  uint eip;$/;"	m	struct:context
eip	x86.h	/^  uint eip;$/;"	m	struct:trapframe
elf	dist/elf.h	/^  uchar elf[12];$/;"	m	struct:elfhdr
elf	elf.h	/^  uchar elf[12];$/;"	m	struct:elfhdr
elfhdr	dist/elf.h	/^struct elfhdr {$/;"	s
elfhdr	elf.h	/^struct elfhdr {$/;"	s
empty	kernel.asm	/^      empty = ip;$/;"	d
empty	kernel.asm	/^  empty = 0;$/;"	d
end_op	dist/log.c	/^end_op(void)$/;"	f
end_op	log.c	/^end_op(void)$/;"	f
endtime	dist/proc.h	/^  uint endtime;$/;"	m	struct:proc
endtime	proc.h	/^  uint endtime;$/;"	m	struct:proc
entry	dist/elf.h	/^  uint entry;$/;"	m	struct:elfhdr
entry	dist/entry.S	/^entry:$/;"	l
entry	dist/mp.h	/^  ushort entry;                 \/\/ entry count$/;"	m	struct:mpconf
entry	elf.h	/^  uint entry;$/;"	m	struct:elfhdr
entry	entry.S	/^entry:$/;"	l
entry	mp.h	/^  ushort entry;                 \/\/ entry count$/;"	m	struct:mpconf
entrypgdir	dist/main.c	/^pde_t entrypgdir[NPDENTRIES] = {$/;"	v
entrypgdir	dist/main.c	/^pde_t entrypgdir[];  \/\/ For entry.S$/;"	v
entrypgdir	main.c	/^pde_t entrypgdir[NPDENTRIES] = {$/;"	v
entrypgdir	main.c	/^pde_t entrypgdir[];  \/\/ For entry.S$/;"	v
ep	kernel.asm	/^  ep = (char*)curproc->sz;$/;"	d
epa	bootblock.asm	/^  epa = pa + count;$/;"	d
eph	bootblock.asm	/^  eph = ph + elf->phnum;$/;"	d
err	dist/x86.h	/^  uint err;$/;"	m	struct:trapframe
err	x86.h	/^  uint err;$/;"	m	struct:trapframe
es	dist/mmu.h	/^  ushort es;         \/\/ Even more saved state (segment selectors)$/;"	m	struct:taskstate
es	dist/x86.h	/^  ushort es;$/;"	m	struct:trapframe
es	mmu.h	/^  ushort es;         \/\/ Even more saved state (segment selectors)$/;"	m	struct:taskstate
es	sh.asm	/^  es = s + strlen(s);$/;"	d
es	x86.h	/^  ushort es;$/;"	m	struct:trapframe
esi	dist/mmu.h	/^  uint esi;$/;"	m	struct:taskstate
esi	dist/proc.h	/^  uint esi;$/;"	m	struct:context
esi	dist/x86.h	/^  uint esi;$/;"	m	struct:trapframe
esi	mmu.h	/^  uint esi;$/;"	m	struct:taskstate
esi	proc.h	/^  uint esi;$/;"	m	struct:context
esi	x86.h	/^  uint esi;$/;"	m	struct:trapframe
esp	dist/mmu.h	/^  uint *esp;$/;"	m	struct:taskstate
esp	dist/x86.h	/^  uint esp;$/;"	m	struct:trapframe
esp	mmu.h	/^  uint *esp;$/;"	m	struct:taskstate
esp	x86.h	/^  uint esp;$/;"	m	struct:trapframe
esp0	dist/mmu.h	/^  uint esp0;         \/\/ Stack pointers and segment selectors$/;"	m	struct:taskstate
esp0	mmu.h	/^  uint esp0;         \/\/ Stack pointers and segment selectors$/;"	m	struct:taskstate
esp1	dist/mmu.h	/^  uint *esp1;$/;"	m	struct:taskstate
esp1	mmu.h	/^  uint *esp1;$/;"	m	struct:taskstate
esp2	dist/mmu.h	/^  uint *esp2;$/;"	m	struct:taskstate
esp2	mmu.h	/^  uint *esp2;$/;"	m	struct:taskstate
exec	dist/exec.c	/^exec(char *path, char **argv)$/;"	f
exec	exec.c	/^exec(char *path, char **argv)$/;"	f
execcmd	dist/sh.c	/^execcmd(void)$/;"	f
execcmd	dist/sh.c	/^struct execcmd {$/;"	s	file:
execcmd	sh.c	/^execcmd(void)$/;"	f
execcmd	sh.c	/^struct execcmd {$/;"	s	file:
exectest	dist/usertests.c	/^exectest(void)$/;"	f
exectest	usertests.c	/^exectest(void)$/;"	f
exit	dist/initcode.S	/^exit:$/;"	l
exit	dist/proc.c	/^exit(void)$/;"	f
exit	initcode.S	/^exit:$/;"	l
exit	initcode.asm	/^exit:$/;"	l
exit	proc.c	/^exit(void)$/;"	f
exitiputtest	dist/usertests.c	/^exitiputtest(void)$/;"	f
exitiputtest	usertests.c	/^exitiputtest(void)$/;"	f
exitwait	dist/usertests.c	/^exitwait(void)$/;"	f
exitwait	usertests.c	/^exitwait(void)$/;"	f
f	Makefile	/^	dd if=\/dev\/zero of=xv6.img count=100000$/;"	m
f	Makefile	/^	dd if=\/dev\/zero of=xv6memfs.img count=10000$/;"	m
f	Makefile	/^	dd if=bootblock of=xv6.img conv=notrunc$/;"	m
f	Makefile	/^	dd if=bootblock of=xv6memfs.img conv=notrunc$/;"	m
f	Makefile	/^	dd if=kernel of=xv6.img seek=1 conv=notrunc$/;"	m
f	Makefile	/^	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc$/;"	m
f	cat.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	dist/Makefile	/^	dd if=\/dev\/zero of=xv6.img count=100000$/;"	m
f	dist/Makefile	/^	dd if=\/dev\/zero of=xv6memfs.img count=10000$/;"	m
f	dist/Makefile	/^	dd if=bootblock of=xv6.img conv=notrunc$/;"	m
f	dist/Makefile	/^	dd if=bootblock of=xv6memfs.img conv=notrunc$/;"	m
f	dist/Makefile	/^	dd if=kernel of=xv6.img seek=1 conv=notrunc$/;"	m
f	dist/Makefile	/^	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc$/;"	m
f	echo.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	forktest.asm	/^   f:	e8 9f 03 00 00       	call   3b3 <exit>$/;"	l
f	getnice.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	grep.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	init.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	kill.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	ls.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	mkdir.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	ps.asm	/^   f:	e8 6f 02 00 00       	call   283 <exit>$/;"	l
f	rm.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	setnice.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	sh.asm	/^       f:	89 e5                	mov    %esp,%ebp$/;"	l
f	swaptest.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	test1.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	test2.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	testcase1.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	testcase2.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	usertests.asm	/^       f:	89 e5                	mov    %esp,%ebp$/;"	l
f	wc.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f	zombie.asm	/^   f:	89 e5                	mov    %esp,%ebp$/;"	l
f0	cat.asm	/^  f0:	50                   	push   %eax$/;"	l
f0	echo.asm	/^  f0:	31 c0                	xor    %eax,%eax$/;"	l
f0	forktest.asm	/^  f0:	68 8f 04 00 00       	push   $0x48f$/;"	l
f0	kill.asm	/^  f0:	f3 0f 1e fb          	endbr32 $/;"	l
f0	mkdir.asm	/^  f0:	31 c0                	xor    %eax,%eax$/;"	l
f0	rm.asm	/^  f0:	31 c0                	xor    %eax,%eax$/;"	l
f0	stressfs.asm	/^  f0:	bb 14 00 00 00       	mov    $0x14,%ebx$/;"	l
f0	test2.asm	/^  f0:	e8 36 03 00 00       	call   42b <ps>$/;"	l
f0	testcase2.asm	/^  f0:	e8 36 03 00 00       	call   42b <ps>$/;"	l
f0	wc.asm	/^  f0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)$/;"	l
f0	zombie.asm	/^  f0:	f3 0f 1e fb          	endbr32 $/;"	l
f00	sh.asm	/^     f00:	5e                   	pop    %esi$/;"	l
f00	usertests.asm	/^     f00:	83 f8 01             	cmp    $0x1,%eax$/;"	l
f01	sh.asm	/^     f01:	5f                   	pop    %edi$/;"	l
f02	sh.asm	/^     f02:	5d                   	pop    %ebp$/;"	l
f03	sh.asm	/^     f03:	c3                   	ret    $/;"	l
f03	usertests.asm	/^     f03:	89 45 d4             	mov    %eax,-0x2c(%ebp)$/;"	l
f04	sh.asm	/^     f04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
f06	usertests.asm	/^     f06:	19 c0                	sbb    %eax,%eax$/;"	l
f08	sh.asm	/^     f08:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)$/;"	l
f08	usertests.asm	/^     f08:	83 ec 04             	sub    $0x4,%esp$/;"	l
f0b	usertests.asm	/^     f0b:	83 e0 f3             	and    $0xfffffff3,%eax$/;"	l
f0e	usertests.asm	/^     f0e:	6a 0a                	push   $0xa$/;"	l
f0f	sh.asm	/^     f0f:	eb 87                	jmp    e98 <printint+0x28>$/;"	l
f1	cat.asm	/^  f1:	50                   	push   %eax$/;"	l
f1	getnice.asm	/^  f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
f1	grep.asm	/^  f1:	0f be 17             	movsbl (%edi),%edx$/;"	l
f1	ln.asm	/^  f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
f1	ls.asm	/^  f1:	5b                   	pop    %ebx$/;"	l
f1	ps.asm	/^  f1:	89 d7                	mov    %edx,%edi$/;"	l
f1	setnice.asm	/^  f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
f1	sh.asm	/^      f1:	68 60 19 00 00       	push   $0x1960$/;"	l
f1	swaptest.asm	/^  f1:	0f b6 1a             	movzbl (%edx),%ebx$/;"	l
f1	test1.asm	/^  f1:	68 1b 0b 00 00       	push   $0xb1b$/;"	l
f1	testcase1.asm	/^  f1:	68 1b 0b 00 00       	push   $0xb1b$/;"	l
f10	usertests.asm	/^     f10:	83 c0 70             	add    $0x70,%eax$/;"	l
f11	sh.asm	/^     f11:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
f13	usertests.asm	/^     f13:	50                   	push   %eax$/;"	l
f14	usertests.asm	/^     f14:	56                   	push   %esi$/;"	l
f15	usertests.asm	/^     f15:	e8 c6 28 00 00       	call   37e0 <memset>$/;"	l
f18	sh.asm	/^     f18:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
f1a	usertests.asm	/^     f1a:	83 c4 10             	add    $0x10,%esp$/;"	l
f1d	usertests.asm	/^     f1d:	eb 06                	jmp    f25 <sharedfd+0x75>$/;"	l
f1f	sh.asm	/^     f1f:	90                   	nop$/;"	l
f1f	usertests.asm	/^     f1f:	90                   	nop$/;"	l
f2	cat.asm	/^  f2:	68 7a 08 00 00       	push   $0x87a$/;"	l
f2	echo.asm	/^  f2:	29 d8                	sub    %ebx,%eax$/;"	l
f2	ls.asm	/^  f2:	5e                   	pop    %esi$/;"	l
f2	mkdir.asm	/^  f2:	29 d8                	sub    %ebx,%eax$/;"	l
f2	rm.asm	/^  f2:	29 d8                	sub    %ebx,%eax$/;"	l
f20	sh.asm	/^     f20:	f3 0f 1e fb          	endbr32 $/;"	l
f20	usertests.asm	/^     f20:	83 eb 01             	sub    $0x1,%ebx$/;"	l
f23	usertests.asm	/^     f23:	74 26                	je     f4b <sharedfd+0x9b>$/;"	l
f24	sh.asm	/^     f24:	55                   	push   %ebp$/;"	l
f25	sh.asm	/^     f25:	89 e5                	mov    %esp,%ebp$/;"	l
f25	usertests.asm	/^     f25:	83 ec 04             	sub    $0x4,%esp$/;"	l
f27	sh.asm	/^     f27:	57                   	push   %edi$/;"	l
f28	sh.asm	/^     f28:	56                   	push   %esi$/;"	l
f28	usertests.asm	/^     f28:	6a 0a                	push   $0xa$/;"	l
f29	sh.asm	/^     f29:	53                   	push   %ebx$/;"	l
f2a	sh.asm	/^     f2a:	83 ec 2c             	sub    $0x2c,%esp$/;"	l
f2a	usertests.asm	/^     f2a:	56                   	push   %esi$/;"	l
f2b	usertests.asm	/^     f2b:	57                   	push   %edi$/;"	l
f2c	usertests.asm	/^     f2c:	e8 72 2a 00 00       	call   39a3 <write>$/;"	l
f2d	sh.asm	/^     f2d:	8b 75 0c             	mov    0xc(%ebp),%esi$/;"	l
f3	init.asm	/^  f3:	e8 8b 02 00 00       	call   383 <exit>$/;"	l
f3	ls.asm	/^  f3:	5d                   	pop    %ebp$/;"	l
f3	ps.asm	/^  f3:	fc                   	cld    $/;"	l
f3	usertests.asm	/^      f3:	e8 08 29 00 00       	call   2a00 <dirfile>$/;"	l
f30	sh.asm	/^     f30:	0f b6 1e             	movzbl (%esi),%ebx$/;"	l
f31	usertests.asm	/^     f31:	83 c4 10             	add    $0x10,%esp$/;"	l
f33	sh.asm	/^     f33:	84 db                	test   %bl,%bl$/;"	l
f34	usertests.asm	/^     f34:	83 f8 0a             	cmp    $0xa,%eax$/;"	l
f35	sh.asm	/^     f35:	0f 84 b4 00 00 00    	je     fef <printf+0xcf>$/;"	l
f37	usertests.asm	/^     f37:	74 e7                	je     f20 <sharedfd+0x70>$/;"	l
f39	usertests.asm	/^     f39:	83 ec 08             	sub    $0x8,%esp$/;"	l
f3b	sh.asm	/^     f3b:	8d 45 10             	lea    0x10(%ebp),%eax$/;"	l
f3c	usertests.asm	/^     f3c:	68 a4 4f 00 00       	push   $0x4fa4$/;"	l
f3e	sh.asm	/^     f3e:	83 c6 01             	add    $0x1,%esi$/;"	l
f4	echo.asm	/^  f4:	5b                   	pop    %ebx$/;"	l
f4	grep.asm	/^  f4:	84 d2                	test   %dl,%dl$/;"	l
f4	kill.asm	/^  f4:	55                   	push   %ebp$/;"	l
f4	ls.asm	/^  f4:	c3                   	ret    $/;"	l
f4	mkdir.asm	/^  f4:	5b                   	pop    %ebx$/;"	l
f4	ps.asm	/^  f4:	f3 aa                	rep stos %al,%es:(%edi)$/;"	l
f4	rm.asm	/^  f4:	5b                   	pop    %ebx$/;"	l
f4	swaptest.asm	/^  f4:	84 c0                	test   %al,%al$/;"	l
f4	zombie.asm	/^  f4:	55                   	push   %ebp$/;"	l
f41	sh.asm	/^     f41:	8d 7d e7             	lea    -0x19(%ebp),%edi$/;"	l
f41	usertests.asm	/^     f41:	6a 01                	push   $0x1$/;"	l
f43	usertests.asm	/^     f43:	e8 c8 2b 00 00       	call   3b10 <printf>$/;"	l
f44	sh.asm	/^     f44:	31 d2                	xor    %edx,%edx$/;"	l
f46	sh.asm	/^     f46:	89 45 d0             	mov    %eax,-0x30(%ebp)$/;"	l
f48	usertests.asm	/^     f48:	83 c4 10             	add    $0x10,%esp$/;"	l
f49	sh.asm	/^     f49:	eb 33                	jmp    f7e <printf+0x5e>$/;"	l
f4b	sh.asm	/^     f4b:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
f4b	usertests.asm	/^     f4b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx$/;"	l
f4e	usertests.asm	/^     f4e:	85 c9                	test   %ecx,%ecx$/;"	l
f4f	sh.asm	/^     f4f:	90                   	nop$/;"	l
f5	echo.asm	/^  f5:	5d                   	pop    %ebp$/;"	l
f5	forktest.asm	/^  f5:	6a 01                	push   $0x1$/;"	l
f5	kill.asm	/^  f5:	89 e5                	mov    %esp,%ebp$/;"	l
f5	ls.asm	/^  f5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
f5	mkdir.asm	/^  f5:	5d                   	pop    %ebp$/;"	l
f5	rm.asm	/^  f5:	5d                   	pop    %ebp$/;"	l
f5	stressfs.asm	/^  f5:	50                   	push   %eax$/;"	l
f5	test2.asm	/^  f5:	e8 29 03 00 00       	call   423 <yield>$/;"	l
f5	testcase2.asm	/^  f5:	e8 29 03 00 00       	call   423 <yield>$/;"	l
f5	zombie.asm	/^  f5:	89 e5                	mov    %esp,%ebp$/;"	l
f50	sh.asm	/^     f50:	89 55 d4             	mov    %edx,-0x2c(%ebp)$/;"	l
f50	usertests.asm	/^     f50:	0f 84 f5 00 00 00    	je     104b <sharedfd+0x19b>$/;"	l
f53	sh.asm	/^     f53:	ba 25 00 00 00       	mov    $0x25,%edx$/;"	l
f56	usertests.asm	/^     f56:	e8 30 2a 00 00       	call   398b <wait>$/;"	l
f58	sh.asm	/^     f58:	83 f8 25             	cmp    $0x25,%eax$/;"	l
f5b	sh.asm	/^     f5b:	74 17                	je     f74 <printf+0x54>$/;"	l
f5b	usertests.asm	/^     f5b:	83 ec 0c             	sub    $0xc,%esp$/;"	l
f5d	sh.asm	/^     f5d:	83 ec 04             	sub    $0x4,%esp$/;"	l
f5e	usertests.asm	/^     f5e:	31 db                	xor    %ebx,%ebx$/;"	l
f6	echo.asm	/^  f6:	c3                   	ret    $/;"	l
f6	grep.asm	/^  f6:	74 0c                	je     104 <matchstar+0x44>$/;"	l
f6	mkdir.asm	/^  f6:	c3                   	ret    $/;"	l
f6	ps.asm	/^  f6:	89 d0                	mov    %edx,%eax$/;"	l
f6	rm.asm	/^  f6:	c3                   	ret    $/;"	l
f6	sh.asm	/^      f6:	e8 c5 09 00 00       	call   ac0 <parsecmd>$/;"	l
f6	stressfs.asm	/^  f6:	e8 e8 02 00 00       	call   3e3 <open>$/;"	l
f6	swaptest.asm	/^  f6:	75 19                	jne    111 <strcmp+0x31>$/;"	l
f6	test1.asm	/^  f6:	6a 01                	push   $0x1$/;"	l
f6	testcase1.asm	/^  f6:	6a 01                	push   $0x1$/;"	l
f60	sh.asm	/^     f60:	88 5d e7             	mov    %bl,-0x19(%ebp)$/;"	l
f60	usertests.asm	/^     f60:	57                   	push   %edi$/;"	l
f61	usertests.asm	/^     f61:	8d 7d e8             	lea    -0x18(%ebp),%edi$/;"	l
f63	sh.asm	/^     f63:	6a 01                	push   $0x1$/;"	l
f64	usertests.asm	/^     f64:	e8 42 2a 00 00       	call   39ab <close>$/;"	l
f65	sh.asm	/^     f65:	57                   	push   %edi$/;"	l
f66	sh.asm	/^     f66:	ff 75 08             	pushl  0x8(%ebp)$/;"	l
f69	sh.asm	/^     f69:	e8 45 fe ff ff       	call   db3 <write>$/;"	l
f69	usertests.asm	/^     f69:	58                   	pop    %eax$/;"	l
f6a	usertests.asm	/^     f6a:	5a                   	pop    %edx$/;"	l
f6b	usertests.asm	/^     f6b:	6a 00                	push   $0x0$/;"	l
f6d	usertests.asm	/^     f6d:	68 b3 42 00 00       	push   $0x42b3$/;"	l
f6e	sh.asm	/^     f6e:	8b 55 d4             	mov    -0x2c(%ebp),%edx$/;"	l
f7	cat.asm	/^  f7:	6a 01                	push   $0x1$/;"	l
f7	echo.asm	/^  f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
f7	forktest.asm	/^  f7:	e8 d7 02 00 00       	call   3d3 <write>$/;"	l
f7	kill.asm	/^  f7:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
f7	mkdir.asm	/^  f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
f7	rm.asm	/^  f7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
f7	wc.asm	/^  f7:	83 c7 01             	add    $0x1,%edi$/;"	l
f7	zombie.asm	/^  f7:	57                   	push   %edi$/;"	l
f71	sh.asm	/^     f71:	83 c4 10             	add    $0x10,%esp$/;"	l
f72	usertests.asm	/^     f72:	e8 4c 2a 00 00       	call   39c3 <open>$/;"	l
f74	sh.asm	/^     f74:	0f b6 1e             	movzbl (%esi),%ebx$/;"	l
f77	sh.asm	/^     f77:	83 c6 01             	add    $0x1,%esi$/;"	l
f77	usertests.asm	/^     f77:	83 c4 10             	add    $0x10,%esp$/;"	l
f7a	sh.asm	/^     f7a:	84 db                	test   %bl,%bl$/;"	l
f7a	usertests.asm	/^     f7a:	31 d2                	xor    %edx,%edx$/;"	l
f7c	sh.asm	/^     f7c:	74 71                	je     fef <printf+0xcf>$/;"	l
f7c	usertests.asm	/^     f7c:	89 45 d0             	mov    %eax,-0x30(%ebp)$/;"	l
f7e	sh.asm	/^     f7e:	0f be cb             	movsbl %bl,%ecx$/;"	l
f7f	usertests.asm	/^     f7f:	85 c0                	test   %eax,%eax$/;"	l
f8	getnice.asm	/^  f8:	83 c0 01             	add    $0x1,%eax$/;"	l
f8	grep.asm	/^  f8:	83 c7 01             	add    $0x1,%edi$/;"	l
f8	init.asm	/^  f8:	51                   	push   %ecx$/;"	l
f8	ln.asm	/^  f8:	83 c0 01             	add    $0x1,%eax$/;"	l
f8	ps.asm	/^  f8:	5f                   	pop    %edi$/;"	l
f8	setnice.asm	/^  f8:	83 c0 01             	add    $0x1,%eax$/;"	l
f8	swaptest.asm	/^  f8:	eb 26                	jmp    120 <strcmp+0x40>$/;"	l
f8	test1.asm	/^  f8:	e8 93 05 00 00       	call   690 <printf>$/;"	l
f8	testcase1.asm	/^  f8:	e8 93 05 00 00       	call   690 <printf>$/;"	l
f8	usertests.asm	/^      f8:	e8 03 2b 00 00       	call   2c00 <iref>$/;"	l
f8	zombie.asm	/^  f8:	8b 55 08             	mov    0x8(%ebp),%edx$/;"	l
f81	sh.asm	/^     f81:	0f b6 c3             	movzbl %bl,%eax$/;"	l
f81	usertests.asm	/^     f81:	0f 88 aa 00 00 00    	js     1031 <sharedfd+0x181>$/;"	l
f84	sh.asm	/^     f84:	85 d2                	test   %edx,%edx$/;"	l
f86	sh.asm	/^     f86:	74 c8                	je     f50 <printf+0x30>$/;"	l
f87	usertests.asm	/^     f87:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
f88	sh.asm	/^     f88:	83 fa 25             	cmp    $0x25,%edx$/;"	l
f8b	sh.asm	/^     f8b:	75 e7                	jne    f74 <printf+0x54>$/;"	l
f8d	sh.asm	/^     f8d:	83 f8 64             	cmp    $0x64,%eax$/;"	l
f8e	usertests.asm	/^     f8e:	66 90                	xchg   %ax,%ax$/;"	l
f9	cat.asm	/^  f9:	e8 02 04 00 00       	call   500 <printf>$/;"	l
f9	init.asm	/^  f9:	6a 01                	push   $0x1$/;"	l
f9	ps.asm	/^  f9:	5d                   	pop    %ebp$/;"	l
f90	sh.asm	/^     f90:	0f 84 9a 00 00 00    	je     1030 <printf+0x110>$/;"	l
f90	usertests.asm	/^     f90:	83 ec 04             	sub    $0x4,%esp$/;"	l
f93	usertests.asm	/^     f93:	89 55 d4             	mov    %edx,-0x2c(%ebp)$/;"	l
f96	sh.asm	/^     f96:	81 e1 f7 00 00 00    	and    $0xf7,%ecx$/;"	l
f96	usertests.asm	/^     f96:	6a 0a                	push   $0xa$/;"	l
f98	usertests.asm	/^     f98:	56                   	push   %esi$/;"	l
f99	usertests.asm	/^     f99:	ff 75 d0             	pushl  -0x30(%ebp)$/;"	l
f9c	sh.asm	/^     f9c:	83 f9 70             	cmp    $0x70,%ecx$/;"	l
f9c	usertests.asm	/^     f9c:	e8 fa 29 00 00       	call   399b <read>$/;"	l
f9f	sh.asm	/^     f9f:	74 5f                	je     1000 <printf+0xe0>$/;"	l
fa	kill.asm	/^  fa:	80 3a 00             	cmpb   $0x0,(%edx)$/;"	l
fa	ps.asm	/^  fa:	c3                   	ret    $/;"	l
fa	swaptest.asm	/^  fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi$/;"	l
fa	test2.asm	/^  fa:	e8 64 02 00 00       	call   363 <exit>$/;"	l
fa	testcase2.asm	/^  fa:	e8 64 02 00 00       	call   363 <exit>$/;"	l
fa	wc.asm	/^  fa:	39 fe                	cmp    %edi,%esi$/;"	l
fa1	sh.asm	/^     fa1:	83 f8 73             	cmp    $0x73,%eax$/;"	l
fa1	usertests.asm	/^     fa1:	83 c4 10             	add    $0x10,%esp$/;"	l
fa4	sh.asm	/^     fa4:	0f 84 d6 00 00 00    	je     1080 <printf+0x160>$/;"	l
fa4	usertests.asm	/^     fa4:	85 c0                	test   %eax,%eax$/;"	l
fa6	usertests.asm	/^     fa6:	7e 28                	jle    fd0 <sharedfd+0x120>$/;"	l
fa8	usertests.asm	/^     fa8:	8b 55 d4             	mov    -0x2c(%ebp),%edx$/;"	l
faa	sh.asm	/^     faa:	83 f8 63             	cmp    $0x63,%eax$/;"	l
fab	usertests.asm	/^     fab:	89 f0                	mov    %esi,%eax$/;"	l
fad	sh.asm	/^     fad:	0f 84 8d 00 00 00    	je     1040 <printf+0x120>$/;"	l
fad	usertests.asm	/^     fad:	eb 13                	jmp    fc2 <sharedfd+0x112>$/;"	l
faf	usertests.asm	/^     faf:	90                   	nop$/;"	l
fb	getnice.asm	/^  fb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)$/;"	l
fb	grep.asm	/^  fb:	39 da                	cmp    %ebx,%edx$/;"	l
fb	init.asm	/^  fb:	6a 01                	push   $0x1$/;"	l
fb	ln.asm	/^  fb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)$/;"	l
fb	ps.asm	/^  fb:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
fb	setnice.asm	/^  fb:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)$/;"	l
fb	sh.asm	/^      fb:	89 04 24             	mov    %eax,(%esp)$/;"	l
fb	stressfs.asm	/^  fb:	83 c4 10             	add    $0x10,%esp$/;"	l
fb	zombie.asm	/^  fb:	8b 4d 10             	mov    0x10(%ebp),%ecx$/;"	l
fb0	usertests.asm	/^     fb0:	80 f9 70             	cmp    $0x70,%cl$/;"	l
fb3	sh.asm	/^     fb3:	83 f8 25             	cmp    $0x25,%eax$/;"	l
fb3	usertests.asm	/^     fb3:	0f 94 c1             	sete   %cl$/;"	l
fb6	sh.asm	/^     fb6:	0f 84 b4 00 00 00    	je     1070 <printf+0x150>$/;"	l
fb6	usertests.asm	/^     fb6:	0f b6 c9             	movzbl %cl,%ecx$/;"	l
fb9	usertests.asm	/^     fb9:	01 cb                	add    %ecx,%ebx$/;"	l
fbb	usertests.asm	/^     fbb:	83 c0 01             	add    $0x1,%eax$/;"	l
fbc	sh.asm	/^     fbc:	83 ec 04             	sub    $0x4,%esp$/;"	l
fbe	usertests.asm	/^     fbe:	39 c7                	cmp    %eax,%edi$/;"	l
fbf	sh.asm	/^     fbf:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)$/;"	l
fc	forktest.asm	/^  fc:	e8 b2 02 00 00       	call   3b3 <exit>$/;"	l
fc	ls.asm	/^  fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi$/;"	l
fc	wc.asm	/^  fc:	74 42                	je     140 <wc+0xa0>$/;"	l
fc0	usertests.asm	/^     fc0:	74 ce                	je     f90 <sharedfd+0xe0>$/;"	l
fc2	usertests.asm	/^     fc2:	0f b6 08             	movzbl (%eax),%ecx$/;"	l
fc3	sh.asm	/^     fc3:	6a 01                	push   $0x1$/;"	l
fc5	sh.asm	/^     fc5:	57                   	push   %edi$/;"	l
fc5	usertests.asm	/^     fc5:	80 f9 63             	cmp    $0x63,%cl$/;"	l
fc6	sh.asm	/^     fc6:	ff 75 08             	pushl  0x8(%ebp)$/;"	l
fc8	usertests.asm	/^     fc8:	75 e6                	jne    fb0 <sharedfd+0x100>$/;"	l
fc9	sh.asm	/^     fc9:	e8 e5 fd ff ff       	call   db3 <write>$/;"	l
fca	usertests.asm	/^     fca:	83 c2 01             	add    $0x1,%edx$/;"	l
fcd	usertests.asm	/^     fcd:	eb ec                	jmp    fbb <sharedfd+0x10b>$/;"	l
fce	sh.asm	/^     fce:	88 5d e7             	mov    %bl,-0x19(%ebp)$/;"	l
fcf	usertests.asm	/^     fcf:	90                   	nop$/;"	l
fd	cat.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	dist/sh.c	/^  int fd;$/;"	m	struct:redircmd	file:
fd	echo.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	forktest.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	getnice.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	grep.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	grep.asm	/^  fd:	74 e1                	je     e0 <matchstar+0x20>$/;"	l
fd	init.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	init.asm	/^  fd:	68 78 08 00 00       	push   $0x878$/;"	l
fd	kill.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	kill.asm	/^  fd:	74 21                	je     120 <strlen+0x30>$/;"	l
fd	ln.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	ls.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	mkdir.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	ps.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	rm.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	setnice.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	sh.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	sh.c	/^  int fd;$/;"	m	struct:redircmd	file:
fd	stressfs.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	stressfs.asm	/^  fd = open(path, O_CREATE | O_RDWR);$/;"	d
fd	stressfs.asm	/^  fd = open(path, O_RDONLY);$/;"	d
fd	swaptest.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	test1.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	test1.asm	/^  fd:	83 c4 10             	add    $0x10,%esp$/;"	l
fd	test2.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	testcase1.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	testcase1.asm	/^  fd:	83 c4 10             	add    $0x10,%esp$/;"	l
fd	testcase2.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	usertests.asm	/^        fd = open(name, O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^      fd = open(file, O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^      fd = open(fname, O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^      fd = open(name, 0);$/;"	d
fd	usertests.asm	/^      fd:	e8 1e 2c 00 00       	call   2d20 <forktest>$/;"	l
fd	usertests.asm	/^    fd = open("", O_CREATE);$/;"	d
fd	usertests.asm	/^    fd = open("bigarg-ok", O_CREATE);$/;"	d
fd	usertests.asm	/^    fd = open("bigwrite", O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^    fd = open("xx", O_CREATE);$/;"	d
fd	usertests.asm	/^    fd = open(fname, 0);$/;"	d
fd	usertests.asm	/^    fd = open(name, O_CREATE|O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open(".", 0);$/;"	d
fd	usertests.asm	/^  fd = open(".", O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("123456789012345\/123456789012345\/123456789012345", O_CREATE);$/;"	d
fd	usertests.asm	/^  fd = open("12345678901234\/12345678901234\/12345678901234", 0);$/;"	d
fd	usertests.asm	/^  fd = open("bd", O_CREATE);$/;"	d
fd	usertests.asm	/^  fd = open("big", O_CREATE|O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("big", O_RDONLY);$/;"	d
fd	usertests.asm	/^  fd = open("bigarg-ok", 0);$/;"	d
fd	usertests.asm	/^  fd = open("bigfile", 0);$/;"	d
fd	usertests.asm	/^  fd = open("bigfile", O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("dd\/dd\/..\/ff", 0);$/;"	d
fd	usertests.asm	/^  fd = open("dd\/dd\/ff", O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("dd\/dd\/ffff", 0);$/;"	d
fd	usertests.asm	/^  fd = open("dd\/ff", O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("dirfile", O_CREATE);$/;"	d
fd	usertests.asm	/^  fd = open("dirfile\/xx", 0);$/;"	d
fd	usertests.asm	/^  fd = open("dirfile\/xx", O_CREATE);$/;"	d
fd	usertests.asm	/^  fd = open("doesnotexist", 0);$/;"	d
fd	usertests.asm	/^  fd = open("echo", 0);$/;"	d
fd	usertests.asm	/^  fd = open("init", O_RDONLY);$/;"	d
fd	usertests.asm	/^  fd = open("lf1", O_CREATE|O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("lf2", 0);$/;"	d
fd	usertests.asm	/^  fd = open("sharedfd", 0);$/;"	d
fd	usertests.asm	/^  fd = open("sharedfd", O_CREATE|O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("small", O_CREATE|O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("small", O_RDONLY);$/;"	d
fd	usertests.asm	/^  fd = open("unlinkread", O_CREATE | O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open("unlinkread", O_RDWR);$/;"	d
fd	usertests.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	wc.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	zombie.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd0	kernel.asm	/^  fd0 = -1;$/;"	d
fd0	usertests.asm	/^     fd0:	83 ec 0c             	sub    $0xc,%esp$/;"	l
fd1	sh.asm	/^     fd1:	83 c4 0c             	add    $0xc,%esp$/;"	l
fd1	usertests.asm	/^  fd1 = open("unlinkread", O_CREATE | O_RDWR);$/;"	d
fd3	usertests.asm	/^     fd3:	ff 75 d0             	pushl  -0x30(%ebp)$/;"	l
fd4	sh.asm	/^     fd4:	6a 01                	push   $0x1$/;"	l
fd6	sh.asm	/^     fd6:	83 c6 01             	add    $0x1,%esi$/;"	l
fd6	usertests.asm	/^     fd6:	e8 d0 29 00 00       	call   39ab <close>$/;"	l
fd9	sh.asm	/^     fd9:	57                   	push   %edi$/;"	l
fda	sh.asm	/^     fda:	ff 75 08             	pushl  0x8(%ebp)$/;"	l
fdalloc	dist/sysfile.c	/^fdalloc(struct file *f)$/;"	f	file:
fdalloc	sysfile.c	/^fdalloc(struct file *f)$/;"	f	file:
fdb	usertests.asm	/^     fdb:	c7 04 24 b3 42 00 00 	movl   $0x42b3,(%esp)$/;"	l
fdd	sh.asm	/^     fdd:	e8 d1 fd ff ff       	call   db3 <write>$/;"	l
fe	cat.asm	/^  fe:	e8 70 02 00 00       	call   373 <exit>$/;"	l
fe	echo.asm	/^  fe:	66 90                	xchg   %ax,%ax$/;"	l
fe	mkdir.asm	/^  fe:	66 90                	xchg   %ax,%ax$/;"	l
fe	rm.asm	/^  fe:	66 90                	xchg   %ax,%ax$/;"	l
fe	sh.asm	/^      fe:	e8 7d 00 00 00       	call   180 <runcmd>$/;"	l
fe	stressfs.asm	/^  fe:	89 c7                	mov    %eax,%edi$/;"	l
fe	wc.asm	/^  fe:	0f be 87 40 0c 00 00 	movsbl 0xc40(%edi),%eax$/;"	l
fe	zombie.asm	/^  fe:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
fe2	sh.asm	/^     fe2:	0f b6 5e ff          	movzbl -0x1(%esi),%ebx$/;"	l
fe2	usertests.asm	/^     fe2:	e8 ec 29 00 00       	call   39d3 <unlink>$/;"	l
fe6	sh.asm	/^     fe6:	83 c4 10             	add    $0x10,%esp$/;"	l
fe7	usertests.asm	/^     fe7:	8b 55 d4             	mov    -0x2c(%ebp),%edx$/;"	l
fe9	sh.asm	/^     fe9:	31 d2                	xor    %edx,%edx$/;"	l
fea	usertests.asm	/^     fea:	83 c4 10             	add    $0x10,%esp$/;"	l
feature	dist/mp.h	/^  uint feature;                 \/\/ feature flags from CPUID instruction$/;"	m	struct:mpproc
feature	mp.h	/^  uint feature;                 \/\/ feature flags from CPUID instruction$/;"	m	struct:mpproc
feb	sh.asm	/^     feb:	84 db                	test   %bl,%bl$/;"	l
fed	sh.asm	/^     fed:	75 8f                	jne    f7e <printf+0x5e>$/;"	l
fed	usertests.asm	/^     fed:	81 fa 10 27 00 00    	cmp    $0x2710,%edx$/;"	l
fef	sh.asm	/^     fef:	8d 65 f4             	lea    -0xc(%ebp),%esp$/;"	l
fetchint	dist/syscall.c	/^fetchint(uint addr, int *ip)$/;"	f
fetchint	syscall.c	/^fetchint(uint addr, int *ip)$/;"	f
fetchstr	dist/syscall.c	/^fetchstr(uint addr, char **pp)$/;"	f
fetchstr	syscall.c	/^fetchstr(uint addr, char **pp)$/;"	f
ff	getnice.asm	/^  ff:	89 c1                	mov    %eax,%ecx$/;"	l
ff	grep.asm	/^  ff:	83 fb 2e             	cmp    $0x2e,%ebx$/;"	l
ff	kernel.asm	/^  ff = *f;$/;"	d
ff	kill.asm	/^  ff:	31 c0                	xor    %eax,%eax$/;"	l
ff	ln.asm	/^  ff:	89 c1                	mov    %eax,%ecx$/;"	l
ff	ps.asm	/^  ff:	90                   	nop$/;"	l
ff	setnice.asm	/^  ff:	89 c1                	mov    %eax,%ecx$/;"	l
ff	test2.asm	/^  ff:	90                   	nop$/;"	l
ff	testcase2.asm	/^  ff:	90                   	nop$/;"	l
ff2	sh.asm	/^     ff2:	5b                   	pop    %ebx$/;"	l
ff3	sh.asm	/^     ff3:	5e                   	pop    %esi$/;"	l
ff3	usertests.asm	/^     ff3:	75 5b                	jne    1050 <sharedfd+0x1a0>$/;"	l
ff4	sh.asm	/^     ff4:	5f                   	pop    %edi$/;"	l
ff5	sh.asm	/^     ff5:	5d                   	pop    %ebp$/;"	l
ff5	usertests.asm	/^     ff5:	81 fb 10 27 00 00    	cmp    $0x2710,%ebx$/;"	l
ff6	sh.asm	/^     ff6:	c3                   	ret    $/;"	l
ff7	sh.asm	/^     ff7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi$/;"	l
ffb	usertests.asm	/^     ffb:	75 53                	jne    1050 <sharedfd+0x1a0>$/;"	l
ffd	usertests.asm	/^     ffd:	83 ec 08             	sub    $0x8,%esp$/;"	l
ffe	sh.asm	/^     ffe:	66 90                	xchg   %ax,%ax$/;"	l
file	dist/file.c	/^  struct file file[NFILE];$/;"	m	struct:__anon10	typeref:struct:__anon10::file	file:
file	dist/file.h	/^struct file {$/;"	s
file	dist/sh.c	/^  char *file;$/;"	m	struct:redircmd	file:
file	file.c	/^  struct file file[NFILE];$/;"	m	struct:__anon2	typeref:struct:__anon2::file	file:
file	file.h	/^struct file {$/;"	s
file	sh.c	/^  char *file;$/;"	m	struct:redircmd	file:
filealloc	dist/file.c	/^filealloc(void)$/;"	f
filealloc	file.c	/^filealloc(void)$/;"	f
fileclose	dist/file.c	/^fileclose(struct file *f)$/;"	f
fileclose	file.c	/^fileclose(struct file *f)$/;"	f
filedup	dist/file.c	/^filedup(struct file *f)$/;"	f
filedup	file.c	/^filedup(struct file *f)$/;"	f
fileinit	dist/file.c	/^fileinit(void)$/;"	f
fileinit	file.c	/^fileinit(void)$/;"	f
fileread	dist/file.c	/^fileread(struct file *f, char *addr, int n)$/;"	f
fileread	file.c	/^fileread(struct file *f, char *addr, int n)$/;"	f
filestat	dist/file.c	/^filestat(struct file *f, struct stat *st)$/;"	f
filestat	file.c	/^filestat(struct file *f, struct stat *st)$/;"	f
filesz	dist/elf.h	/^  uint filesz;$/;"	m	struct:proghdr
filesz	elf.h	/^  uint filesz;$/;"	m	struct:proghdr
filewrite	dist/file.c	/^filewrite(struct file *f, char *addr, int n)$/;"	f
filewrite	file.c	/^filewrite(struct file *f, char *addr, int n)$/;"	f
fill_rtcdate	dist/lapic.c	/^fill_rtcdate(struct rtcdate *r)$/;"	f	file:
fill_rtcdate	lapic.c	/^fill_rtcdate(struct rtcdate *r)$/;"	f	file:
first	kernel.asm	/^    first = 0;$/;"	d
flags	buf.h	/^  int flags;$/;"	m	struct:buf
flags	dist/buf.h	/^  int flags;$/;"	m	struct:buf
flags	dist/elf.h	/^  uint flags;$/;"	m	struct:elfhdr
flags	dist/elf.h	/^  uint flags;$/;"	m	struct:proghdr
flags	dist/mp.h	/^  uchar flags;                  \/\/ CPU flags$/;"	m	struct:mpproc
flags	dist/mp.h	/^  uchar flags;                  \/\/ I\/O APIC flags$/;"	m	struct:mpioapic
flags	elf.h	/^  uint flags;$/;"	m	struct:elfhdr
flags	elf.h	/^  uint flags;$/;"	m	struct:proghdr
flags	kernel.asm	/^    flags = PTE_FLAGS(*pte);$/;"	d
flags	mp.h	/^  uchar flags;                  \/\/ CPU flags$/;"	m	struct:mpproc
flags	mp.h	/^  uchar flags;                  \/\/ I\/O APIC flags$/;"	m	struct:mpioapic
fmtname	dist/ls.c	/^fmtname(char *path)$/;"	f
fmtname	ls.c	/^fmtname(char *path)$/;"	f
fname	usertests.asm	/^    fname = names[i];$/;"	d
fork	dist/proc.c	/^fork(void)$/;"	f
fork	proc.c	/^fork(void)$/;"	f
fork1	dist/sh.c	/^fork1(void)$/;"	f
fork1	sh.c	/^fork1(void)$/;"	f
forkret	dist/proc.c	/^forkret(void)$/;"	f
forkret	proc.c	/^forkret(void)$/;"	f
forktest	dist/forktest.c	/^forktest(void)$/;"	f
forktest	dist/usertests.c	/^forktest(void)$/;"	f
forktest	forktest.c	/^forktest(void)$/;"	f
forktest	usertests.c	/^forktest(void)$/;"	f
found	kernel.asm	/^found:$/;"	l
fourfiles	dist/usertests.c	/^fourfiles(void)$/;"	f
fourfiles	usertests.c	/^fourfiles(void)$/;"	f
fourteen	dist/usertests.c	/^fourteen(void)$/;"	f
fourteen	usertests.c	/^fourteen(void)$/;"	f
free	dist/umalloc.c	/^free(void *ap)$/;"	f
free	umalloc.c	/^free(void *ap)$/;"	f
freeblock	dist/mkfs.c	/^uint freeblock;$/;"	v
freeblock	mkfs.c	/^uint freeblock;$/;"	v
freeinode	dist/mkfs.c	/^uint freeinode = 1;$/;"	v
freeinode	mkfs.c	/^uint freeinode = 1;$/;"	v
freelist	dist/kalloc.c	/^  struct run *freelist;$/;"	m	struct:__anon12	typeref:struct:__anon12::run	file:
freelist	kalloc.c	/^  struct run *freelist;$/;"	m	struct:__anon4	typeref:struct:__anon4::run	file:
freep	cat.asm	/^      freep = prevp;$/;"	d
freep	cat.asm	/^  freep = p;$/;"	d
freep	dist/umalloc.c	/^static Header *freep;$/;"	v	file:
freep	echo.asm	/^      freep = prevp;$/;"	d
freep	echo.asm	/^  freep = p;$/;"	d
freep	getnice.asm	/^      freep = prevp;$/;"	d
freep	getnice.asm	/^  freep = p;$/;"	d
freep	grep.asm	/^      freep = prevp;$/;"	d
freep	grep.asm	/^  freep = p;$/;"	d
freep	init.asm	/^      freep = prevp;$/;"	d
freep	init.asm	/^  freep = p;$/;"	d
freep	kill.asm	/^      freep = prevp;$/;"	d
freep	kill.asm	/^  freep = p;$/;"	d
freep	ln.asm	/^      freep = prevp;$/;"	d
freep	ln.asm	/^  freep = p;$/;"	d
freep	ls.asm	/^      freep = prevp;$/;"	d
freep	ls.asm	/^  freep = p;$/;"	d
freep	mkdir.asm	/^      freep = prevp;$/;"	d
freep	mkdir.asm	/^  freep = p;$/;"	d
freep	ps.asm	/^      freep = prevp;$/;"	d
freep	ps.asm	/^  freep = p;$/;"	d
freep	rm.asm	/^      freep = prevp;$/;"	d
freep	rm.asm	/^  freep = p;$/;"	d
freep	setnice.asm	/^      freep = prevp;$/;"	d
freep	setnice.asm	/^  freep = p;$/;"	d
freep	sh.asm	/^      freep = prevp;$/;"	d
freep	sh.asm	/^  freep = p;$/;"	d
freep	stressfs.asm	/^      freep = prevp;$/;"	d
freep	stressfs.asm	/^  freep = p;$/;"	d
freep	swaptest.asm	/^      freep = prevp;$/;"	d
freep	swaptest.asm	/^  freep = p;$/;"	d
freep	test1.asm	/^      freep = prevp;$/;"	d
freep	test1.asm	/^  freep = p;$/;"	d
freep	test2.asm	/^      freep = prevp;$/;"	d
freep	test2.asm	/^  freep = p;$/;"	d
freep	testcase1.asm	/^      freep = prevp;$/;"	d
freep	testcase1.asm	/^  freep = p;$/;"	d
freep	testcase2.asm	/^      freep = prevp;$/;"	d
freep	testcase2.asm	/^  freep = p;$/;"	d
freep	umalloc.c	/^static Header *freep;$/;"	v	file:
freep	usertests.asm	/^      freep = prevp;$/;"	d
freep	usertests.asm	/^  freep = p;$/;"	d
freep	wc.asm	/^      freep = prevp;$/;"	d
freep	wc.asm	/^  freep = p;$/;"	d
freep	zombie.asm	/^      freep = prevp;$/;"	d
freep	zombie.asm	/^  freep = p;$/;"	d
freerange	dist/kalloc.c	/^freerange(void *vstart, void *vend)$/;"	f
freerange	kalloc.c	/^freerange(void *vstart, void *vend)$/;"	f
freevm	dist/vm.c	/^freevm(pde_t *pgdir)$/;"	f
freevm	vm.c	/^freevm(pde_t *pgdir)$/;"	f
fs	dist/mmu.h	/^  ushort fs;$/;"	m	struct:taskstate
fs	dist/x86.h	/^  ushort fs;$/;"	m	struct:trapframe
fs	mmu.h	/^  ushort fs;$/;"	m	struct:taskstate
fs	x86.h	/^  ushort fs;$/;"	m	struct:trapframe
fsfd	dist/mkfs.c	/^int fsfd;$/;"	v
fsfd	mkfs.c	/^int fsfd;$/;"	v
fsfull	dist/usertests.c	/^fsfull()$/;"	f
fsfull	usertests.c	/^fsfull()$/;"	f
ftable	dist/file.c	/^} ftable;$/;"	v	typeref:struct:__anon10
ftable	file.c	/^} ftable;$/;"	v	typeref:struct:__anon2
g	dist/mmu.h	/^  uint g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:segdesc
g	mmu.h	/^  uint g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:segdesc
gatedesc	dist/mmu.h	/^struct gatedesc {$/;"	s
gatedesc	mmu.h	/^struct gatedesc {$/;"	s
gdt	bootasm.S	/^gdt:$/;"	l
gdt	dist/bootasm.S	/^gdt:$/;"	l
gdt	dist/entryother.S	/^gdt:$/;"	l
gdt	dist/proc.h	/^  struct segdesc gdt[NSEGS];   \/\/ x86 global descriptor table$/;"	m	struct:cpu	typeref:struct:cpu::segdesc
gdt	entryother.S	/^gdt:$/;"	l
gdt	proc.h	/^  struct segdesc gdt[NSEGS];   \/\/ x86 global descriptor table$/;"	m	struct:cpu	typeref:struct:cpu::segdesc
gdtdesc	bootasm.S	/^gdtdesc:$/;"	l
gdtdesc	dist/bootasm.S	/^gdtdesc:$/;"	l
gdtdesc	dist/entryother.S	/^gdtdesc:$/;"	l
gdtdesc	entryother.S	/^gdtdesc:$/;"	l
getcallerpcs	dist/spinlock.c	/^getcallerpcs(void *v, uint pcs[])$/;"	f
getcallerpcs	spinlock.c	/^getcallerpcs(void *v, uint pcs[])$/;"	f
getcmd	dist/sh.c	/^getcmd(char *buf, int nbuf)$/;"	f
getcmd	sh.c	/^getcmd(char *buf, int nbuf)$/;"	f
getnice	dist/proc.c	/^int getnice(int pid){$/;"	f
getnice	proc.c	/^int getnice(int pid){$/;"	f
gets	dist/ulib.c	/^gets(char *buf, int max)$/;"	f
gets	ulib.c	/^gets(char *buf, int max)$/;"	f
gettoken	dist/sh.c	/^gettoken(char **ps, char *es, char **q, char **eq)$/;"	f
gettoken	sh.c	/^gettoken(char **ps, char *es, char **q, char **eq)$/;"	f
grep	dist/grep.c	/^grep(char *pattern, int fd)$/;"	f
grep	grep.c	/^grep(char *pattern, int fd)$/;"	f
growproc	dist/proc.c	/^growproc(int n)$/;"	f
growproc	proc.c	/^growproc(int n)$/;"	f
gs	dist/mmu.h	/^  ushort gs;$/;"	m	struct:taskstate
gs	dist/x86.h	/^  ushort gs;$/;"	m	struct:trapframe
gs	mmu.h	/^  ushort gs;$/;"	m	struct:taskstate
gs	x86.h	/^  ushort gs;$/;"	m	struct:trapframe
havedisk1	dist/ide.c	/^static int havedisk1;$/;"	v	file:
havedisk1	ide.c	/^static int havedisk1;$/;"	v	file:
havedisk1	kernel.asm	/^      havedisk1 = 1;$/;"	d
havekids	kernel.asm	/^      havekids = 1;$/;"	d
havekids	kernel.asm	/^    havekids = 0;$/;"	d
head	bio.c	/^  struct buf head;$/;"	m	struct:__anon18	typeref:struct:__anon18::buf	file:
head	dist/bio.c	/^  struct buf head;$/;"	m	struct:__anon17	typeref:struct:__anon17::buf	file:
header	dist/umalloc.c	/^union header {$/;"	u	file:
header	umalloc.c	/^union header {$/;"	u	file:
holding	dist/spinlock.c	/^holding(struct spinlock *lock)$/;"	f
holding	spinlock.c	/^holding(struct spinlock *lock)$/;"	f
holdingsleep	dist/sleeplock.c	/^holdingsleep(struct sleeplock *lk)$/;"	f
holdingsleep	sleeplock.c	/^holdingsleep(struct sleeplock *lk)$/;"	f
hour	date.h	/^  uint hour;$/;"	m	struct:rtcdate
hour	dist/date.h	/^  uint hour;$/;"	m	struct:rtcdate
i	cat.asm	/^  i = 0;$/;"	d
i	echo.asm	/^  i = 0;$/;"	d
i	getnice.asm	/^  i = 0;$/;"	d
i	grep.asm	/^  i = 0;$/;"	d
i	init.asm	/^  i = 0;$/;"	d
i	kernel.asm	/^  i = 0;$/;"	d
i	kill.asm	/^  i = 0;$/;"	d
i	ln.asm	/^  i = 0;$/;"	d
i	ls.asm	/^  i = 0;$/;"	d
i	mkdir.asm	/^  i = 0;$/;"	d
i	ps.asm	/^  i = 0;$/;"	d
i	rm.asm	/^  i = 0;$/;"	d
i	setnice.asm	/^  i = 0;$/;"	d
i	sh.asm	/^  i = 0;$/;"	d
i	stressfs.asm	/^  i = 0;$/;"	d
i	swaptest.asm	/^  i = 0;$/;"	d
i	test1.asm	/^  i = 0;$/;"	d
i	test2.asm	/^  i = 0;$/;"	d
i	testcase1.asm	/^  i = 0;$/;"	d
i	testcase2.asm	/^  i = 0;$/;"	d
i	usertests.asm	/^      i = de.name[1] - '0';$/;"	d
i	usertests.asm	/^    i = read(fd, buf, 512);$/;"	d
i	usertests.asm	/^  i = 0;$/;"	d
i	usertests.asm	/^  i = read(fd, buf, 2000);$/;"	d
i	wc.asm	/^  i = 0;$/;"	d
i	zombie.asm	/^  i = 0;$/;"	d
ialloc	dist/fs.c	/^ialloc(uint dev, short type)$/;"	f
ialloc	dist/mkfs.c	/^ialloc(ushort type)$/;"	f
ialloc	fs.c	/^ialloc(uint dev, short type)$/;"	f
ialloc	mkfs.c	/^ialloc(ushort type)$/;"	f
iappend	dist/mkfs.c	/^iappend(uint inum, void *xp, int n)$/;"	f
iappend	mkfs.c	/^iappend(uint inum, void *xp, int n)$/;"	f
icache	dist/fs.c	/^} icache;$/;"	v	typeref:struct:__anon11
icache	fs.c	/^} icache;$/;"	v	typeref:struct:__anon3
id	kernel.asm	/^  id = ioapicread(REG_ID) >> 24;$/;"	d
ideinit	dist/ide.c	/^ideinit(void)$/;"	f
ideinit	ide.c	/^ideinit(void)$/;"	f
ideinit	memide.c	/^ideinit(void)$/;"	f
ideintr	dist/ide.c	/^ideintr(void)$/;"	f
ideintr	ide.c	/^ideintr(void)$/;"	f
ideintr	memide.c	/^ideintr(void)$/;"	f
idelock	dist/ide.c	/^static struct spinlock idelock;$/;"	v	typeref:struct:spinlock	file:
idelock	ide.c	/^static struct spinlock idelock;$/;"	v	typeref:struct:spinlock	file:
idequeue	dist/ide.c	/^static struct buf *idequeue;$/;"	v	typeref:struct:buf	file:
idequeue	ide.c	/^static struct buf *idequeue;$/;"	v	typeref:struct:buf	file:
idequeue	kernel.asm	/^  idequeue = b->qnext;$/;"	d
iderw	dist/ide.c	/^iderw(struct buf *b)$/;"	f
iderw	ide.c	/^iderw(struct buf *b)$/;"	f
iderw	memide.c	/^iderw(struct buf *b)$/;"	f
idestart	dist/ide.c	/^idestart(struct buf *b)$/;"	f	file:
idestart	ide.c	/^idestart(struct buf *b)$/;"	f	file:
idewait	dist/ide.c	/^idewait(int checkerr)$/;"	f	file:
idewait	ide.c	/^idewait(int checkerr)$/;"	f	file:
idt	dist/trap.c	/^struct gatedesc idt[256];$/;"	v	typeref:struct:gatedesc
idt	trap.c	/^struct gatedesc idt[256];$/;"	v	typeref:struct:gatedesc
idtinit	dist/trap.c	/^idtinit(void)$/;"	f
idtinit	trap.c	/^idtinit(void)$/;"	f
idup	dist/fs.c	/^idup(struct inode *ip)$/;"	f
idup	fs.c	/^idup(struct inode *ip)$/;"	f
iget	dist/fs.c	/^iget(uint dev, uint inum)$/;"	f	file:
iget	fs.c	/^iget(uint dev, uint inum)$/;"	f	file:
iinit	dist/fs.c	/^iinit(int dev)$/;"	f
iinit	fs.c	/^iinit(int dev)$/;"	f
ilock	dist/fs.c	/^ilock(struct inode *ip)$/;"	f
ilock	fs.c	/^ilock(struct inode *ip)$/;"	f
imcrp	dist/mp.h	/^  uchar imcrp;$/;"	m	struct:mp
imcrp	mp.h	/^  uchar imcrp;$/;"	m	struct:mp
inb	dist/x86.h	/^inb(ushort port)$/;"	f
inb	x86.h	/^inb(ushort port)$/;"	f
init	dist/initcode.S	/^init:$/;"	l
init	initcode.S	/^init:$/;"	l
initlock	dist/spinlock.c	/^initlock(struct spinlock *lk, char *name)$/;"	f
initlock	spinlock.c	/^initlock(struct spinlock *lk, char *name)$/;"	f
initlog	dist/log.c	/^initlog(int dev)$/;"	f
initlog	log.c	/^initlog(int dev)$/;"	f
initproc	dist/proc.c	/^static struct proc *initproc;$/;"	v	typeref:struct:proc	file:
initproc	kernel.asm	/^  initproc = p;$/;"	d
initproc	proc.c	/^static struct proc *initproc;$/;"	v	typeref:struct:proc	file:
initsleeplock	dist/sleeplock.c	/^initsleeplock(struct sleeplock *lk, char *name)$/;"	f
initsleeplock	sleeplock.c	/^initsleeplock(struct sleeplock *lk, char *name)$/;"	f
inituvm	dist/vm.c	/^inituvm(pde_t *pgdir, char *init, uint sz)$/;"	f
inituvm	vm.c	/^inituvm(pde_t *pgdir, char *init, uint sz)$/;"	f
ino	dist/stat.h	/^  uint ino;    \/\/ Inode number$/;"	m	struct:stat
ino	stat.h	/^  uint ino;    \/\/ Inode number$/;"	m	struct:stat
inode	dist/file.h	/^struct inode {$/;"	s
inode	dist/fs.c	/^  struct inode inode[NINODE];$/;"	m	struct:__anon11	typeref:struct:__anon11::inode	file:
inode	file.h	/^struct inode {$/;"	s
inode	fs.c	/^  struct inode inode[NINODE];$/;"	m	struct:__anon3	typeref:struct:__anon3::inode	file:
inodestart	dist/fs.h	/^  uint inodestart;   \/\/ Block number of first inode block$/;"	m	struct:superblock
inodestart	fs.h	/^  uint inodestart;   \/\/ Block number of first inode block$/;"	m	struct:superblock
input	console.c	/^} input;$/;"	v	typeref:struct:__anon6
input	dist/console.c	/^} input;$/;"	v	typeref:struct:__anon14
insl	dist/x86.h	/^insl(int port, void *addr, int cnt)$/;"	f
insl	x86.h	/^insl(int port, void *addr, int cnt)$/;"	f
install_trans	dist/log.c	/^install_trans(void)$/;"	f	file:
install_trans	log.c	/^install_trans(void)$/;"	f	file:
int	cat.asm	/^int$/;"	l
int	echo.asm	/^int$/;"	l
int	forktest.asm	/^int$/;"	l
int	getnice.asm	/^int main(int argc, char* argv[]){$/;"	l
int	getnice.asm	/^int$/;"	l
int	grep.asm	/^int matchstar(int c, char *re, char *text)$/;"	l
int	grep.asm	/^int$/;"	l
int	init.asm	/^int$/;"	l
int	kernel.asm	/^int getnice(int pid){$/;"	l
int	kernel.asm	/^int setnice(int pid, int nice){$/;"	l
int	kernel.asm	/^int sys_getnice(void){$/;"	l
int	kernel.asm	/^int sys_ps(void){$/;"	l
int	kernel.asm	/^int sys_setnice(void){$/;"	l
int	kernel.asm	/^int sys_swapread(void)$/;"	l
int	kernel.asm	/^int sys_swapwrite(void)$/;"	l
int	kernel.asm	/^int sys_yield(void){$/;"	l
int	kernel.asm	/^int$/;"	l
int	kill.asm	/^int$/;"	l
int	ln.asm	/^int$/;"	l
int	ls.asm	/^int$/;"	l
int	mkdir.asm	/^int$/;"	l
int	ps.asm	/^int main(int argc, char* argv[]){$/;"	l
int	ps.asm	/^int$/;"	l
int	rm.asm	/^int$/;"	l
int	setnice.asm	/^int main(int argc, char* argv[]){$/;"	l
int	setnice.asm	/^int$/;"	l
int	sh.asm	/^int$/;"	l
int	stressfs.asm	/^int$/;"	l
int	swaptest.asm	/^int main(int argc, char** argv)$/;"	l
int	swaptest.asm	/^int$/;"	l
int	test1.asm	/^int main(int argc, char **argv)$/;"	l
int	test1.asm	/^int$/;"	l
int	test2.asm	/^int main(int argc, char **argv)$/;"	l
int	test2.asm	/^int$/;"	l
int	testcase1.asm	/^int main(int argc, char **argv)$/;"	l
int	testcase1.asm	/^int$/;"	l
int	testcase2.asm	/^int main(int argc, char **argv)$/;"	l
int	testcase2.asm	/^int$/;"	l
int	usertests.asm	/^int$/;"	l
int	wc.asm	/^int$/;"	l
int	zombie.asm	/^int$/;"	l
intena	dist/proc.h	/^  int intena;                  \/\/ Were interrupts enabled before pushcli?$/;"	m	struct:cpu
intena	kernel.asm	/^  intena = mycpu()->intena;$/;"	d
intena	proc.h	/^  int intena;                  \/\/ Were interrupts enabled before pushcli?$/;"	m	struct:cpu
inum	dist/file.h	/^  uint inum;          \/\/ Inode number$/;"	m	struct:inode
inum	dist/fs.h	/^  ushort inum;$/;"	m	struct:dirent
inum	file.h	/^  uint inum;          \/\/ Inode number$/;"	m	struct:inode
inum	fs.h	/^  ushort inum;$/;"	m	struct:dirent
inum	kernel.asm	/^      inum = de.inum;$/;"	d
inword	wc.asm	/^        inword = 0;$/;"	d
inword	wc.asm	/^        inword = 1;$/;"	d
inword	wc.asm	/^  inword = 0;$/;"	d
ioapic	dist/ioapic.c	/^struct ioapic {$/;"	s	file:
ioapic	dist/ioapic.c	/^volatile struct ioapic *ioapic;$/;"	v	typeref:struct:ioapic
ioapic	ioapic.c	/^struct ioapic {$/;"	s	file:
ioapic	ioapic.c	/^volatile struct ioapic *ioapic;$/;"	v	typeref:struct:ioapic
ioapic	kernel.asm	/^  ioapic = (volatile struct ioapic*)IOAPIC;$/;"	d
ioapicenable	dist/ioapic.c	/^ioapicenable(int irq, int cpunum)$/;"	f
ioapicenable	ioapic.c	/^ioapicenable(int irq, int cpunum)$/;"	f
ioapicid	dist/mp.c	/^uchar ioapicid;$/;"	v
ioapicid	kernel.asm	/^      ioapicid = ioapic->apicno;$/;"	d
ioapicid	mp.c	/^uchar ioapicid;$/;"	v
ioapicinit	dist/ioapic.c	/^ioapicinit(void)$/;"	f
ioapicinit	ioapic.c	/^ioapicinit(void)$/;"	f
ioapicread	dist/ioapic.c	/^ioapicread(int reg)$/;"	f	file:
ioapicread	ioapic.c	/^ioapicread(int reg)$/;"	f	file:
ioapicwrite	dist/ioapic.c	/^ioapicwrite(int reg, uint data)$/;"	f	file:
ioapicwrite	ioapic.c	/^ioapicwrite(int reg, uint data)$/;"	f	file:
iomb	dist/mmu.h	/^  ushort iomb;       \/\/ I\/O map base address$/;"	m	struct:taskstate
iomb	mmu.h	/^  ushort iomb;       \/\/ I\/O map base address$/;"	m	struct:taskstate
ip	dist/file.h	/^  struct inode *ip;$/;"	m	struct:file	typeref:struct:file::inode
ip	file.h	/^  struct inode *ip;$/;"	m	struct:file	typeref:struct:file::inode
ip	kernel.asm	/^    ip = create(path, T_FILE, 0, 0);$/;"	d
ip	kernel.asm	/^    ip = idup(myproc()->cwd);$/;"	d
ip	kernel.asm	/^    ip = iget(ROOTDEV, ROOTINO);$/;"	d
ip	kernel.asm	/^    ip = next;$/;"	d
ip	kernel.asm	/^  ip = empty;$/;"	d
iput	dist/fs.c	/^iput(struct inode *ip)$/;"	f
iput	fs.c	/^iput(struct inode *ip)$/;"	f
iputtest	dist/usertests.c	/^iputtest(void)$/;"	f
iputtest	usertests.c	/^iputtest(void)$/;"	f
iref	dist/usertests.c	/^iref(void)$/;"	f
iref	usertests.c	/^iref(void)$/;"	f
isdirempty	dist/sysfile.c	/^isdirempty(struct inode *dp)$/;"	f	file:
isdirempty	sysfile.c	/^isdirempty(struct inode *dp)$/;"	f	file:
ismp	kernel.asm	/^      ismp = 0;$/;"	d
ismp	kernel.asm	/^  ismp = 1;$/;"	d
itrunc	dist/fs.c	/^itrunc(struct inode *ip)$/;"	f	file:
itrunc	fs.c	/^itrunc(struct inode *ip)$/;"	f	file:
iunlock	dist/fs.c	/^iunlock(struct inode *ip)$/;"	f
iunlock	fs.c	/^iunlock(struct inode *ip)$/;"	f
iunlockput	dist/fs.c	/^iunlockput(struct inode *ip)$/;"	f
iunlockput	fs.c	/^iunlockput(struct inode *ip)$/;"	f
iupdate	dist/fs.c	/^iupdate(struct inode *ip)$/;"	f
iupdate	fs.c	/^iupdate(struct inode *ip)$/;"	f
kalloc	dist/kalloc.c	/^kalloc(void)$/;"	f
kalloc	kalloc.c	/^kalloc(void)$/;"	f
kbdgetc	dist/kbd.c	/^kbdgetc(void)$/;"	f
kbdgetc	kbd.c	/^kbdgetc(void)$/;"	f
kbdintr	dist/kbd.c	/^kbdintr(void)$/;"	f
kbdintr	kbd.c	/^kbdintr(void)$/;"	f
kernel	kernel.asm	/^kernel:     file format elf32-i386$/;"	l
kfree	dist/kalloc.c	/^kfree(char *v)$/;"	f
kfree	kalloc.c	/^kfree(char *v)$/;"	f
kill	dist/proc.c	/^kill(int pid)$/;"	f
kill	proc.c	/^kill(int pid)$/;"	f
killed	dist/proc.h	/^  int killed;                  \/\/ If non-zero, have been killed$/;"	m	struct:proc
killed	proc.h	/^  int killed;                  \/\/ If non-zero, have been killed$/;"	m	struct:proc
kinit1	dist/kalloc.c	/^kinit1(void *vstart, void *vend)$/;"	f
kinit1	kalloc.c	/^kinit1(void *vstart, void *vend)$/;"	f
kinit2	dist/kalloc.c	/^kinit2(void *vstart, void *vend)$/;"	f
kinit2	kalloc.c	/^kinit2(void *vstart, void *vend)$/;"	f
kmap	dist/vm.c	/^static struct kmap {$/;"	s	file:
kmap	dist/vm.c	/^} kmap[] = {$/;"	v	typeref:struct:kmap	file:
kmap	vm.c	/^static struct kmap {$/;"	s	file:
kmap	vm.c	/^} kmap[] = {$/;"	v	typeref:struct:kmap	file:
kmem	dist/kalloc.c	/^} kmem;$/;"	v	typeref:struct:__anon12
kmem	kalloc.c	/^} kmem;$/;"	v	typeref:struct:__anon4
kpgdir	dist/vm.c	/^pde_t *kpgdir;  \/\/ for use in scheduler()$/;"	v
kpgdir	kernel.asm	/^  kpgdir = setupkvm();$/;"	d
kpgdir	vm.c	/^pde_t *kpgdir;  \/\/ for use in scheduler()$/;"	v
kstack	dist/proc.h	/^  char *kstack;                \/\/ Bottom of kernel stack for this process$/;"	m	struct:proc
kstack	proc.h	/^  char *kstack;                \/\/ Bottom of kernel stack for this process$/;"	m	struct:proc
kvmalloc	dist/vm.c	/^kvmalloc(void)$/;"	f
kvmalloc	vm.c	/^kvmalloc(void)$/;"	f
l	wc.asm	/^  l = w = c = 0;$/;"	d
lapic	dist/lapic.c	/^volatile uint *lapic;  \/\/ Initialized in mp.c$/;"	v
lapic	kernel.asm	/^  lapic = (uint*)conf->lapicaddr;$/;"	d
lapic	lapic.c	/^volatile uint *lapic;  \/\/ Initialized in mp.c$/;"	v
lapicaddr	dist/mp.h	/^  uint *lapicaddr;              \/\/ address of local APIC$/;"	m	struct:mpconf
lapicaddr	mp.h	/^  uint *lapicaddr;              \/\/ address of local APIC$/;"	m	struct:mpconf
lapiceoi	dist/lapic.c	/^lapiceoi(void)$/;"	f
lapiceoi	lapic.c	/^lapiceoi(void)$/;"	f
lapicid	dist/lapic.c	/^lapicid(void)$/;"	f
lapicid	lapic.c	/^lapicid(void)$/;"	f
lapicinit	dist/lapic.c	/^lapicinit(void)$/;"	f
lapicinit	lapic.c	/^lapicinit(void)$/;"	f
lapicstartap	dist/lapic.c	/^lapicstartap(uchar apicid, uint addr)$/;"	f
lapicstartap	lapic.c	/^lapicstartap(uchar apicid, uint addr)$/;"	f
lapicw	dist/lapic.c	/^lapicw(int index, int value)$/;"	f	file:
lapicw	lapic.c	/^lapicw(int index, int value)$/;"	f	file:
last	kernel.asm	/^  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);$/;"	d
lcmd	sh.asm	/^    lcmd = (struct listcmd*)cmd;$/;"	d
lcr3	dist/x86.h	/^lcr3(uint val)$/;"	f
lcr3	x86.h	/^lcr3(uint val)$/;"	f
ldt	dist/mmu.h	/^  ushort ldt;$/;"	m	struct:taskstate
ldt	mmu.h	/^  ushort ldt;$/;"	m	struct:taskstate
left	dist/sh.c	/^  struct cmd *left;$/;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:
left	dist/sh.c	/^  struct cmd *left;$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:
left	sh.c	/^  struct cmd *left;$/;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:
left	sh.c	/^  struct cmd *left;$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:
len	kernel.asm	/^  len = path - s;$/;"	d
length	dist/mp.h	/^  uchar length;                 \/\/ 1$/;"	m	struct:mp
length	dist/mp.h	/^  ushort length;                \/\/ total table length$/;"	m	struct:mpconf
length	mp.h	/^  uchar length;                 \/\/ 1$/;"	m	struct:mp
length	mp.h	/^  ushort length;                \/\/ total table length$/;"	m	struct:mpconf
lgdt	dist/x86.h	/^lgdt(struct segdesc *p, int size)$/;"	f
lgdt	x86.h	/^lgdt(struct segdesc *p, int size)$/;"	f
lh	dist/log.c	/^  struct logheader lh;$/;"	m	struct:log	typeref:struct:log::logheader	file:
lh	log.c	/^  struct logheader lh;$/;"	m	struct:log	typeref:struct:log::logheader	file:
lidt	dist/x86.h	/^lidt(struct gatedesc *p, int size)$/;"	f
lidt	x86.h	/^lidt(struct gatedesc *p, int size)$/;"	f
lim_15_0	dist/mmu.h	/^  uint lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:segdesc
lim_15_0	mmu.h	/^  uint lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:segdesc
lim_19_16	dist/mmu.h	/^  uint lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:segdesc
lim_19_16	mmu.h	/^  uint lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:segdesc
link	dist/mmu.h	/^  uint link;         \/\/ Old ts selector$/;"	m	struct:taskstate
link	mmu.h	/^  uint link;         \/\/ Old ts selector$/;"	m	struct:taskstate
linktest	dist/usertests.c	/^linktest(void)$/;"	f
linktest	usertests.c	/^linktest(void)$/;"	f
linkunlink	dist/usertests.c	/^linkunlink()$/;"	f
linkunlink	usertests.c	/^linkunlink()$/;"	f
listcmd	dist/sh.c	/^listcmd(struct cmd *left, struct cmd *right)$/;"	f
listcmd	dist/sh.c	/^struct listcmd {$/;"	s	file:
listcmd	sh.c	/^listcmd(struct cmd *left, struct cmd *right)$/;"	f
listcmd	sh.c	/^struct listcmd {$/;"	s	file:
lk	dist/sleeplock.h	/^  struct spinlock lk; \/\/ spinlock protecting this sleep lock$/;"	m	struct:sleeplock	typeref:struct:sleeplock::spinlock
lk	sleeplock.h	/^  struct spinlock lk; \/\/ spinlock protecting this sleep lock$/;"	m	struct:sleeplock	typeref:struct:sleeplock::spinlock
loadgs	dist/x86.h	/^loadgs(ushort v)$/;"	f
loadgs	x86.h	/^loadgs(ushort v)$/;"	f
loaduvm	dist/vm.c	/^loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)$/;"	f
loaduvm	vm.c	/^loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)$/;"	f
lock	bio.c	/^  struct spinlock lock;$/;"	m	struct:__anon18	typeref:struct:__anon18::spinlock	file:
lock	buf.h	/^  struct sleeplock lock;$/;"	m	struct:buf	typeref:struct:buf::sleeplock
lock	console.c	/^  struct spinlock lock;$/;"	m	struct:__anon5	typeref:struct:__anon5::spinlock	file:
lock	dist/bio.c	/^  struct spinlock lock;$/;"	m	struct:__anon17	typeref:struct:__anon17::spinlock	file:
lock	dist/buf.h	/^  struct sleeplock lock;$/;"	m	struct:buf	typeref:struct:buf::sleeplock
lock	dist/console.c	/^  struct spinlock lock;$/;"	m	struct:__anon13	typeref:struct:__anon13::spinlock	file:
lock	dist/file.c	/^  struct spinlock lock;$/;"	m	struct:__anon10	typeref:struct:__anon10::spinlock	file:
lock	dist/file.h	/^  struct sleeplock lock; \/\/ protects everything below here$/;"	m	struct:inode	typeref:struct:inode::sleeplock
lock	dist/fs.c	/^  struct spinlock lock;$/;"	m	struct:__anon11	typeref:struct:__anon11::spinlock	file:
lock	dist/kalloc.c	/^  struct spinlock lock;$/;"	m	struct:__anon12	typeref:struct:__anon12::spinlock	file:
lock	dist/log.c	/^  struct spinlock lock;$/;"	m	struct:log	typeref:struct:log::spinlock	file:
lock	dist/pipe.c	/^  struct spinlock lock;$/;"	m	struct:pipe	typeref:struct:pipe::spinlock	file:
lock	dist/proc.c	/^  struct spinlock lock;$/;"	m	struct:__anon16	typeref:struct:__anon16::spinlock	file:
lock	file.c	/^  struct spinlock lock;$/;"	m	struct:__anon2	typeref:struct:__anon2::spinlock	file:
lock	file.h	/^  struct sleeplock lock; \/\/ protects everything below here$/;"	m	struct:inode	typeref:struct:inode::sleeplock
lock	fs.c	/^  struct spinlock lock;$/;"	m	struct:__anon3	typeref:struct:__anon3::spinlock	file:
lock	kalloc.c	/^  struct spinlock lock;$/;"	m	struct:__anon4	typeref:struct:__anon4::spinlock	file:
lock	log.c	/^  struct spinlock lock;$/;"	m	struct:log	typeref:struct:log::spinlock	file:
lock	pipe.c	/^  struct spinlock lock;$/;"	m	struct:pipe	typeref:struct:pipe::spinlock	file:
lock	proc.c	/^  struct spinlock lock;$/;"	m	struct:__anon8	typeref:struct:__anon8::spinlock	file:
locked	dist/sleeplock.h	/^  uint locked;       \/\/ Is the lock held?$/;"	m	struct:sleeplock
locked	dist/spinlock.h	/^  uint locked;       \/\/ Is the lock held?$/;"	m	struct:spinlock
locked	sleeplock.h	/^  uint locked;       \/\/ Is the lock held?$/;"	m	struct:sleeplock
locked	spinlock.h	/^  uint locked;       \/\/ Is the lock held?$/;"	m	struct:spinlock
locking	console.c	/^  int locking;$/;"	m	struct:__anon5	file:
locking	dist/console.c	/^  int locking;$/;"	m	struct:__anon13	file:
locking	kernel.asm	/^  locking = cons.locking;$/;"	d
log	dist/log.c	/^struct log log;$/;"	v	typeref:struct:log
log	dist/log.c	/^struct log {$/;"	s	file:
log	log.c	/^struct log log;$/;"	v	typeref:struct:log
log	log.c	/^struct log {$/;"	s	file:
log_write	dist/log.c	/^log_write(struct buf *b)$/;"	f
log_write	log.c	/^log_write(struct buf *b)$/;"	f
logheader	dist/log.c	/^struct logheader {$/;"	s	file:
logheader	log.c	/^struct logheader {$/;"	s	file:
logstart	dist/fs.h	/^  uint logstart;     \/\/ Block number of first log block$/;"	m	struct:superblock
logstart	fs.h	/^  uint logstart;     \/\/ Block number of first log block$/;"	m	struct:superblock
ls	dist/ls.c	/^ls(char *path)$/;"	f
ls	ls.c	/^ls(char *path)$/;"	f
ltr	dist/x86.h	/^ltr(ushort sel)$/;"	f
ltr	x86.h	/^ltr(ushort sel)$/;"	f
m	grep.asm	/^      m = 0;$/;"	d
m	grep.asm	/^  m = 0;$/;"	d
m	kernel.asm	/^      m = 1 << (bi % 8);$/;"	d
m	kernel.asm	/^    m = min(n - tot, BSIZE - off%BSIZE);$/;"	d
m	kernel.asm	/^  m = 1 << (bi % 8);$/;"	d
m1	usertests.asm	/^    m1 = malloc(1024*20);$/;"	d
m2	usertests.asm	/^      m2 = *(char**)m1;$/;"	d
machine	dist/elf.h	/^  ushort machine;$/;"	m	struct:elfhdr
machine	elf.h	/^  ushort machine;$/;"	m	struct:elfhdr
magic	dist/elf.h	/^  uint magic;  \/\/ must equal ELF_MAGIC$/;"	m	struct:elfhdr
magic	elf.h	/^  uint magic;  \/\/ must equal ELF_MAGIC$/;"	m	struct:elfhdr
main	cat.c	/^main(int argc, char *argv[])$/;"	f
main	dist/cat.c	/^main(int argc, char *argv[])$/;"	f
main	dist/echo.c	/^main(int argc, char *argv[])$/;"	f
main	dist/forktest.c	/^main(void)$/;"	f
main	dist/getnice.c	/^int main(int argc, char* argv[]){$/;"	f
main	dist/grep.c	/^main(int argc, char *argv[])$/;"	f
main	dist/init.c	/^main(void)$/;"	f
main	dist/kill.c	/^main(int argc, char **argv)$/;"	f
main	dist/ln.c	/^main(int argc, char *argv[])$/;"	f
main	dist/ls.c	/^main(int argc, char *argv[])$/;"	f
main	dist/main.c	/^main(void)$/;"	f
main	dist/mkdir.c	/^main(int argc, char *argv[])$/;"	f
main	dist/mkfs.c	/^main(int argc, char *argv[])$/;"	f
main	dist/ps.c	/^int main(int argc, char* argv[]){$/;"	f
main	dist/rm.c	/^main(int argc, char *argv[])$/;"	f
main	dist/setnice.c	/^int main(int argc, char* argv[]){$/;"	f
main	dist/sh.c	/^main(void)$/;"	f
main	dist/stressfs.c	/^main(int argc, char *argv[])$/;"	f
main	dist/test1.c	/^int main(int argc, char **argv)$/;"	f
main	dist/test2.c	/^int main(int argc, char **argv)$/;"	f
main	dist/usertests.c	/^main(int argc, char *argv[])$/;"	f
main	dist/wc.c	/^main(int argc, char *argv[])$/;"	f
main	dist/zombie.c	/^main(void)$/;"	f
main	echo.c	/^main(int argc, char *argv[])$/;"	f
main	forktest.c	/^main(void)$/;"	f
main	getnice.c	/^int main(int argc, char* argv[]){$/;"	f
main	grep.c	/^main(int argc, char *argv[])$/;"	f
main	init.c	/^main(void)$/;"	f
main	kill.c	/^main(int argc, char **argv)$/;"	f
main	ln.c	/^main(int argc, char *argv[])$/;"	f
main	ls.c	/^main(int argc, char *argv[])$/;"	f
main	main.c	/^main(void)$/;"	f
main	mkdir.c	/^main(int argc, char *argv[])$/;"	f
main	mkfs.c	/^main(int argc, char *argv[])$/;"	f
main	ps.c	/^int main(int argc, char* argv[]){$/;"	f
main	rm.c	/^main(int argc, char *argv[])$/;"	f
main	setnice.c	/^int main(int argc, char* argv[]){$/;"	f
main	sh.c	/^main(void)$/;"	f
main	stressfs.c	/^main(int argc, char *argv[])$/;"	f
main	swaptest.c	/^int main(int argc, char** argv)$/;"	f
main	test1.c	/^int main(int argc, char **argv)$/;"	f
main	test2.c	/^int main(int argc, char **argv)$/;"	f
main	usertests.c	/^main(int argc, char *argv[])$/;"	f
main	wc.c	/^main(int argc, char *argv[])$/;"	f
main	zombie.c	/^main(void)$/;"	f
major	dist/file.h	/^  short major;$/;"	m	struct:inode
major	dist/fs.h	/^  short major;          \/\/ Major device number (T_DEV only)$/;"	m	struct:dinode
major	file.h	/^  short major;$/;"	m	struct:inode
major	fs.h	/^  short major;          \/\/ Major device number (T_DEV only)$/;"	m	struct:dinode
malloc	dist/umalloc.c	/^malloc(uint nbytes)$/;"	f
malloc	umalloc.c	/^malloc(uint nbytes)$/;"	f
mappages	dist/vm.c	/^mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)$/;"	f	file:
mappages	vm.c	/^mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)$/;"	f	file:
match	dist/grep.c	/^match(char *re, char *text)$/;"	f
match	grep.c	/^match(char *re, char *text)$/;"	f
matchhere	dist/grep.c	/^int matchhere(char *re, char *text)$/;"	f
matchhere	grep.c	/^int matchhere(char *re, char *text)$/;"	f
matchstar	dist/grep.c	/^int matchstar(int c, char *re, char *text)$/;"	f
matchstar	grep.c	/^int matchstar(int c, char *re, char *text)$/;"	f
maxintr	kernel.asm	/^  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;$/;"	d
mem	dist/usertests.c	/^mem(void)$/;"	f
mem	kernel.asm	/^    mem = kalloc();$/;"	d
mem	kernel.asm	/^  mem = kalloc();$/;"	d
mem	usertests.c	/^mem(void)$/;"	f
memcmp	dist/string.c	/^memcmp(const void *v1, const void *v2, uint n)$/;"	f
memcmp	string.c	/^memcmp(const void *v1, const void *v2, uint n)$/;"	f
memcpy	dist/string.c	/^memcpy(void *dst, const void *src, uint n)$/;"	f
memcpy	string.c	/^memcpy(void *dst, const void *src, uint n)$/;"	f
memdisk	memide.c	/^static uchar *memdisk;$/;"	v	file:
memmove	dist/string.c	/^memmove(void *dst, const void *src, uint n)$/;"	f
memmove	dist/ulib.c	/^memmove(void *vdst, const void *vsrc, int n)$/;"	f
memmove	string.c	/^memmove(void *dst, const void *src, uint n)$/;"	f
memmove	ulib.c	/^memmove(void *vdst, const void *vsrc, int n)$/;"	f
memset	dist/string.c	/^memset(void *dst, int c, uint n)$/;"	f
memset	dist/ulib.c	/^memset(void *dst, int c, uint n)$/;"	f
memset	string.c	/^memset(void *dst, int c, uint n)$/;"	f
memset	ulib.c	/^memset(void *dst, int c, uint n)$/;"	f
memsz	dist/elf.h	/^  uint memsz;$/;"	m	struct:proghdr
memsz	elf.h	/^  uint memsz;$/;"	m	struct:proghdr
microdelay	dist/lapic.c	/^microdelay(int us)$/;"	f
microdelay	lapic.c	/^microdelay(int us)$/;"	f
min	dist/fs.c	24;"	d	file:
min	dist/mkfs.c	253;"	d	file:
min	fs.c	24;"	d	file:
min	mkfs.c	253;"	d	file:
minor	dist/file.h	/^  short minor;$/;"	m	struct:inode
minor	dist/fs.h	/^  short minor;          \/\/ Minor device number (T_DEV only)$/;"	m	struct:dinode
minor	file.h	/^  short minor;$/;"	m	struct:inode
minor	fs.h	/^  short minor;          \/\/ Minor device number (T_DEV only)$/;"	m	struct:dinode
minute	date.h	/^  uint minute;$/;"	m	struct:rtcdate
minute	dist/date.h	/^  uint minute;$/;"	m	struct:rtcdate
mode	dist/sh.c	/^  int mode;$/;"	m	struct:redircmd	file:
mode	sh.c	/^  int mode;$/;"	m	struct:redircmd	file:
month	date.h	/^  uint month;$/;"	m	struct:rtcdate
month	dist/date.h	/^  uint month;$/;"	m	struct:rtcdate
morecore	dist/umalloc.c	/^morecore(uint nu)$/;"	f	file:
morecore	umalloc.c	/^morecore(uint nu)$/;"	f	file:
mp	dist/mp.h	/^struct mp {             \/\/ floating pointer$/;"	s
mp	mp.h	/^struct mp {             \/\/ floating pointer$/;"	s
mpconf	dist/mp.h	/^struct mpconf {         \/\/ configuration table header$/;"	s
mpconf	mp.h	/^struct mpconf {         \/\/ configuration table header$/;"	s
mpconfig	dist/mp.c	/^mpconfig(struct mp **pmp)$/;"	f	file:
mpconfig	mp.c	/^mpconfig(struct mp **pmp)$/;"	f	file:
mpenter	dist/main.c	/^mpenter(void)$/;"	f	file:
mpenter	main.c	/^mpenter(void)$/;"	f	file:
mpinit	dist/mp.c	/^mpinit(void)$/;"	f
mpinit	mp.c	/^mpinit(void)$/;"	f
mpioapic	dist/mp.h	/^struct mpioapic {       \/\/ I\/O APIC table entry$/;"	s
mpioapic	mp.h	/^struct mpioapic {       \/\/ I\/O APIC table entry$/;"	s
mpmain	dist/main.c	/^mpmain(void)$/;"	f	file:
mpmain	main.c	/^mpmain(void)$/;"	f	file:
mpproc	dist/mp.h	/^struct mpproc {         \/\/ processor table entry$/;"	s
mpproc	mp.h	/^struct mpproc {         \/\/ processor table entry$/;"	s
mpsearch	dist/mp.c	/^mpsearch(void)$/;"	f	file:
mpsearch	mp.c	/^mpsearch(void)$/;"	f	file:
mpsearch1	dist/mp.c	/^mpsearch1(uint a, int len)$/;"	f	file:
mpsearch1	mp.c	/^mpsearch1(uint a, int len)$/;"	f	file:
multiboot_header	dist/entry.S	/^multiboot_header:$/;"	l
multiboot_header	entry.S	/^multiboot_header:$/;"	l
mycpu	dist/proc.c	/^mycpu(void)$/;"	f
mycpu	proc.c	/^mycpu(void)$/;"	f
myproc	dist/proc.c	/^myproc(void) {$/;"	f
myproc	proc.c	/^myproc(void) {$/;"	f
n	cat.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	cat.asm	/^  n = 0;$/;"	d
n	dist/log.c	/^  int n;$/;"	m	struct:logheader	file:
n	echo.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	echo.asm	/^  n = 0;$/;"	d
n	forktest.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	forktest.asm	/^  n = 0;$/;"	d
n	getnice.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	getnice.asm	/^  n = 0;$/;"	d
n	grep.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	grep.asm	/^  n = 0;$/;"	d
n	init.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	init.asm	/^  n = 0;$/;"	d
n	kernel.asm	/^      n = len;$/;"	d
n	kernel.asm	/^    n = PGSIZE - (va - va0);$/;"	d
n	kernel.asm	/^    n = ip->size - off;$/;"	d
n	kill.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	kill.asm	/^  n = 0;$/;"	d
n	ln.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	ln.asm	/^  n = 0;$/;"	d
n	log.c	/^  int n;$/;"	m	struct:logheader	file:
n	ls.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	ls.asm	/^  n = 0;$/;"	d
n	mkdir.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	mkdir.asm	/^  n = 0;$/;"	d
n	ps.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	ps.asm	/^  n = 0;$/;"	d
n	rm.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	rm.asm	/^  n = 0;$/;"	d
n	setnice.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	setnice.asm	/^  n = 0;$/;"	d
n	sh.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	sh.asm	/^  n = 0;$/;"	d
n	stressfs.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	stressfs.asm	/^  n = 0;$/;"	d
n	swaptest.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	swaptest.asm	/^  n = 0;$/;"	d
n	test1.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	test1.asm	/^  n = 0;$/;"	d
n	test2.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	test2.asm	/^  n = 0;$/;"	d
n	testcase1.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	testcase1.asm	/^  n = 0;$/;"	d
n	testcase2.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	testcase2.asm	/^  n = 0;$/;"	d
n	usertests.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	usertests.asm	/^  n = 0;$/;"	d
n	wc.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	wc.asm	/^  n = 0;$/;"	d
n	zombie.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	zombie.asm	/^  n = 0;$/;"	d
n1	kernel.asm	/^        n1 = max;$/;"	d
name	cat.asm	/^  name: \\$/;"	l
name	dist/fs.h	/^  char name[DIRSIZ];$/;"	m	struct:dirent
name	dist/proc.h	/^  char name[16];               \/\/ Process name (debugging)$/;"	m	struct:proc
name	dist/sleeplock.h	/^  char *name;        \/\/ Name of lock.$/;"	m	struct:sleeplock
name	dist/spinlock.h	/^  char *name;        \/\/ Name of lock.$/;"	m	struct:spinlock
name	dist/usertests.c	/^char name[3];$/;"	v
name	dist/usys.S	/^  name: \\$/;"	l
name	echo.asm	/^  name: \\$/;"	l
name	forktest.asm	/^  name: \\$/;"	l
name	fs.h	/^  char name[DIRSIZ];$/;"	m	struct:dirent
name	getnice.asm	/^  name: \\$/;"	l
name	grep.asm	/^  name: \\$/;"	l
name	init.asm	/^  name: \\$/;"	l
name	kill.asm	/^  name: \\$/;"	l
name	ln.asm	/^  name: \\$/;"	l
name	ls.asm	/^  name: \\$/;"	l
name	mkdir.asm	/^  name: \\$/;"	l
name	proc.h	/^  char name[16];               \/\/ Process name (debugging)$/;"	m	struct:proc
name	ps.asm	/^  name: \\$/;"	l
name	rm.asm	/^  name: \\$/;"	l
name	setnice.asm	/^  name: \\$/;"	l
name	sh.asm	/^  name: \\$/;"	l
name	sleeplock.h	/^  char *name;        \/\/ Name of lock.$/;"	m	struct:sleeplock
name	spinlock.h	/^  char *name;        \/\/ Name of lock.$/;"	m	struct:spinlock
name	stressfs.asm	/^  name: \\$/;"	l
name	swaptest.asm	/^  name: \\$/;"	l
name	test1.asm	/^  name: \\$/;"	l
name	test2.asm	/^  name: \\$/;"	l
name	testcase1.asm	/^  name: \\$/;"	l
name	testcase2.asm	/^  name: \\$/;"	l
name	usertests.asm	/^  name: \\$/;"	l
name	usertests.c	/^char name[3];$/;"	v
name	usys.S	/^  name: \\$/;"	l
name	wc.asm	/^  name: \\$/;"	l
name	zombie.asm	/^  name: \\$/;"	l
namecmp	dist/fs.c	/^namecmp(const char *s, const char *t)$/;"	f
namecmp	fs.c	/^namecmp(const char *s, const char *t)$/;"	f
namei	dist/fs.c	/^namei(char *path)$/;"	f
namei	fs.c	/^namei(char *path)$/;"	f
nameiparent	dist/fs.c	/^nameiparent(char *path, char *name)$/;"	f
nameiparent	fs.c	/^nameiparent(char *path, char *name)$/;"	f
namex	dist/fs.c	/^namex(char *path, int nameiparent, char *name)$/;"	f	file:
namex	fs.c	/^namex(char *path, int nameiparent, char *name)$/;"	f	file:
nbitmap	dist/mkfs.c	/^int nbitmap = FSSIZE\/(BSIZE*8) + 1;$/;"	v
nbitmap	mkfs.c	/^int nbitmap = FSSIZE\/(BSIZE*8) + 1;$/;"	v
nblocks	dist/fs.h	/^  uint nblocks;      \/\/ Number of data blocks$/;"	m	struct:superblock
nblocks	dist/mkfs.c	/^int nblocks;  \/\/ Number of data blocks$/;"	v
nblocks	fs.h	/^  uint nblocks;      \/\/ Number of data blocks$/;"	m	struct:superblock
nblocks	mkfs.c	/^int nblocks;  \/\/ Number of data blocks$/;"	v
nc	usertests.asm	/^  nc = np = 0;$/;"	d
ncli	dist/proc.h	/^  int ncli;                    \/\/ Depth of pushcli nesting.$/;"	m	struct:cpu
ncli	proc.h	/^  int ncli;                    \/\/ Depth of pushcli nesting.$/;"	m	struct:cpu
ncpu	dist/mp.c	/^int ncpu;$/;"	v
ncpu	mp.c	/^int ncpu;$/;"	v
neg	cat.asm	/^    neg = 1;$/;"	d
neg	cat.asm	/^  neg = 0;$/;"	d
neg	echo.asm	/^    neg = 1;$/;"	d
neg	echo.asm	/^  neg = 0;$/;"	d
neg	getnice.asm	/^    neg = 1;$/;"	d
neg	getnice.asm	/^  neg = 0;$/;"	d
neg	grep.asm	/^    neg = 1;$/;"	d
neg	grep.asm	/^  neg = 0;$/;"	d
neg	init.asm	/^    neg = 1;$/;"	d
neg	init.asm	/^  neg = 0;$/;"	d
neg	kill.asm	/^    neg = 1;$/;"	d
neg	kill.asm	/^  neg = 0;$/;"	d
neg	ln.asm	/^    neg = 1;$/;"	d
neg	ln.asm	/^  neg = 0;$/;"	d
neg	ls.asm	/^    neg = 1;$/;"	d
neg	ls.asm	/^  neg = 0;$/;"	d
neg	mkdir.asm	/^    neg = 1;$/;"	d
neg	mkdir.asm	/^  neg = 0;$/;"	d
neg	ps.asm	/^    neg = 1;$/;"	d
neg	ps.asm	/^  neg = 0;$/;"	d
neg	rm.asm	/^    neg = 1;$/;"	d
neg	rm.asm	/^  neg = 0;$/;"	d
neg	setnice.asm	/^    neg = 1;$/;"	d
neg	setnice.asm	/^  neg = 0;$/;"	d
neg	sh.asm	/^    neg = 1;$/;"	d
neg	sh.asm	/^  neg = 0;$/;"	d
neg	stressfs.asm	/^    neg = 1;$/;"	d
neg	stressfs.asm	/^  neg = 0;$/;"	d
neg	swaptest.asm	/^    neg = 1;$/;"	d
neg	swaptest.asm	/^  neg = 0;$/;"	d
neg	test1.asm	/^    neg = 1;$/;"	d
neg	test1.asm	/^  neg = 0;$/;"	d
neg	test2.asm	/^    neg = 1;$/;"	d
neg	test2.asm	/^  neg = 0;$/;"	d
neg	testcase1.asm	/^    neg = 1;$/;"	d
neg	testcase1.asm	/^  neg = 0;$/;"	d
neg	testcase2.asm	/^    neg = 1;$/;"	d
neg	testcase2.asm	/^  neg = 0;$/;"	d
neg	usertests.asm	/^    neg = 1;$/;"	d
neg	usertests.asm	/^  neg = 0;$/;"	d
neg	wc.asm	/^    neg = 1;$/;"	d
neg	wc.asm	/^  neg = 0;$/;"	d
neg	zombie.asm	/^    neg = 1;$/;"	d
neg	zombie.asm	/^  neg = 0;$/;"	d
next	buf.h	/^  struct buf *next;$/;"	m	struct:buf	typeref:struct:buf::buf
next	dist/buf.h	/^  struct buf *next;$/;"	m	struct:buf	typeref:struct:buf::buf
next	dist/kalloc.c	/^  struct run *next;$/;"	m	struct:run	typeref:struct:run::run	file:
next	kalloc.c	/^  struct run *next;$/;"	m	struct:run	typeref:struct:run::run	file:
nextpid	dist/proc.c	/^int nextpid = 1;$/;"	v
nextpid	proc.c	/^int nextpid = 1;$/;"	v
nice	test1.asm	/^		nice = getnice(pid);$/;"	d
nice	testcase1.asm	/^		nice = getnice(pid);$/;"	d
ninodeblocks	dist/mkfs.c	/^int ninodeblocks = NINODES \/ IPB + 1;$/;"	v
ninodeblocks	mkfs.c	/^int ninodeblocks = NINODES \/ IPB + 1;$/;"	v
ninodes	dist/fs.h	/^  uint ninodes;      \/\/ Number of inodes.$/;"	m	struct:superblock
ninodes	fs.h	/^  uint ninodes;      \/\/ Number of inodes.$/;"	m	struct:superblock
nlink	dist/file.h	/^  short nlink;$/;"	m	struct:inode
nlink	dist/fs.h	/^  short nlink;          \/\/ Number of links to inode in file system$/;"	m	struct:dinode
nlink	dist/stat.h	/^  short nlink; \/\/ Number of links to file$/;"	m	struct:stat
nlink	file.h	/^  short nlink;$/;"	m	struct:inode
nlink	fs.h	/^  short nlink;          \/\/ Number of links to inode in file system$/;"	m	struct:dinode
nlink	stat.h	/^  short nlink; \/\/ Number of links to file$/;"	m	struct:stat
nlog	dist/fs.h	/^  uint nlog;         \/\/ Number of log blocks$/;"	m	struct:superblock
nlog	dist/mkfs.c	/^int nlog = LOGSIZE;$/;"	v
nlog	fs.h	/^  uint nlog;         \/\/ Number of log blocks$/;"	m	struct:superblock
nlog	mkfs.c	/^int nlog = LOGSIZE;$/;"	v
nmeta	dist/mkfs.c	/^int nmeta;    \/\/ Number of meta blocks (boot, sb, nlog, inode, bitmap)$/;"	v
nmeta	mkfs.c	/^int nmeta;    \/\/ Number of meta blocks (boot, sb, nlog, inode, bitmap)$/;"	v
normalmap	dist/kbd.h	/^static uchar normalmap[256] =$/;"	v
normalmap	kbd.h	/^static uchar normalmap[256] =$/;"	v
nread	dist/pipe.c	/^  uint nread;     \/\/ number of bytes read$/;"	m	struct:pipe	file:
nread	pipe.c	/^  uint nread;     \/\/ number of bytes read$/;"	m	struct:pipe	file:
nulterminate	dist/sh.c	/^nulterminate(struct cmd *cmd)$/;"	f
nulterminate	sh.c	/^nulterminate(struct cmd *cmd)$/;"	f
num	kernel.asm	/^  num = curproc->tf->eax;$/;"	d
nunits	cat.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	echo.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	getnice.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	grep.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	init.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	kill.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	ln.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	ls.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	mkdir.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	ps.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	rm.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	setnice.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	sh.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	stressfs.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	swaptest.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	test1.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	test2.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	testcase1.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	testcase2.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	usertests.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	wc.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	zombie.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nwrite	dist/pipe.c	/^  uint nwrite;    \/\/ number of bytes written$/;"	m	struct:pipe	file:
nwrite	pipe.c	/^  uint nwrite;    \/\/ number of bytes written$/;"	m	struct:pipe	file:
oemlength	dist/mp.h	/^  ushort oemlength;             \/\/ OEM table length$/;"	m	struct:mpconf
oemlength	mp.h	/^  ushort oemlength;             \/\/ OEM table length$/;"	m	struct:mpconf
oemtable	dist/mp.h	/^  uint *oemtable;               \/\/ OEM table pointer$/;"	m	struct:mpconf
oemtable	mp.h	/^  uint *oemtable;               \/\/ OEM table pointer$/;"	m	struct:mpconf
oesp	dist/x86.h	/^  uint oesp;      \/\/ useless & ignored$/;"	m	struct:trapframe
oesp	x86.h	/^  uint oesp;      \/\/ useless & ignored$/;"	m	struct:trapframe
off	dist/elf.h	/^  uint off;$/;"	m	struct:proghdr
off	dist/file.h	/^  uint off;$/;"	m	struct:file
off	elf.h	/^  uint off;$/;"	m	struct:proghdr
off	file.h	/^  uint off;$/;"	m	struct:file
off_15_0	dist/mmu.h	/^  uint off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:gatedesc
off_15_0	mmu.h	/^  uint off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:gatedesc
off_31_16	dist/mmu.h	/^  uint off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:gatedesc
off_31_16	mmu.h	/^  uint off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:gatedesc
offset	bootblock.asm	/^  offset = (offset \/ SECTSIZE) + 1;$/;"	d
ofile	dist/proc.h	/^  struct file *ofile[NOFILE];  \/\/ Open files$/;"	m	struct:proc	typeref:struct:proc::file
ofile	proc.h	/^  struct file *ofile[NOFILE];  \/\/ Open files$/;"	m	struct:proc	typeref:struct:proc::file
oldbrk	usertests.asm	/^  oldbrk = sbrk(0);$/;"	d
oldpgdir	kernel.asm	/^  oldpgdir = curproc->pgdir;$/;"	d
openiputtest	dist/usertests.c	/^openiputtest(void)$/;"	f
openiputtest	usertests.c	/^openiputtest(void)$/;"	f
opentest	dist/usertests.c	/^opentest(void)$/;"	f
opentest	usertests.c	/^opentest(void)$/;"	f
os	cat.asm	/^  os = s;$/;"	d
os	echo.asm	/^  os = s;$/;"	d
os	forktest.asm	/^  os = s;$/;"	d
os	getnice.asm	/^  os = s;$/;"	d
os	grep.asm	/^  os = s;$/;"	d
os	init.asm	/^  os = s;$/;"	d
os	kill.asm	/^  os = s;$/;"	d
os	ln.asm	/^  os = s;$/;"	d
os	ls.asm	/^  os = s;$/;"	d
os	mkdir.asm	/^  os = s;$/;"	d
os	ps.asm	/^  os = s;$/;"	d
os	rm.asm	/^  os = s;$/;"	d
os	setnice.asm	/^  os = s;$/;"	d
os	sh.asm	/^  os = s;$/;"	d
os	stressfs.asm	/^  os = s;$/;"	d
os	swaptest.asm	/^  os = s;$/;"	d
os	test1.asm	/^  os = s;$/;"	d
os	test2.asm	/^  os = s;$/;"	d
os	testcase1.asm	/^  os = s;$/;"	d
os	testcase2.asm	/^  os = s;$/;"	d
os	usertests.asm	/^  os = s;$/;"	d
os	wc.asm	/^  os = s;$/;"	d
os	zombie.asm	/^  os = s;$/;"	d
outb	dist/x86.h	/^outb(ushort port, uchar data)$/;"	f
outb	x86.h	/^outb(ushort port, uchar data)$/;"	f
outsl	dist/x86.h	/^outsl(int port, const void *addr, int cnt)$/;"	f
outsl	x86.h	/^outsl(int port, const void *addr, int cnt)$/;"	f
outstanding	dist/log.c	/^  int outstanding; \/\/ how many FS sys calls are executing.$/;"	m	struct:log	file:
outstanding	log.c	/^  int outstanding; \/\/ how many FS sys calls are executing.$/;"	m	struct:log	file:
outw	dist/x86.h	/^outw(ushort port, ushort data)$/;"	f
outw	x86.h	/^outw(ushort port, ushort data)$/;"	f
p	cat.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	dist/mmu.h	/^  uint p : 1;           \/\/ Present$/;"	m	struct:gatedesc
p	dist/mmu.h	/^  uint p : 1;          \/\/ Present$/;"	m	struct:segdesc
p	echo.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	getnice.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	grep.asm	/^      p = q+1;$/;"	d
p	grep.asm	/^    p = buf;$/;"	d
p	grep.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	init.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	kernel.asm	/^    p = ((bda[0x14]<<8)|bda[0x13])*1024;$/;"	d
p	kernel.asm	/^  p = (char*)PGROUNDUP((uint)vstart);$/;"	d
p	kernel.asm	/^  p = 0;$/;"	d
p	kernel.asm	/^  p = allocproc();$/;"	d
p	kernel.asm	/^  p = c->proc;$/;"	d
p	kill.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	ln.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	ls.asm	/^    p = buf+strlen(buf);$/;"	d
p	ls.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	mkdir.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	mmu.h	/^  uint p : 1;           \/\/ Present$/;"	m	struct:gatedesc
p	mmu.h	/^  uint p : 1;          \/\/ Present$/;"	m	struct:segdesc
p	ps.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	rm.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	setnice.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	sh.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	stressfs.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	swaptest.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	test1.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	test2.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	testcase1.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	testcase2.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	usertests.asm	/^  p = sbrk(amt);$/;"	d
p	usertests.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	wc.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	zombie.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
pa	bootblock.asm	/^    pa = (uchar*)ph->paddr;$/;"	d
pa	kernel.asm	/^      pa = PTE_ADDR(*pte);$/;"	d
pa	kernel.asm	/^    pa = PTE_ADDR(*pte);$/;"	d
pa0	kernel.asm	/^    pa0 = uva2ka(pgdir, (char*)va0);$/;"	d
pad	dist/ioapic.c	/^  uint pad[3];$/;"	m	struct:ioapic	file:
pad	dist/runoff	/^pad()$/;"	f
pad	ioapic.c	/^  uint pad[3];$/;"	m	struct:ioapic	file:
pad	runoff	/^pad()$/;"	f
padding1	dist/mmu.h	/^  ushort padding1;$/;"	m	struct:taskstate
padding1	dist/x86.h	/^  ushort padding1;$/;"	m	struct:trapframe
padding1	mmu.h	/^  ushort padding1;$/;"	m	struct:taskstate
padding1	x86.h	/^  ushort padding1;$/;"	m	struct:trapframe
padding10	dist/mmu.h	/^  ushort padding10;$/;"	m	struct:taskstate
padding10	mmu.h	/^  ushort padding10;$/;"	m	struct:taskstate
padding2	dist/mmu.h	/^  ushort padding2;$/;"	m	struct:taskstate
padding2	dist/x86.h	/^  ushort padding2;$/;"	m	struct:trapframe
padding2	mmu.h	/^  ushort padding2;$/;"	m	struct:taskstate
padding2	x86.h	/^  ushort padding2;$/;"	m	struct:trapframe
padding3	dist/mmu.h	/^  ushort padding3;$/;"	m	struct:taskstate
padding3	dist/x86.h	/^  ushort padding3;$/;"	m	struct:trapframe
padding3	mmu.h	/^  ushort padding3;$/;"	m	struct:taskstate
padding3	x86.h	/^  ushort padding3;$/;"	m	struct:trapframe
padding4	dist/mmu.h	/^  ushort padding4;$/;"	m	struct:taskstate
padding4	dist/x86.h	/^  ushort padding4;$/;"	m	struct:trapframe
padding4	mmu.h	/^  ushort padding4;$/;"	m	struct:taskstate
padding4	x86.h	/^  ushort padding4;$/;"	m	struct:trapframe
padding5	dist/mmu.h	/^  ushort padding5;$/;"	m	struct:taskstate
padding5	dist/x86.h	/^  ushort padding5;$/;"	m	struct:trapframe
padding5	mmu.h	/^  ushort padding5;$/;"	m	struct:taskstate
padding5	x86.h	/^  ushort padding5;$/;"	m	struct:trapframe
padding6	dist/mmu.h	/^  ushort padding6;$/;"	m	struct:taskstate
padding6	dist/x86.h	/^  ushort padding6;$/;"	m	struct:trapframe
padding6	mmu.h	/^  ushort padding6;$/;"	m	struct:taskstate
padding6	x86.h	/^  ushort padding6;$/;"	m	struct:trapframe
padding7	dist/mmu.h	/^  ushort padding7;$/;"	m	struct:taskstate
padding7	mmu.h	/^  ushort padding7;$/;"	m	struct:taskstate
padding8	dist/mmu.h	/^  ushort padding8;$/;"	m	struct:taskstate
padding8	mmu.h	/^  ushort padding8;$/;"	m	struct:taskstate
padding9	dist/mmu.h	/^  ushort padding9;$/;"	m	struct:taskstate
padding9	mmu.h	/^  ushort padding9;$/;"	m	struct:taskstate
paddr	dist/elf.h	/^  uint paddr;$/;"	m	struct:proghdr
paddr	elf.h	/^  uint paddr;$/;"	m	struct:proghdr
panic	console.c	/^panic(char *s)$/;"	f
panic	dist/console.c	/^panic(char *s)$/;"	f
panic	dist/sh.c	/^panic(char *s)$/;"	f
panic	sh.c	/^panic(char *s)$/;"	f
panicked	console.c	/^static int panicked = 0;$/;"	v	file:
panicked	dist/console.c	/^static int panicked = 0;$/;"	v	file:
panicked	kernel.asm	/^  panicked = 1; \/\/ freeze other CPU$/;"	d
parent	dist/proc.h	/^  struct proc *parent;         \/\/ Parent process$/;"	m	struct:proc	typeref:struct:proc::proc
parent	proc.h	/^  struct proc *parent;         \/\/ Parent process$/;"	m	struct:proc	typeref:struct:proc::proc
parseblock	dist/sh.c	/^parseblock(char **ps, char *es)$/;"	f
parseblock	sh.c	/^parseblock(char **ps, char *es)$/;"	f
parsecmd	dist/sh.c	/^parsecmd(char *s)$/;"	f
parsecmd	sh.c	/^parsecmd(char *s)$/;"	f
parseexec	dist/sh.c	/^parseexec(char **ps, char *es)$/;"	f
parseexec	sh.c	/^parseexec(char **ps, char *es)$/;"	f
parseline	dist/sh.c	/^parseline(char **ps, char *es)$/;"	f
parseline	sh.c	/^parseline(char **ps, char *es)$/;"	f
parsepipe	dist/sh.c	/^parsepipe(char **ps, char *es)$/;"	f
parsepipe	sh.c	/^parsepipe(char **ps, char *es)$/;"	f
parseredirs	dist/sh.c	/^parseredirs(struct cmd *cmd, char **ps, char *es)$/;"	f
parseredirs	sh.c	/^parseredirs(struct cmd *cmd, char **ps, char *es)$/;"	f
pattern	grep.asm	/^  pattern = argv[1];$/;"	d
pcs	dist/spinlock.h	/^  uint pcs[10];      \/\/ The call stack (an array of program counters)$/;"	m	struct:spinlock
pcs	spinlock.h	/^  uint pcs[10];      \/\/ The call stack (an array of program counters)$/;"	m	struct:spinlock
pde	kernel.asm	/^  pde = &pgdir[PDX(va)];$/;"	d
pde_t	dist/types.h	/^typedef uint pde_t;$/;"	t
pde_t	types.h	/^typedef uint pde_t;$/;"	t
peek	dist/sh.c	/^peek(char **ps, char *es, char *toks)$/;"	f
peek	sh.c	/^peek(char **ps, char *es, char *toks)$/;"	f
perm	dist/vm.c	/^  int perm;$/;"	m	struct:kmap	file:
perm	vm.c	/^  int perm;$/;"	m	struct:kmap	file:
pgdir	dist/proc.h	/^  pde_t* pgdir;                \/\/ Page table$/;"	m	struct:proc
pgdir	kernel.asm	/^  pgdir = 0;$/;"	d
pgdir	proc.h	/^  pde_t* pgdir;                \/\/ Page table$/;"	m	struct:proc
pgtab	kernel.asm	/^    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));$/;"	d
ph	bootblock.asm	/^  ph = (struct proghdr*)((uchar*)elf + elf->phoff);$/;"	d
phentsize	dist/elf.h	/^  ushort phentsize;$/;"	m	struct:elfhdr
phentsize	elf.h	/^  ushort phentsize;$/;"	m	struct:elfhdr
phnum	dist/elf.h	/^  ushort phnum;$/;"	m	struct:elfhdr
phnum	elf.h	/^  ushort phnum;$/;"	m	struct:elfhdr
phoff	dist/elf.h	/^  uint phoff;$/;"	m	struct:elfhdr
phoff	elf.h	/^  uint phoff;$/;"	m	struct:elfhdr
phys_end	dist/vm.c	/^  uint phys_end;$/;"	m	struct:kmap	file:
phys_end	vm.c	/^  uint phys_end;$/;"	m	struct:kmap	file:
phys_start	dist/vm.c	/^  uint phys_start;$/;"	m	struct:kmap	file:
phys_start	vm.c	/^  uint phys_start;$/;"	m	struct:kmap	file:
physaddr	dist/mp.h	/^  void *physaddr;               \/\/ phys addr of MP config table$/;"	m	struct:mp
physaddr	mp.h	/^  void *physaddr;               \/\/ phys addr of MP config table$/;"	m	struct:mp
picinit	dist/picirq.c	/^picinit(void)$/;"	f
picinit	picirq.c	/^picinit(void)$/;"	f
pid	dist/proc.h	/^  int pid;                     \/\/ Process ID$/;"	m	struct:proc
pid	dist/sleeplock.h	/^  int pid;           \/\/ Process holding lock$/;"	m	struct:sleeplock
pid	forktest.asm	/^    pid = fork();$/;"	d
pid	init.asm	/^    pid = fork();$/;"	d
pid	kernel.asm	/^        pid = p->pid;$/;"	d
pid	kernel.asm	/^  pid = np->pid;$/;"	d
pid	proc.h	/^  int pid;                     \/\/ Process ID$/;"	m	struct:proc
pid	sh.asm	/^  pid = fork();$/;"	d
pid	sleeplock.h	/^  int pid;           \/\/ Process holding lock$/;"	m	struct:sleeplock
pid	test1.asm	/^		pid = fork();$/;"	d
pid	test1.asm	/^		pid = getpid();$/;"	d
pid	test2.asm	/^	pid = fork();$/;"	d
pid	testcase1.asm	/^		pid = fork();$/;"	d
pid	testcase1.asm	/^		pid = getpid();$/;"	d
pid	testcase2.asm	/^	pid = fork();$/;"	d
pid	usertests.asm	/^    pid = fork();$/;"	d
pid	usertests.asm	/^  pid = fork();$/;"	d
pid1	usertests.asm	/^  pid1 = fork();$/;"	d
pid2	usertests.asm	/^  pid2 = fork();$/;"	d
pid3	usertests.asm	/^  pid3 = fork();$/;"	d
pinit	dist/proc.c	/^pinit(void)$/;"	f
pinit	proc.c	/^pinit(void)$/;"	f
pipe	dist/file.h	/^  struct pipe *pipe;$/;"	m	struct:file	typeref:struct:file::pipe
pipe	dist/pipe.c	/^struct pipe {$/;"	s	file:
pipe	file.h	/^  struct pipe *pipe;$/;"	m	struct:file	typeref:struct:file::pipe
pipe	pipe.c	/^struct pipe {$/;"	s	file:
pipe1	dist/usertests.c	/^pipe1(void)$/;"	f
pipe1	usertests.c	/^pipe1(void)$/;"	f
pipealloc	dist/pipe.c	/^pipealloc(struct file **f0, struct file **f1)$/;"	f
pipealloc	pipe.c	/^pipealloc(struct file **f0, struct file **f1)$/;"	f
pipeclose	dist/pipe.c	/^pipeclose(struct pipe *p, int writable)$/;"	f
pipeclose	pipe.c	/^pipeclose(struct pipe *p, int writable)$/;"	f
pipecmd	dist/sh.c	/^pipecmd(struct cmd *left, struct cmd *right)$/;"	f
pipecmd	dist/sh.c	/^struct pipecmd {$/;"	s	file:
pipecmd	sh.c	/^pipecmd(struct cmd *left, struct cmd *right)$/;"	f
pipecmd	sh.c	/^struct pipecmd {$/;"	s	file:
piperead	dist/pipe.c	/^piperead(struct pipe *p, char *addr, int n)$/;"	f
piperead	pipe.c	/^piperead(struct pipe *p, char *addr, int n)$/;"	f
pipewrite	dist/pipe.c	/^pipewrite(struct pipe *p, char *addr, int n)$/;"	f
pipewrite	pipe.c	/^pipewrite(struct pipe *p, char *addr, int n)$/;"	f
popcli	dist/spinlock.c	/^popcli(void)$/;"	f
popcli	spinlock.c	/^popcli(void)$/;"	f
pos	kernel.asm	/^  pos = inb(CRTPORT+1) << 8;$/;"	d
ppid	usertests.asm	/^    ppid = getpid();$/;"	d
ppid	usertests.asm	/^  ppid = getpid();$/;"	d
preempt	dist/usertests.c	/^preempt(void)$/;"	f
preempt	usertests.c	/^preempt(void)$/;"	f
prev	buf.h	/^  struct buf *prev; \/\/ LRU cache list$/;"	m	struct:buf	typeref:struct:buf::buf
prev	dist/buf.h	/^  struct buf *prev; \/\/ LRU cache list$/;"	m	struct:buf	typeref:struct:buf::buf
printf	dist/forktest.c	/^printf(int fd, const char *s, ...)$/;"	f
printf	dist/printf.c	/^printf(int fd, const char *fmt, ...)$/;"	f
printf	forktest.c	/^printf(int fd, const char *s, ...)$/;"	f
printf	printf.c	/^printf(int fd, const char *fmt, ...)$/;"	f
printint	console.c	/^printint(int xx, int base, int sign)$/;"	f	file:
printint	dist/console.c	/^printint(int xx, int base, int sign)$/;"	f	file:
printint	dist/printf.c	/^printint(int fd, int xx, int base, int sgn)$/;"	f	file:
printint	printf.c	/^printint(int fd, int xx, int base, int sgn)$/;"	f	file:
priority	dist/proc.h	/^  int priority;$/;"	m	struct:proc
priority	proc.h	/^  int priority;$/;"	m	struct:proc
proc	dist/proc.c	/^  struct proc proc[NPROC];$/;"	m	struct:__anon16	typeref:struct:__anon16::proc	file:
proc	dist/proc.h	/^  struct proc *proc;           \/\/ The process running on this cpu or null$/;"	m	struct:cpu	typeref:struct:cpu::proc
proc	dist/proc.h	/^struct proc {$/;"	s
proc	proc.c	/^  struct proc proc[NPROC];$/;"	m	struct:__anon8	typeref:struct:__anon8::proc	file:
proc	proc.h	/^  struct proc *proc;           \/\/ The process running on this cpu or null$/;"	m	struct:cpu	typeref:struct:cpu::proc
proc	proc.h	/^struct proc {$/;"	s
procdump	dist/proc.c	/^procdump(void)$/;"	f
procdump	proc.c	/^procdump(void)$/;"	f
procstate	dist/proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	g
procstate	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	g
product	dist/mp.h	/^  uchar product[20];            \/\/ product id$/;"	m	struct:mpconf
product	mp.h	/^  uchar product[20];            \/\/ product id$/;"	m	struct:mpconf
proghdr	dist/elf.h	/^struct proghdr {$/;"	s
proghdr	elf.h	/^struct proghdr {$/;"	s
ps	dist/proc.c	/^void ps(){$/;"	f
ps	proc.c	/^void ps(){$/;"	f
ptable	dist/proc.c	/^} ptable;$/;"	v	typeref:struct:__anon16
ptable	proc.c	/^} ptable;$/;"	v	typeref:struct:__anon8
pte	kernel.asm	/^    pte = walkpgdir(pgdir, (char*)a, 0);$/;"	d
pte	kernel.asm	/^  pte = walkpgdir(pgdir, uva, 0);$/;"	d
pte_t	dist/mmu.h	/^typedef uint pte_t;$/;"	t
pte_t	mmu.h	/^typedef uint pte_t;$/;"	t
ptr	dist/umalloc.c	/^    union header *ptr;$/;"	m	struct:header::__anon15	typeref:union:header::__anon15::header	file:
ptr	umalloc.c	/^    union header *ptr;$/;"	m	struct:header::__anon7	typeref:union:header::__anon7::header	file:
pushcli	dist/spinlock.c	/^pushcli(void)$/;"	f
pushcli	spinlock.c	/^pushcli(void)$/;"	f
putc	dist/printf.c	/^putc(int fd, char c)$/;"	f	file:
putc	printf.c	/^putc(int fd, char c)$/;"	f	file:
qnext	buf.h	/^  struct buf *qnext; \/\/ disk queue$/;"	m	struct:buf	typeref:struct:buf::buf
qnext	dist/buf.h	/^  struct buf *qnext; \/\/ disk queue$/;"	m	struct:buf	typeref:struct:buf::buf
r	cat.asm	/^  r = fstat(fd, st);$/;"	d
r	console.c	/^  uint r;  \/\/ Read index$/;"	m	struct:__anon6	file:
r	dist/console.c	/^  uint r;  \/\/ Read index$/;"	m	struct:__anon14	file:
r	echo.asm	/^  r = fstat(fd, st);$/;"	d
r	forktest.asm	/^  r = fstat(fd, st);$/;"	d
r	getnice.asm	/^  r = fstat(fd, st);$/;"	d
r	grep.asm	/^  r = fstat(fd, st);$/;"	d
r	init.asm	/^  r = fstat(fd, st);$/;"	d
r	kernel.asm	/^  r = (struct run*)v;$/;"	d
r	kernel.asm	/^  r = kmem.freelist;$/;"	d
r	kernel.asm	/^  r = lk->locked && (lk->pid == myproc()->pid);$/;"	d
r	kernel.asm	/^  r = lock->locked && lock->cpu == mycpu();$/;"	d
r	kill.asm	/^  r = fstat(fd, st);$/;"	d
r	ln.asm	/^  r = fstat(fd, st);$/;"	d
r	ls.asm	/^  r = fstat(fd, st);$/;"	d
r	mkdir.asm	/^  r = fstat(fd, st);$/;"	d
r	ps.asm	/^  r = fstat(fd, st);$/;"	d
r	rm.asm	/^  r = fstat(fd, st);$/;"	d
r	setnice.asm	/^  r = fstat(fd, st);$/;"	d
r	sh.asm	/^  r = fstat(fd, st);$/;"	d
r	stressfs.asm	/^  r = fstat(fd, st);$/;"	d
r	swaptest.asm	/^  r = fstat(fd, st);$/;"	d
r	test1.asm	/^  r = fstat(fd, st);$/;"	d
r	test2.asm	/^  r = fstat(fd, st);$/;"	d
r	testcase1.asm	/^  r = fstat(fd, st);$/;"	d
r	testcase2.asm	/^  r = fstat(fd, st);$/;"	d
r	usertests.asm	/^  r = fstat(fd, st);$/;"	d
r	wc.asm	/^  r = fstat(fd, st);$/;"	d
r	zombie.asm	/^  r = fstat(fd, st);$/;"	d
rand	dist/usertests.c	/^rand()$/;"	f
rand	usertests.c	/^rand()$/;"	f
randstate	dist/usertests.c	/^unsigned long randstate = 1;$/;"	v
randstate	usertests.asm	/^  randstate = randstate * 1664525 + 1013904223;$/;"	d
randstate	usertests.c	/^unsigned long randstate = 1;$/;"	v
rcr2	dist/x86.h	/^rcr2(void)$/;"	f
rcr2	x86.h	/^rcr2(void)$/;"	f
read	dist/file.h	/^  int (*read)(struct inode*, char*, int);$/;"	m	struct:devsw
read	file.h	/^  int (*read)(struct inode*, char*, int);$/;"	m	struct:devsw
read_head	dist/log.c	/^read_head(void)$/;"	f	file:
read_head	log.c	/^read_head(void)$/;"	f	file:
readable	dist/file.h	/^  char readable;$/;"	m	struct:file
readable	file.h	/^  char readable;$/;"	m	struct:file
readeflags	dist/x86.h	/^readeflags(void)$/;"	f
readeflags	x86.h	/^readeflags(void)$/;"	f
readi	dist/fs.c	/^readi(struct inode *ip, char *dst, uint off, uint n)$/;"	f
readi	fs.c	/^readi(struct inode *ip, char *dst, uint off, uint n)$/;"	f
readopen	dist/pipe.c	/^  int readopen;   \/\/ read fd is still open$/;"	m	struct:pipe	file:
readopen	pipe.c	/^  int readopen;   \/\/ read fd is still open$/;"	m	struct:pipe	file:
readsb	dist/fs.c	/^readsb(int dev, struct superblock *sb)$/;"	f
readsb	fs.c	/^readsb(int dev, struct superblock *sb)$/;"	f
readsect	bootmain.c	/^readsect(void *dst, uint offset)$/;"	f
readsect	dist/bootmain.c	/^readsect(void *dst, uint offset)$/;"	f
readseg	bootmain.c	/^readseg(uchar* pa, uint count, uint offset)$/;"	f
readseg	dist/bootmain.c	/^readseg(uchar* pa, uint count, uint offset)$/;"	f
recover_from_log	dist/log.c	/^recover_from_log(void)$/;"	f	file:
recover_from_log	log.c	/^recover_from_log(void)$/;"	f	file:
redircmd	dist/sh.c	/^redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)$/;"	f
redircmd	dist/sh.c	/^struct redircmd {$/;"	s	file:
redircmd	sh.c	/^redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)$/;"	f
redircmd	sh.c	/^struct redircmd {$/;"	s	file:
ref	dist/file.h	/^  int ref;            \/\/ Reference count$/;"	m	struct:inode
ref	dist/file.h	/^  int ref; \/\/ reference count$/;"	m	struct:file
ref	file.h	/^  int ref;            \/\/ Reference count$/;"	m	struct:inode
ref	file.h	/^  int ref; \/\/ reference count$/;"	m	struct:file
refcnt	buf.h	/^  uint refcnt;$/;"	m	struct:buf
refcnt	dist/buf.h	/^  uint refcnt;$/;"	m	struct:buf
reg	dist/ioapic.c	/^  uint reg;$/;"	m	struct:ioapic	file:
reg	ioapic.c	/^  uint reg;$/;"	m	struct:ioapic	file:
release	dist/spinlock.c	/^release(struct spinlock *lk)$/;"	f
release	spinlock.c	/^release(struct spinlock *lk)$/;"	f
releasesleep	dist/sleeplock.c	/^releasesleep(struct sleeplock *lk)$/;"	f
releasesleep	sleeplock.c	/^releasesleep(struct sleeplock *lk)$/;"	f
reserved	dist/mp.h	/^  uchar reserved;$/;"	m	struct:mpconf
reserved	dist/mp.h	/^  uchar reserved[3];$/;"	m	struct:mp
reserved	dist/mp.h	/^  uchar reserved[8];$/;"	m	struct:mpproc
reserved	mp.h	/^  uchar reserved;$/;"	m	struct:mpconf
reserved	mp.h	/^  uchar reserved[3];$/;"	m	struct:mp
reserved	mp.h	/^  uchar reserved[8];$/;"	m	struct:mpproc
ret	sh.asm	/^      ret = '+';$/;"	d
ret	sh.asm	/^    ret = 'a';$/;"	d
ret	sh.asm	/^    ret = parseredirs(ret, ps, es);$/;"	d
ret	sh.asm	/^  ret = *s;$/;"	d
ret	sh.asm	/^  ret = execcmd();$/;"	d
ret	sh.asm	/^  ret = parseredirs(ret, ps, es);$/;"	d
return	kernel.asm	/^  return d;$/;"	d
right	dist/sh.c	/^  struct cmd *right;$/;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:
right	dist/sh.c	/^  struct cmd *right;$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:
right	sh.c	/^  struct cmd *right;$/;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:
right	sh.c	/^  struct cmd *right;$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:
rinode	dist/mkfs.c	/^rinode(uint inum, struct dinode *ip)$/;"	f
rinode	mkfs.c	/^rinode(uint inum, struct dinode *ip)$/;"	f
rmdot	dist/usertests.c	/^rmdot(void)$/;"	f
rmdot	usertests.c	/^rmdot(void)$/;"	f
rsect	dist/mkfs.c	/^rsect(uint sec, void *buf)$/;"	f
rsect	mkfs.c	/^rsect(uint sec, void *buf)$/;"	f
rsv1	dist/mmu.h	/^  uint rsv1 : 1;       \/\/ Reserved$/;"	m	struct:segdesc
rsv1	dist/mmu.h	/^  uint rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:gatedesc
rsv1	mmu.h	/^  uint rsv1 : 1;       \/\/ Reserved$/;"	m	struct:segdesc
rsv1	mmu.h	/^  uint rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:gatedesc
rtcdate	date.h	/^struct rtcdate {$/;"	s
rtcdate	dist/date.h	/^struct rtcdate {$/;"	s
run	dist/kalloc.c	/^struct run {$/;"	s	file:
run	kalloc.c	/^struct run {$/;"	s	file:
runcmd	dist/sh.c	/^runcmd(struct cmd *cmd)$/;"	f
runcmd	sh.c	/^runcmd(struct cmd *cmd)$/;"	f
runtime	dist/proc.h	/^  uint runtime;$/;"	m	struct:proc
runtime	proc.h	/^  uint runtime;$/;"	m	struct:proc
s	cat.asm	/^          s = "(null)";$/;"	d
s	cat.asm	/^        s = (char*)*ap;$/;"	d
s	dist/mmu.h	/^  uint s : 1;           \/\/ must be 0 (system)$/;"	m	struct:gatedesc
s	dist/mmu.h	/^  uint s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:segdesc
s	dist/umalloc.c	/^  } s;$/;"	m	union:header	typeref:struct:header::__anon15	file:
s	echo.asm	/^          s = "(null)";$/;"	d
s	echo.asm	/^        s = (char*)*ap;$/;"	d
s	getnice.asm	/^          s = "(null)";$/;"	d
s	getnice.asm	/^        s = (char*)*ap;$/;"	d
s	grep.asm	/^          s = "(null)";$/;"	d
s	grep.asm	/^        s = (char*)*ap;$/;"	d
s	init.asm	/^          s = "(null)";$/;"	d
s	init.asm	/^        s = (char*)*ap;$/;"	d
s	kernel.asm	/^        s = "(null)";$/;"	d
s	kill.asm	/^          s = "(null)";$/;"	d
s	kill.asm	/^        s = (char*)*ap;$/;"	d
s	ln.asm	/^          s = "(null)";$/;"	d
s	ln.asm	/^        s = (char*)*ap;$/;"	d
s	ls.asm	/^          s = "(null)";$/;"	d
s	ls.asm	/^        s = (char*)*ap;$/;"	d
s	mkdir.asm	/^          s = "(null)";$/;"	d
s	mkdir.asm	/^        s = (char*)*ap;$/;"	d
s	mmu.h	/^  uint s : 1;           \/\/ must be 0 (system)$/;"	m	struct:gatedesc
s	mmu.h	/^  uint s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:segdesc
s	ps.asm	/^          s = "(null)";$/;"	d
s	ps.asm	/^        s = (char*)*ap;$/;"	d
s	rm.asm	/^          s = "(null)";$/;"	d
s	rm.asm	/^        s = (char*)*ap;$/;"	d
s	setnice.asm	/^          s = "(null)";$/;"	d
s	setnice.asm	/^        s = (char*)*ap;$/;"	d
s	sh.asm	/^          s = "(null)";$/;"	d
s	sh.asm	/^        s = (char*)*ap;$/;"	d
s	sh.asm	/^  s = *ps;$/;"	d
s	stressfs.asm	/^          s = "(null)";$/;"	d
s	stressfs.asm	/^        s = (char*)*ap;$/;"	d
s	swaptest.asm	/^          s = "(null)";$/;"	d
s	swaptest.asm	/^        s = (char*)*ap;$/;"	d
s	test1.asm	/^          s = "(null)";$/;"	d
s	test1.asm	/^        s = (char*)*ap;$/;"	d
s	test2.asm	/^          s = "(null)";$/;"	d
s	test2.asm	/^        s = (char*)*ap;$/;"	d
s	testcase1.asm	/^          s = "(null)";$/;"	d
s	testcase1.asm	/^        s = (char*)*ap;$/;"	d
s	testcase2.asm	/^          s = "(null)";$/;"	d
s	testcase2.asm	/^        s = (char*)*ap;$/;"	d
s	umalloc.c	/^  } s;$/;"	m	union:header	typeref:struct:header::__anon7	file:
s	usertests.asm	/^          s = "(null)";$/;"	d
s	usertests.asm	/^        s = (char*)*ap;$/;"	d
s	wc.asm	/^          s = "(null)";$/;"	d
s	wc.asm	/^        s = (char*)*ap;$/;"	d
s	zombie.asm	/^          s = "(null)";$/;"	d
s	zombie.asm	/^        s = (char*)*ap;$/;"	d
safestrcpy	dist/string.c	/^safestrcpy(char *s, const char *t, int n)$/;"	f
safestrcpy	string.c	/^safestrcpy(char *s, const char *t, int n)$/;"	f
sb	dist/fs.c	/^struct superblock sb; $/;"	v	typeref:struct:superblock
sb	dist/mkfs.c	/^struct superblock sb;$/;"	v	typeref:struct:superblock
sb	fs.c	/^struct superblock sb; $/;"	v	typeref:struct:superblock
sb	kernel.asm	/^  sb = cmos_read(CMOS_STATB);$/;"	d
sb	mkfs.c	/^struct superblock sb;$/;"	v	typeref:struct:superblock
sbrktest	dist/usertests.c	/^sbrktest(void)$/;"	f
sbrktest	usertests.c	/^sbrktest(void)$/;"	f
sched	dist/proc.c	/^sched(void)$/;"	f
sched	proc.c	/^sched(void)$/;"	f
scheduler	dist/proc.c	/^scheduler(void)$/;"	f
scheduler	dist/proc.h	/^  struct context *scheduler;   \/\/ swtch() here to enter scheduler$/;"	m	struct:cpu	typeref:struct:cpu::context
scheduler	proc.c	/^scheduler(void)$/;"	f
scheduler	proc.h	/^  struct context *scheduler;   \/\/ swtch() here to enter scheduler$/;"	m	struct:cpu	typeref:struct:cpu::context
second	date.h	/^  uint second;$/;"	m	struct:rtcdate
second	dist/date.h	/^  uint second;$/;"	m	struct:rtcdate
segdesc	dist/mmu.h	/^struct segdesc {$/;"	s
segdesc	mmu.h	/^struct segdesc {$/;"	s
seginit	dist/vm.c	/^seginit(void)$/;"	f
seginit	vm.c	/^seginit(void)$/;"	f
seq	usertests.asm	/^  seq = 0;$/;"	d
setnice	dist/proc.c	/^int setnice(int pid, int nice){$/;"	f
setnice	proc.c	/^int setnice(int pid, int nice){$/;"	f
setupkvm	dist/vm.c	/^setupkvm(void)$/;"	f
setupkvm	vm.c	/^setupkvm(void)$/;"	f
sharedfd	dist/usertests.c	/^sharedfd(void)$/;"	f
sharedfd	usertests.c	/^sharedfd(void)$/;"	f
shentsize	dist/elf.h	/^  ushort shentsize;$/;"	m	struct:elfhdr
shentsize	elf.h	/^  ushort shentsize;$/;"	m	struct:elfhdr
shiftcode	dist/kbd.h	/^static uchar shiftcode[256] =$/;"	v
shiftcode	kbd.h	/^static uchar shiftcode[256] =$/;"	v
shiftmap	dist/kbd.h	/^static uchar shiftmap[256] =$/;"	v
shiftmap	kbd.h	/^static uchar shiftmap[256] =$/;"	v
shnum	dist/elf.h	/^  ushort shnum;$/;"	m	struct:elfhdr
shnum	elf.h	/^  ushort shnum;$/;"	m	struct:elfhdr
shoff	dist/elf.h	/^  uint shoff;$/;"	m	struct:elfhdr
shoff	elf.h	/^  uint shoff;$/;"	m	struct:elfhdr
shstrndx	dist/elf.h	/^  ushort shstrndx;$/;"	m	struct:elfhdr
shstrndx	elf.h	/^  ushort shstrndx;$/;"	m	struct:elfhdr
signature	dist/mp.h	/^  uchar signature[4];           \/\/ "PCMP"$/;"	m	struct:mpconf
signature	dist/mp.h	/^  uchar signature[4];           \/\/ "_MP_"$/;"	m	struct:mp
signature	dist/mp.h	/^  uchar signature[4];           \/\/ CPU signature$/;"	m	struct:mpproc
signature	mp.h	/^  uchar signature[4];           \/\/ "PCMP"$/;"	m	struct:mpconf
signature	mp.h	/^  uchar signature[4];           \/\/ "_MP_"$/;"	m	struct:mp
signature	mp.h	/^  uchar signature[4];           \/\/ CPU signature$/;"	m	struct:mpproc
size	dist/file.h	/^  uint size;$/;"	m	struct:inode
size	dist/fs.h	/^  uint size;            \/\/ Size of file (bytes)$/;"	m	struct:dinode
size	dist/fs.h	/^  uint size;         \/\/ Size of file system image (blocks)$/;"	m	struct:superblock
size	dist/log.c	/^  int size;$/;"	m	struct:log	file:
size	dist/stat.h	/^  uint size;   \/\/ Size of file in bytes$/;"	m	struct:stat
size	dist/umalloc.c	/^    uint size;$/;"	m	struct:header::__anon15	file:
size	file.h	/^  uint size;$/;"	m	struct:inode
size	fs.h	/^  uint size;            \/\/ Size of file (bytes)$/;"	m	struct:dinode
size	fs.h	/^  uint size;         \/\/ Size of file system image (blocks)$/;"	m	struct:superblock
size	log.c	/^  int size;$/;"	m	struct:log	file:
size	stat.h	/^  uint size;   \/\/ Size of file in bytes$/;"	m	struct:stat
size	umalloc.c	/^    uint size;$/;"	m	struct:header::__anon7	file:
skipelem	dist/fs.c	/^skipelem(char *path, char *name)$/;"	f	file:
skipelem	fs.c	/^skipelem(char *path, char *name)$/;"	f	file:
sleep	dist/proc.c	/^sleep(void *chan, struct spinlock *lk)$/;"	f
sleep	proc.c	/^sleep(void *chan, struct spinlock *lk)$/;"	f
sleeplock	dist/sleeplock.h	/^struct sleeplock {$/;"	s
sleeplock	sleeplock.h	/^struct sleeplock {$/;"	s
sp	kernel.asm	/^    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;$/;"	d
sp	kernel.asm	/^  sp = p->kstack + KSTACKSIZE;$/;"	d
specrev	dist/mp.h	/^  uchar specrev;                \/\/ [14]$/;"	m	struct:mp
specrev	mp.h	/^  uchar specrev;                \/\/ [14]$/;"	m	struct:mp
spin	bootasm.S	/^spin:$/;"	l
spin	bootblock.asm	/^spin:$/;"	l
spin	dist/bootasm.S	/^spin:$/;"	l
spin	dist/entryother.S	/^spin:$/;"	l
spin	entryother.S	/^spin:$/;"	l
spin	entryother.asm	/^spin:$/;"	l
spinlock	dist/spinlock.h	/^struct spinlock {$/;"	s
spinlock	spinlock.h	/^struct spinlock {$/;"	s
src	cat.asm	/^  src = vsrc;$/;"	d
src	echo.asm	/^  src = vsrc;$/;"	d
src	forktest.asm	/^  src = vsrc;$/;"	d
src	getnice.asm	/^  src = vsrc;$/;"	d
src	grep.asm	/^  src = vsrc;$/;"	d
src	init.asm	/^  src = vsrc;$/;"	d
src	kill.asm	/^  src = vsrc;$/;"	d
src	ln.asm	/^  src = vsrc;$/;"	d
src	ls.asm	/^  src = vsrc;$/;"	d
src	mkdir.asm	/^  src = vsrc;$/;"	d
src	ps.asm	/^  src = vsrc;$/;"	d
src	rm.asm	/^  src = vsrc;$/;"	d
src	setnice.asm	/^  src = vsrc;$/;"	d
src	sh.asm	/^  src = vsrc;$/;"	d
src	stressfs.asm	/^  src = vsrc;$/;"	d
src	swaptest.asm	/^  src = vsrc;$/;"	d
src	test1.asm	/^  src = vsrc;$/;"	d
src	test2.asm	/^  src = vsrc;$/;"	d
src	testcase1.asm	/^  src = vsrc;$/;"	d
src	testcase2.asm	/^  src = vsrc;$/;"	d
src	usertests.asm	/^  src = vsrc;$/;"	d
src	wc.asm	/^  src = vsrc;$/;"	d
src	zombie.asm	/^  src = vsrc;$/;"	d
ss	dist/mmu.h	/^  ushort ss;$/;"	m	struct:taskstate
ss	dist/x86.h	/^  ushort ss;$/;"	m	struct:trapframe
ss	mmu.h	/^  ushort ss;$/;"	m	struct:taskstate
ss	x86.h	/^  ushort ss;$/;"	m	struct:trapframe
ss0	dist/mmu.h	/^  ushort ss0;        \/\/   after an increase in privilege level$/;"	m	struct:taskstate
ss0	mmu.h	/^  ushort ss0;        \/\/   after an increase in privilege level$/;"	m	struct:taskstate
ss1	dist/mmu.h	/^  ushort ss1;$/;"	m	struct:taskstate
ss1	mmu.h	/^  ushort ss1;$/;"	m	struct:taskstate
ss2	dist/mmu.h	/^  ushort ss2;$/;"	m	struct:taskstate
ss2	mmu.h	/^  ushort ss2;$/;"	m	struct:taskstate
st	kernel.asm	/^  st = inb(KBSTATP);$/;"	d
stack	kernel.asm	/^    stack = kalloc();$/;"	d
start	bootasm.S	/^start:$/;"	l
start	bootblock.asm	/^start:$/;"	l
start	dist/bootasm.S	/^start:$/;"	l
start	dist/entryother.S	/^start:$/;"	l
start	dist/initcode.S	/^start:$/;"	l
start	dist/log.c	/^  int start;$/;"	m	struct:log	file:
start	entryother.S	/^start:$/;"	l
start	entryother.asm	/^start:$/;"	l
start	initcode.S	/^start:$/;"	l
start	initcode.asm	/^start:$/;"	l
start	log.c	/^  int start;$/;"	m	struct:log	file:
start32	bootasm.S	/^start32:$/;"	l
start32	bootblock.asm	/^start32:$/;"	l
start32	dist/bootasm.S	/^start32:$/;"	l
start32	dist/entryother.S	/^start32:$/;"	l
start32	entryother.S	/^start32:$/;"	l
start32	entryother.asm	/^start32:$/;"	l
started	dist/proc.h	/^  volatile uint started;       \/\/ Has the CPU started?$/;"	m	struct:cpu
started	proc.h	/^  volatile uint started;       \/\/ Has the CPU started?$/;"	m	struct:cpu
startothers	dist/main.c	/^startothers(void)$/;"	f	file:
startothers	main.c	/^startothers(void)$/;"	f	file:
starttime	dist/proc.h	/^  uint starttime;			\/\/ Process creation time$/;"	m	struct:proc
starttime	proc.h	/^  uint starttime;			\/\/ Process creation time$/;"	m	struct:proc
stat	dist/mkfs.c	8;"	d	file:
stat	dist/stat.h	/^struct stat {$/;"	s
stat	dist/ulib.c	/^stat(const char *n, struct stat *st)$/;"	f
stat	mkfs.c	8;"	d	file:
stat	stat.h	/^struct stat {$/;"	s
stat	ulib.c	/^stat(const char *n, struct stat *st)$/;"	f
state	cat.asm	/^        state = '%';$/;"	d
state	cat.asm	/^      state = 0;$/;"	d
state	cat.asm	/^  state = 0;$/;"	d
state	dist/proc.h	/^  enum procstate state;        \/\/ Process state$/;"	m	struct:proc	typeref:enum:proc::procstate
state	echo.asm	/^        state = '%';$/;"	d
state	echo.asm	/^      state = 0;$/;"	d
state	echo.asm	/^  state = 0;$/;"	d
state	getnice.asm	/^        state = '%';$/;"	d
state	getnice.asm	/^      state = 0;$/;"	d
state	getnice.asm	/^  state = 0;$/;"	d
state	grep.asm	/^        state = '%';$/;"	d
state	grep.asm	/^      state = 0;$/;"	d
state	grep.asm	/^  state = 0;$/;"	d
state	init.asm	/^        state = '%';$/;"	d
state	init.asm	/^      state = 0;$/;"	d
state	init.asm	/^  state = 0;$/;"	d
state	kernel.asm	/^      state = "???";$/;"	d
state	kill.asm	/^        state = '%';$/;"	d
state	kill.asm	/^      state = 0;$/;"	d
state	kill.asm	/^  state = 0;$/;"	d
state	ln.asm	/^        state = '%';$/;"	d
state	ln.asm	/^      state = 0;$/;"	d
state	ln.asm	/^  state = 0;$/;"	d
state	ls.asm	/^        state = '%';$/;"	d
state	ls.asm	/^      state = 0;$/;"	d
state	ls.asm	/^  state = 0;$/;"	d
state	mkdir.asm	/^        state = '%';$/;"	d
state	mkdir.asm	/^      state = 0;$/;"	d
state	mkdir.asm	/^  state = 0;$/;"	d
state	proc.h	/^  enum procstate state;        \/\/ Process state$/;"	m	struct:proc	typeref:enum:proc::procstate
state	ps.asm	/^        state = '%';$/;"	d
state	ps.asm	/^      state = 0;$/;"	d
state	ps.asm	/^  state = 0;$/;"	d
state	rm.asm	/^        state = '%';$/;"	d
state	rm.asm	/^      state = 0;$/;"	d
state	rm.asm	/^  state = 0;$/;"	d
state	setnice.asm	/^        state = '%';$/;"	d
state	setnice.asm	/^      state = 0;$/;"	d
state	setnice.asm	/^  state = 0;$/;"	d
state	sh.asm	/^        state = '%';$/;"	d
state	sh.asm	/^      state = 0;$/;"	d
state	sh.asm	/^  state = 0;$/;"	d
state	stressfs.asm	/^        state = '%';$/;"	d
state	stressfs.asm	/^      state = 0;$/;"	d
state	stressfs.asm	/^  state = 0;$/;"	d
state	swaptest.asm	/^        state = '%';$/;"	d
state	swaptest.asm	/^      state = 0;$/;"	d
state	swaptest.asm	/^  state = 0;$/;"	d
state	test1.asm	/^        state = '%';$/;"	d
state	test1.asm	/^      state = 0;$/;"	d
state	test1.asm	/^  state = 0;$/;"	d
state	test2.asm	/^        state = '%';$/;"	d
state	test2.asm	/^      state = 0;$/;"	d
state	test2.asm	/^  state = 0;$/;"	d
state	testcase1.asm	/^        state = '%';$/;"	d
state	testcase1.asm	/^      state = 0;$/;"	d
state	testcase1.asm	/^  state = 0;$/;"	d
state	testcase2.asm	/^        state = '%';$/;"	d
state	testcase2.asm	/^      state = 0;$/;"	d
state	testcase2.asm	/^  state = 0;$/;"	d
state	usertests.asm	/^        state = '%';$/;"	d
state	usertests.asm	/^      state = 0;$/;"	d
state	usertests.asm	/^  state = 0;$/;"	d
state	wc.asm	/^        state = '%';$/;"	d
state	wc.asm	/^      state = 0;$/;"	d
state	wc.asm	/^  state = 0;$/;"	d
state	zombie.asm	/^        state = '%';$/;"	d
state	zombie.asm	/^      state = 0;$/;"	d
state	zombie.asm	/^  state = 0;$/;"	d
stati	dist/fs.c	/^stati(struct inode *ip, struct stat *st)$/;"	f
stati	fs.c	/^stati(struct inode *ip, struct stat *st)$/;"	f
static	bootblock.asm	/^static inline uchar$/;"	l
static	bootblock.asm	/^static inline void$/;"	l
static	cat.asm	/^static Header *freep;$/;"	l
static	cat.asm	/^static Header base;$/;"	l
static	cat.asm	/^static inline void$/;"	l
static	cat.asm	/^static void$/;"	l
static	echo.asm	/^static Header *freep;$/;"	l
static	echo.asm	/^static Header base;$/;"	l
static	echo.asm	/^static inline void$/;"	l
static	echo.asm	/^static void$/;"	l
static	forktest.asm	/^static inline void$/;"	l
static	getnice.asm	/^static Header *freep;$/;"	l
static	getnice.asm	/^static Header base;$/;"	l
static	getnice.asm	/^static inline void$/;"	l
static	getnice.asm	/^static void$/;"	l
static	grep.asm	/^static Header *freep;$/;"	l
static	grep.asm	/^static Header base;$/;"	l
static	grep.asm	/^static inline void$/;"	l
static	grep.asm	/^static void$/;"	l
static	init.asm	/^static Header *freep;$/;"	l
static	init.asm	/^static Header base;$/;"	l
static	init.asm	/^static inline void$/;"	l
static	init.asm	/^static void$/;"	l
static	kernel.asm	/^static inline uint$/;"	l
static	kernel.asm	/^static inline void$/;"	l
static	kernel.asm	/^static int$/;"	l
static	kernel.asm	/^static pte_t *$/;"	l
static	kernel.asm	/^static struct inode*$/;"	t
static	kernel.asm	/^static struct mp*$/;"	t
static	kernel.asm	/^static struct proc*$/;"	t
static	kernel.asm	/^static uint$/;"	l
static	kernel.asm	/^static void$/;"	l
static	kill.asm	/^static Header *freep;$/;"	l
static	kill.asm	/^static Header base;$/;"	l
static	kill.asm	/^static inline void$/;"	l
static	kill.asm	/^static void$/;"	l
static	ln.asm	/^static Header *freep;$/;"	l
static	ln.asm	/^static Header base;$/;"	l
static	ln.asm	/^static inline void$/;"	l
static	ln.asm	/^static void$/;"	l
static	ls.asm	/^static Header *freep;$/;"	l
static	ls.asm	/^static Header base;$/;"	l
static	ls.asm	/^static inline void$/;"	l
static	ls.asm	/^static void$/;"	l
static	mkdir.asm	/^static Header *freep;$/;"	l
static	mkdir.asm	/^static Header base;$/;"	l
static	mkdir.asm	/^static inline void$/;"	l
static	mkdir.asm	/^static void$/;"	l
static	ps.asm	/^static Header *freep;$/;"	l
static	ps.asm	/^static Header base;$/;"	l
static	ps.asm	/^static inline void$/;"	l
static	ps.asm	/^static void$/;"	l
static	rm.asm	/^static Header *freep;$/;"	l
static	rm.asm	/^static Header base;$/;"	l
static	rm.asm	/^static inline void$/;"	l
static	rm.asm	/^static void$/;"	l
static	setnice.asm	/^static Header *freep;$/;"	l
static	setnice.asm	/^static Header base;$/;"	l
static	setnice.asm	/^static inline void$/;"	l
static	setnice.asm	/^static void$/;"	l
static	sh.asm	/^static Header *freep;$/;"	l
static	sh.asm	/^static Header base;$/;"	l
static	sh.asm	/^static inline void$/;"	l
static	sh.asm	/^static void$/;"	l
static	stressfs.asm	/^static Header *freep;$/;"	l
static	stressfs.asm	/^static Header base;$/;"	l
static	stressfs.asm	/^static inline void$/;"	l
static	stressfs.asm	/^static void$/;"	l
static	swaptest.asm	/^static Header *freep;$/;"	l
static	swaptest.asm	/^static Header base;$/;"	l
static	swaptest.asm	/^static inline void$/;"	l
static	swaptest.asm	/^static void$/;"	l
static	test1.asm	/^static Header *freep;$/;"	l
static	test1.asm	/^static Header base;$/;"	l
static	test1.asm	/^static inline void$/;"	l
static	test1.asm	/^static void$/;"	l
static	test2.asm	/^static Header *freep;$/;"	l
static	test2.asm	/^static Header base;$/;"	l
static	test2.asm	/^static inline void$/;"	l
static	test2.asm	/^static void$/;"	l
static	testcase1.asm	/^static Header *freep;$/;"	l
static	testcase1.asm	/^static Header base;$/;"	l
static	testcase1.asm	/^static inline void$/;"	l
static	testcase1.asm	/^static void$/;"	l
static	testcase2.asm	/^static Header *freep;$/;"	l
static	testcase2.asm	/^static Header base;$/;"	l
static	testcase2.asm	/^static inline void$/;"	l
static	testcase2.asm	/^static void$/;"	l
static	usertests.asm	/^static Header *freep;$/;"	l
static	usertests.asm	/^static Header base;$/;"	l
static	usertests.asm	/^static inline void$/;"	l
static	usertests.asm	/^static void$/;"	l
static	wc.asm	/^static Header *freep;$/;"	l
static	wc.asm	/^static Header base;$/;"	l
static	wc.asm	/^static inline void$/;"	l
static	wc.asm	/^static void$/;"	l
static	zombie.asm	/^static Header *freep;$/;"	l
static	zombie.asm	/^static Header base;$/;"	l
static	zombie.asm	/^static inline void$/;"	l
static	zombie.asm	/^static void$/;"	l
static_assert	dist/mkfs.c	15;"	d	file:
static_assert	mkfs.c	15;"	d	file:
stdout	dist/usertests.c	/^int stdout = 1;$/;"	v
stdout	usertests.c	/^int stdout = 1;$/;"	v
sti	dist/x86.h	/^sti(void)$/;"	f
sti	x86.h	/^sti(void)$/;"	f
stosb	dist/x86.h	/^stosb(void *addr, int data, int cnt)$/;"	f
stosb	x86.h	/^stosb(void *addr, int data, int cnt)$/;"	f
stosl	dist/x86.h	/^stosl(void *addr, int data, int cnt)$/;"	f
stosl	x86.h	/^stosl(void *addr, int data, int cnt)$/;"	f
strchr	dist/ulib.c	/^strchr(const char *s, char c)$/;"	f
strchr	ulib.c	/^strchr(const char *s, char c)$/;"	f
strcmp	dist/ulib.c	/^strcmp(const char *p, const char *q)$/;"	f
strcmp	ulib.c	/^strcmp(const char *p, const char *q)$/;"	f
strcpy	dist/ulib.c	/^strcpy(char *s, const char *t)$/;"	f
strcpy	ulib.c	/^strcpy(char *s, const char *t)$/;"	f
strlen	dist/string.c	/^strlen(const char *s)$/;"	f
strlen	dist/ulib.c	/^strlen(const char *s)$/;"	f
strlen	string.c	/^strlen(const char *s)$/;"	f
strlen	ulib.c	/^strlen(const char *s)$/;"	f
strncmp	dist/string.c	/^strncmp(const char *p, const char *q, uint n)$/;"	f
strncmp	string.c	/^strncmp(const char *p, const char *q, uint n)$/;"	f
strncpy	dist/string.c	/^strncpy(char *s, const char *t, int n)$/;"	f
strncpy	string.c	/^strncpy(char *s, const char *t, int n)$/;"	f
struct	kernel.asm	/^  struct proc *curproc = myproc();$/;"	l
struct	kernel.asm	/^  struct proc *p;$/;"	l
subdir	dist/usertests.c	/^subdir(void)$/;"	f
subdir	usertests.c	/^subdir(void)$/;"	f
sum	dist/mp.c	/^sum(uchar *addr, int len)$/;"	f	file:
sum	kernel.asm	/^  sum = 0;$/;"	d
sum	mp.c	/^sum(uchar *addr, int len)$/;"	f	file:
superblock	dist/fs.h	/^struct superblock {$/;"	s
superblock	fs.h	/^struct superblock {$/;"	s
swapread	dist/fs.c	/^void swapread(char* ptr, int blkno)$/;"	f
swapread	fs.c	/^void swapread(char* ptr, int blkno)$/;"	f
swapwrite	dist/fs.c	/^void swapwrite(char* ptr, int blkno)$/;"	f
swapwrite	fs.c	/^void swapwrite(char* ptr, int blkno)$/;"	f
switchkvm	dist/vm.c	/^switchkvm(void)$/;"	f
switchkvm	vm.c	/^switchkvm(void)$/;"	f
switchuvm	dist/vm.c	/^switchuvm(struct proc *p)$/;"	f
switchuvm	vm.c	/^switchuvm(struct proc *p)$/;"	f
swtch	dist/swtch.S	/^swtch:$/;"	l
swtch	swtch.S	/^swtch:$/;"	l
symbols	dist/sh.c	/^char symbols[] = "<|>&;()";$/;"	v
symbols	sh.c	/^char symbols[] = "<|>&;()";$/;"	v
sys_chdir	dist/sysfile.c	/^sys_chdir(void)$/;"	f
sys_chdir	sysfile.c	/^sys_chdir(void)$/;"	f
sys_close	dist/sysfile.c	/^sys_close(void)$/;"	f
sys_close	sysfile.c	/^sys_close(void)$/;"	f
sys_dup	dist/sysfile.c	/^sys_dup(void)$/;"	f
sys_dup	sysfile.c	/^sys_dup(void)$/;"	f
sys_exec	dist/sysfile.c	/^sys_exec(void)$/;"	f
sys_exec	sysfile.c	/^sys_exec(void)$/;"	f
sys_exit	dist/sysproc.c	/^sys_exit(void)$/;"	f
sys_exit	sysproc.c	/^sys_exit(void)$/;"	f
sys_fork	dist/sysproc.c	/^sys_fork(void)$/;"	f
sys_fork	sysproc.c	/^sys_fork(void)$/;"	f
sys_fstat	dist/sysfile.c	/^sys_fstat(void)$/;"	f
sys_fstat	sysfile.c	/^sys_fstat(void)$/;"	f
sys_getnice	dist/sysproc.c	/^int sys_getnice(void){$/;"	f
sys_getnice	sysproc.c	/^int sys_getnice(void){$/;"	f
sys_getpid	dist/sysproc.c	/^sys_getpid(void)$/;"	f
sys_getpid	sysproc.c	/^sys_getpid(void)$/;"	f
sys_kill	dist/sysproc.c	/^sys_kill(void)$/;"	f
sys_kill	sysproc.c	/^sys_kill(void)$/;"	f
sys_link	dist/sysfile.c	/^sys_link(void)$/;"	f
sys_link	sysfile.c	/^sys_link(void)$/;"	f
sys_mkdir	dist/sysfile.c	/^sys_mkdir(void)$/;"	f
sys_mkdir	sysfile.c	/^sys_mkdir(void)$/;"	f
sys_mknod	dist/sysfile.c	/^sys_mknod(void)$/;"	f
sys_mknod	sysfile.c	/^sys_mknod(void)$/;"	f
sys_open	dist/sysfile.c	/^sys_open(void)$/;"	f
sys_open	sysfile.c	/^sys_open(void)$/;"	f
sys_pipe	dist/sysfile.c	/^sys_pipe(void)$/;"	f
sys_pipe	sysfile.c	/^sys_pipe(void)$/;"	f
sys_ps	dist/sysproc.c	/^int sys_ps(void){$/;"	f
sys_ps	sysproc.c	/^int sys_ps(void){$/;"	f
sys_read	dist/sysfile.c	/^sys_read(void)$/;"	f
sys_read	sysfile.c	/^sys_read(void)$/;"	f
sys_sbrk	dist/sysproc.c	/^sys_sbrk(void)$/;"	f
sys_sbrk	sysproc.c	/^sys_sbrk(void)$/;"	f
sys_setnice	dist/sysproc.c	/^int sys_setnice(void){$/;"	f
sys_setnice	sysproc.c	/^int sys_setnice(void){$/;"	f
sys_sleep	dist/sysproc.c	/^sys_sleep(void)$/;"	f
sys_sleep	sysproc.c	/^sys_sleep(void)$/;"	f
sys_swapread	dist/sysfile.c	/^int sys_swapread(void)$/;"	f
sys_swapread	sysfile.c	/^int sys_swapread(void)$/;"	f
sys_swapwrite	dist/sysfile.c	/^int sys_swapwrite(void)$/;"	f
sys_swapwrite	sysfile.c	/^int sys_swapwrite(void)$/;"	f
sys_unlink	dist/sysfile.c	/^sys_unlink(void)$/;"	f
sys_unlink	sysfile.c	/^sys_unlink(void)$/;"	f
sys_uptime	dist/sysproc.c	/^sys_uptime(void)$/;"	f
sys_uptime	sysproc.c	/^sys_uptime(void)$/;"	f
sys_wait	dist/sysproc.c	/^sys_wait(void)$/;"	f
sys_wait	sysproc.c	/^sys_wait(void)$/;"	f
sys_write	dist/sysfile.c	/^sys_write(void)$/;"	f
sys_write	sysfile.c	/^sys_write(void)$/;"	f
sys_yield	dist/sysproc.c	/^int sys_yield(void){$/;"	f
sys_yield	sysproc.c	/^int sys_yield(void){$/;"	f
syscall	dist/syscall.c	/^syscall(void)$/;"	f
syscall	syscall.c	/^syscall(void)$/;"	f
syscalls	dist/syscall.c	/^static int (*syscalls[])(void) = {$/;"	v	file:
syscalls	syscall.c	/^static int (*syscalls[])(void) = {$/;"	v	file:
sz	dist/proc.h	/^  uint sz;                     \/\/ Size of process memory (bytes)$/;"	m	struct:proc
sz	kernel.asm	/^  sz = 0;$/;"	d
sz	kernel.asm	/^  sz = curproc->sz;$/;"	d
sz	proc.h	/^  uint sz;                     \/\/ Size of process memory (bytes)$/;"	m	struct:proc
t	dist/mmu.h	/^  ushort t;          \/\/ Trap on task switch$/;"	m	struct:taskstate
t	mmu.h	/^  ushort t;          \/\/ Trap on task switch$/;"	m	struct:taskstate
target	kernel.asm	/^  target = n;$/;"	d
taskstate	dist/mmu.h	/^struct taskstate {$/;"	s
taskstate	mmu.h	/^struct taskstate {$/;"	s
test_p1_1	dist/test1.c	/^void test_p1_1()$/;"	f
test_p1_1	test1.c	/^void test_p1_1()$/;"	f
test_p1_2	dist/test2.c	/^void test_p1_2()$/;"	f
test_p1_2	test2.c	/^void test_p1_2()$/;"	f
tf	dist/proc.h	/^  struct trapframe *tf;        \/\/ Trap frame for current syscall$/;"	m	struct:proc	typeref:struct:proc::trapframe
tf	proc.h	/^  struct trapframe *tf;        \/\/ Trap frame for current syscall$/;"	m	struct:proc	typeref:struct:proc::trapframe
tickcounter	dist/proc.h	/^  int tickcounter;$/;"	m	struct:proc
tickcounter	proc.h	/^  int tickcounter;$/;"	m	struct:proc
ticks	dist/trap.c	/^uint ticks;$/;"	v
ticks	trap.c	/^uint ticks;$/;"	v
ticks0	kernel.asm	/^  ticks0 = ticks;$/;"	d
tickslock	dist/trap.c	/^struct spinlock tickslock;$/;"	v	typeref:struct:spinlock
tickslock	trap.c	/^struct spinlock tickslock;$/;"	v	typeref:struct:spinlock
togglecode	dist/kbd.h	/^static uchar togglecode[256] =$/;"	v
togglecode	kbd.h	/^static uchar togglecode[256] =$/;"	v
tok	sh.asm	/^    tok = gettoken(ps, es, 0, 0);$/;"	d
total	usertests.asm	/^    total = 0;$/;"	d
total	usertests.asm	/^  total = 0;$/;"	d
trap	dist/trap.c	/^trap(struct trapframe *tf)$/;"	f
trap	trap.c	/^trap(struct trapframe *tf)$/;"	f
trapframe	dist/x86.h	/^struct trapframe {$/;"	s
trapframe	x86.h	/^struct trapframe {$/;"	s
trapno	dist/x86.h	/^  uint trapno;$/;"	m	struct:trapframe
trapno	x86.h	/^  uint trapno;$/;"	m	struct:trapframe
trapret	dist/trapasm.S	/^trapret:$/;"	l
trapret	trapasm.S	/^trapret:$/;"	l
ts	dist/proc.h	/^  struct taskstate ts;         \/\/ Used by x86 to find stack for interrupt$/;"	m	struct:cpu	typeref:struct:cpu::taskstate
ts	proc.h	/^  struct taskstate ts;         \/\/ Used by x86 to find stack for interrupt$/;"	m	struct:cpu	typeref:struct:cpu::taskstate
tvinit	dist/trap.c	/^tvinit(void)$/;"	f
tvinit	trap.c	/^tvinit(void)$/;"	f
type	dist/elf.h	/^  uint type;$/;"	m	struct:proghdr
type	dist/elf.h	/^  ushort type;$/;"	m	struct:elfhdr
type	dist/file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	m	struct:file	typeref:enum:file::__anon9
type	dist/file.h	/^  short type;         \/\/ copy of disk inode$/;"	m	struct:inode
type	dist/fs.h	/^  short type;           \/\/ File type$/;"	m	struct:dinode
type	dist/mmu.h	/^  uint type : 4;        \/\/ type(STS_{IG32,TG32})$/;"	m	struct:gatedesc
type	dist/mmu.h	/^  uint type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:segdesc
type	dist/mp.h	/^  uchar type;                   \/\/ MP system config type$/;"	m	struct:mp
type	dist/mp.h	/^  uchar type;                   \/\/ entry type (0)$/;"	m	struct:mpproc
type	dist/mp.h	/^  uchar type;                   \/\/ entry type (2)$/;"	m	struct:mpioapic
type	dist/sh.c	/^  int type;$/;"	m	struct:backcmd	file:
type	dist/sh.c	/^  int type;$/;"	m	struct:cmd	file:
type	dist/sh.c	/^  int type;$/;"	m	struct:execcmd	file:
type	dist/sh.c	/^  int type;$/;"	m	struct:listcmd	file:
type	dist/sh.c	/^  int type;$/;"	m	struct:pipecmd	file:
type	dist/sh.c	/^  int type;$/;"	m	struct:redircmd	file:
type	dist/stat.h	/^  short type;  \/\/ Type of file$/;"	m	struct:stat
type	elf.h	/^  uint type;$/;"	m	struct:proghdr
type	elf.h	/^  ushort type;$/;"	m	struct:elfhdr
type	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	m	struct:file	typeref:enum:file::__anon1
type	file.h	/^  short type;         \/\/ copy of disk inode$/;"	m	struct:inode
type	fs.h	/^  short type;           \/\/ File type$/;"	m	struct:dinode
type	mmu.h	/^  uint type : 4;        \/\/ type(STS_{IG32,TG32})$/;"	m	struct:gatedesc
type	mmu.h	/^  uint type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:segdesc
type	mp.h	/^  uchar type;                   \/\/ MP system config type$/;"	m	struct:mp
type	mp.h	/^  uchar type;                   \/\/ entry type (0)$/;"	m	struct:mpproc
type	mp.h	/^  uchar type;                   \/\/ entry type (2)$/;"	m	struct:mpioapic
type	sh.c	/^  int type;$/;"	m	struct:backcmd	file:
type	sh.c	/^  int type;$/;"	m	struct:cmd	file:
type	sh.c	/^  int type;$/;"	m	struct:execcmd	file:
type	sh.c	/^  int type;$/;"	m	struct:listcmd	file:
type	sh.c	/^  int type;$/;"	m	struct:pipecmd	file:
type	sh.c	/^  int type;$/;"	m	struct:redircmd	file:
type	stat.h	/^  short type;  \/\/ Type of file$/;"	m	struct:stat
uart	dist/uart.c	/^static int uart;    \/\/ is there a uart?$/;"	v	file:
uart	kernel.asm	/^  uart = 1;$/;"	d
uart	uart.c	/^static int uart;    \/\/ is there a uart?$/;"	v	file:
uartgetc	dist/uart.c	/^uartgetc(void)$/;"	f	file:
uartgetc	uart.c	/^uartgetc(void)$/;"	f	file:
uartinit	dist/uart.c	/^uartinit(void)$/;"	f
uartinit	uart.c	/^uartinit(void)$/;"	f
uartintr	dist/uart.c	/^uartintr(void)$/;"	f
uartintr	uart.c	/^uartintr(void)$/;"	f
uartputc	dist/uart.c	/^uartputc(int c)$/;"	f
uartputc	uart.c	/^uartputc(int c)$/;"	f
uchar	dist/types.h	/^typedef unsigned char  uchar;$/;"	t
uchar	types.h	/^typedef unsigned char  uchar;$/;"	t
uint	cat.asm	/^uint$/;"	l
uint	dist/types.h	/^typedef unsigned int   uint;$/;"	t
uint	echo.asm	/^uint$/;"	l
uint	forktest.asm	/^uint$/;"	l
uint	getnice.asm	/^uint$/;"	l
uint	grep.asm	/^uint$/;"	l
uint	init.asm	/^uint$/;"	l
uint	kernel.asm	/^uint ticks;$/;"	l
uint	kill.asm	/^uint$/;"	l
uint	ln.asm	/^uint$/;"	l
uint	ls.asm	/^uint$/;"	l
uint	mkdir.asm	/^uint$/;"	l
uint	ps.asm	/^uint$/;"	l
uint	rm.asm	/^uint$/;"	l
uint	setnice.asm	/^uint$/;"	l
uint	sh.asm	/^uint$/;"	l
uint	stressfs.asm	/^uint$/;"	l
uint	swaptest.asm	/^uint$/;"	l
uint	test1.asm	/^uint$/;"	l
uint	test2.asm	/^uint$/;"	l
uint	testcase1.asm	/^uint$/;"	l
uint	testcase2.asm	/^uint$/;"	l
uint	types.h	/^typedef unsigned int   uint;$/;"	t
uint	usertests.asm	/^uint$/;"	l
uint	wc.asm	/^uint$/;"	l
uint	zombie.asm	/^uint$/;"	l
uio	dist/usertests.c	/^uio()$/;"	f
uio	usertests.c	/^uio()$/;"	f
uninit	dist/usertests.c	/^char uninit[10000];$/;"	v
uninit	usertests.c	/^char uninit[10000];$/;"	v
unlinkread	dist/usertests.c	/^unlinkread(void)$/;"	f
unlinkread	usertests.c	/^unlinkread(void)$/;"	f
use_lock	dist/kalloc.c	/^  int use_lock;$/;"	m	struct:__anon12	file:
use_lock	kalloc.c	/^  int use_lock;$/;"	m	struct:__anon4	file:
userinit	dist/proc.c	/^userinit(void)$/;"	f
userinit	proc.c	/^userinit(void)$/;"	f
ushort	dist/types.h	/^typedef unsigned short ushort;$/;"	t
ushort	types.h	/^typedef unsigned short ushort;$/;"	t
uva2ka	dist/vm.c	/^uva2ka(pde_t *pgdir, char *uva)$/;"	f
uva2ka	vm.c	/^uva2ka(pde_t *pgdir, char *uva)$/;"	f
va	kernel.asm	/^    va = va0 + PGSIZE;$/;"	d
va0	kernel.asm	/^    va0 = (uint)PGROUNDDOWN(va);$/;"	d
vaddr	dist/elf.h	/^  uint vaddr;$/;"	m	struct:proghdr
vaddr	elf.h	/^  uint vaddr;$/;"	m	struct:proghdr
valid	dist/file.h	/^  int valid;          \/\/ inode has been read from disk?$/;"	m	struct:inode
valid	file.h	/^  int valid;          \/\/ inode has been read from disk?$/;"	m	struct:inode
validateint	dist/usertests.c	/^validateint(int *p)$/;"	f
validateint	usertests.c	/^validateint(int *p)$/;"	f
validatetest	dist/usertests.c	/^validatetest(void)$/;"	f
validatetest	usertests.c	/^validatetest(void)$/;"	f
vector0	vectors.S	/^vector0:$/;"	l
vector1	vectors.S	/^vector1:$/;"	l
vector10	vectors.S	/^vector10:$/;"	l
vector100	vectors.S	/^vector100:$/;"	l
vector101	vectors.S	/^vector101:$/;"	l
vector102	vectors.S	/^vector102:$/;"	l
vector103	vectors.S	/^vector103:$/;"	l
vector104	vectors.S	/^vector104:$/;"	l
vector105	vectors.S	/^vector105:$/;"	l
vector106	vectors.S	/^vector106:$/;"	l
vector107	vectors.S	/^vector107:$/;"	l
vector108	vectors.S	/^vector108:$/;"	l
vector109	vectors.S	/^vector109:$/;"	l
vector11	vectors.S	/^vector11:$/;"	l
vector110	vectors.S	/^vector110:$/;"	l
vector111	vectors.S	/^vector111:$/;"	l
vector112	vectors.S	/^vector112:$/;"	l
vector113	vectors.S	/^vector113:$/;"	l
vector114	vectors.S	/^vector114:$/;"	l
vector115	vectors.S	/^vector115:$/;"	l
vector116	vectors.S	/^vector116:$/;"	l
vector117	vectors.S	/^vector117:$/;"	l
vector118	vectors.S	/^vector118:$/;"	l
vector119	vectors.S	/^vector119:$/;"	l
vector12	vectors.S	/^vector12:$/;"	l
vector120	vectors.S	/^vector120:$/;"	l
vector121	vectors.S	/^vector121:$/;"	l
vector122	vectors.S	/^vector122:$/;"	l
vector123	vectors.S	/^vector123:$/;"	l
vector124	vectors.S	/^vector124:$/;"	l
vector125	vectors.S	/^vector125:$/;"	l
vector126	vectors.S	/^vector126:$/;"	l
vector127	vectors.S	/^vector127:$/;"	l
vector128	vectors.S	/^vector128:$/;"	l
vector129	vectors.S	/^vector129:$/;"	l
vector13	vectors.S	/^vector13:$/;"	l
vector130	vectors.S	/^vector130:$/;"	l
vector131	vectors.S	/^vector131:$/;"	l
vector132	vectors.S	/^vector132:$/;"	l
vector133	vectors.S	/^vector133:$/;"	l
vector134	vectors.S	/^vector134:$/;"	l
vector135	vectors.S	/^vector135:$/;"	l
vector136	vectors.S	/^vector136:$/;"	l
vector137	vectors.S	/^vector137:$/;"	l
vector138	vectors.S	/^vector138:$/;"	l
vector139	vectors.S	/^vector139:$/;"	l
vector14	vectors.S	/^vector14:$/;"	l
vector140	vectors.S	/^vector140:$/;"	l
vector141	vectors.S	/^vector141:$/;"	l
vector142	vectors.S	/^vector142:$/;"	l
vector143	vectors.S	/^vector143:$/;"	l
vector144	vectors.S	/^vector144:$/;"	l
vector145	vectors.S	/^vector145:$/;"	l
vector146	vectors.S	/^vector146:$/;"	l
vector147	vectors.S	/^vector147:$/;"	l
vector148	vectors.S	/^vector148:$/;"	l
vector149	vectors.S	/^vector149:$/;"	l
vector15	vectors.S	/^vector15:$/;"	l
vector150	vectors.S	/^vector150:$/;"	l
vector151	vectors.S	/^vector151:$/;"	l
vector152	vectors.S	/^vector152:$/;"	l
vector153	vectors.S	/^vector153:$/;"	l
vector154	vectors.S	/^vector154:$/;"	l
vector155	vectors.S	/^vector155:$/;"	l
vector156	vectors.S	/^vector156:$/;"	l
vector157	vectors.S	/^vector157:$/;"	l
vector158	vectors.S	/^vector158:$/;"	l
vector159	vectors.S	/^vector159:$/;"	l
vector16	vectors.S	/^vector16:$/;"	l
vector160	vectors.S	/^vector160:$/;"	l
vector161	vectors.S	/^vector161:$/;"	l
vector162	vectors.S	/^vector162:$/;"	l
vector163	vectors.S	/^vector163:$/;"	l
vector164	vectors.S	/^vector164:$/;"	l
vector165	vectors.S	/^vector165:$/;"	l
vector166	vectors.S	/^vector166:$/;"	l
vector167	vectors.S	/^vector167:$/;"	l
vector168	vectors.S	/^vector168:$/;"	l
vector169	vectors.S	/^vector169:$/;"	l
vector17	vectors.S	/^vector17:$/;"	l
vector170	vectors.S	/^vector170:$/;"	l
vector171	vectors.S	/^vector171:$/;"	l
vector172	vectors.S	/^vector172:$/;"	l
vector173	vectors.S	/^vector173:$/;"	l
vector174	vectors.S	/^vector174:$/;"	l
vector175	vectors.S	/^vector175:$/;"	l
vector176	vectors.S	/^vector176:$/;"	l
vector177	vectors.S	/^vector177:$/;"	l
vector178	vectors.S	/^vector178:$/;"	l
vector179	vectors.S	/^vector179:$/;"	l
vector18	vectors.S	/^vector18:$/;"	l
vector180	vectors.S	/^vector180:$/;"	l
vector181	vectors.S	/^vector181:$/;"	l
vector182	vectors.S	/^vector182:$/;"	l
vector183	vectors.S	/^vector183:$/;"	l
vector184	vectors.S	/^vector184:$/;"	l
vector185	vectors.S	/^vector185:$/;"	l
vector186	vectors.S	/^vector186:$/;"	l
vector187	vectors.S	/^vector187:$/;"	l
vector188	vectors.S	/^vector188:$/;"	l
vector189	vectors.S	/^vector189:$/;"	l
vector19	vectors.S	/^vector19:$/;"	l
vector190	vectors.S	/^vector190:$/;"	l
vector191	vectors.S	/^vector191:$/;"	l
vector192	vectors.S	/^vector192:$/;"	l
vector193	vectors.S	/^vector193:$/;"	l
vector194	vectors.S	/^vector194:$/;"	l
vector195	vectors.S	/^vector195:$/;"	l
vector196	vectors.S	/^vector196:$/;"	l
vector197	vectors.S	/^vector197:$/;"	l
vector198	vectors.S	/^vector198:$/;"	l
vector199	vectors.S	/^vector199:$/;"	l
vector2	vectors.S	/^vector2:$/;"	l
vector20	vectors.S	/^vector20:$/;"	l
vector200	vectors.S	/^vector200:$/;"	l
vector201	vectors.S	/^vector201:$/;"	l
vector202	vectors.S	/^vector202:$/;"	l
vector203	vectors.S	/^vector203:$/;"	l
vector204	vectors.S	/^vector204:$/;"	l
vector205	vectors.S	/^vector205:$/;"	l
vector206	vectors.S	/^vector206:$/;"	l
vector207	vectors.S	/^vector207:$/;"	l
vector208	vectors.S	/^vector208:$/;"	l
vector209	vectors.S	/^vector209:$/;"	l
vector21	vectors.S	/^vector21:$/;"	l
vector210	vectors.S	/^vector210:$/;"	l
vector211	vectors.S	/^vector211:$/;"	l
vector212	vectors.S	/^vector212:$/;"	l
vector213	vectors.S	/^vector213:$/;"	l
vector214	vectors.S	/^vector214:$/;"	l
vector215	vectors.S	/^vector215:$/;"	l
vector216	vectors.S	/^vector216:$/;"	l
vector217	vectors.S	/^vector217:$/;"	l
vector218	vectors.S	/^vector218:$/;"	l
vector219	vectors.S	/^vector219:$/;"	l
vector22	vectors.S	/^vector22:$/;"	l
vector220	vectors.S	/^vector220:$/;"	l
vector221	vectors.S	/^vector221:$/;"	l
vector222	vectors.S	/^vector222:$/;"	l
vector223	vectors.S	/^vector223:$/;"	l
vector224	vectors.S	/^vector224:$/;"	l
vector225	vectors.S	/^vector225:$/;"	l
vector226	vectors.S	/^vector226:$/;"	l
vector227	vectors.S	/^vector227:$/;"	l
vector228	vectors.S	/^vector228:$/;"	l
vector229	vectors.S	/^vector229:$/;"	l
vector23	vectors.S	/^vector23:$/;"	l
vector230	vectors.S	/^vector230:$/;"	l
vector231	vectors.S	/^vector231:$/;"	l
vector232	vectors.S	/^vector232:$/;"	l
vector233	vectors.S	/^vector233:$/;"	l
vector234	vectors.S	/^vector234:$/;"	l
vector235	vectors.S	/^vector235:$/;"	l
vector236	vectors.S	/^vector236:$/;"	l
vector237	vectors.S	/^vector237:$/;"	l
vector238	vectors.S	/^vector238:$/;"	l
vector239	vectors.S	/^vector239:$/;"	l
vector24	vectors.S	/^vector24:$/;"	l
vector240	vectors.S	/^vector240:$/;"	l
vector241	vectors.S	/^vector241:$/;"	l
vector242	vectors.S	/^vector242:$/;"	l
vector243	vectors.S	/^vector243:$/;"	l
vector244	vectors.S	/^vector244:$/;"	l
vector245	vectors.S	/^vector245:$/;"	l
vector246	vectors.S	/^vector246:$/;"	l
vector247	vectors.S	/^vector247:$/;"	l
vector248	vectors.S	/^vector248:$/;"	l
vector249	vectors.S	/^vector249:$/;"	l
vector25	vectors.S	/^vector25:$/;"	l
vector250	vectors.S	/^vector250:$/;"	l
vector251	vectors.S	/^vector251:$/;"	l
vector252	vectors.S	/^vector252:$/;"	l
vector253	vectors.S	/^vector253:$/;"	l
vector254	vectors.S	/^vector254:$/;"	l
vector255	vectors.S	/^vector255:$/;"	l
vector26	vectors.S	/^vector26:$/;"	l
vector27	vectors.S	/^vector27:$/;"	l
vector28	vectors.S	/^vector28:$/;"	l
vector29	vectors.S	/^vector29:$/;"	l
vector3	vectors.S	/^vector3:$/;"	l
vector30	vectors.S	/^vector30:$/;"	l
vector31	vectors.S	/^vector31:$/;"	l
vector32	vectors.S	/^vector32:$/;"	l
vector33	vectors.S	/^vector33:$/;"	l
vector34	vectors.S	/^vector34:$/;"	l
vector35	vectors.S	/^vector35:$/;"	l
vector36	vectors.S	/^vector36:$/;"	l
vector37	vectors.S	/^vector37:$/;"	l
vector38	vectors.S	/^vector38:$/;"	l
vector39	vectors.S	/^vector39:$/;"	l
vector4	vectors.S	/^vector4:$/;"	l
vector40	vectors.S	/^vector40:$/;"	l
vector41	vectors.S	/^vector41:$/;"	l
vector42	vectors.S	/^vector42:$/;"	l
vector43	vectors.S	/^vector43:$/;"	l
vector44	vectors.S	/^vector44:$/;"	l
vector45	vectors.S	/^vector45:$/;"	l
vector46	vectors.S	/^vector46:$/;"	l
vector47	vectors.S	/^vector47:$/;"	l
vector48	vectors.S	/^vector48:$/;"	l
vector49	vectors.S	/^vector49:$/;"	l
vector5	vectors.S	/^vector5:$/;"	l
vector50	vectors.S	/^vector50:$/;"	l
vector51	vectors.S	/^vector51:$/;"	l
vector52	vectors.S	/^vector52:$/;"	l
vector53	vectors.S	/^vector53:$/;"	l
vector54	vectors.S	/^vector54:$/;"	l
vector55	vectors.S	/^vector55:$/;"	l
vector56	vectors.S	/^vector56:$/;"	l
vector57	vectors.S	/^vector57:$/;"	l
vector58	vectors.S	/^vector58:$/;"	l
vector59	vectors.S	/^vector59:$/;"	l
vector6	vectors.S	/^vector6:$/;"	l
vector60	vectors.S	/^vector60:$/;"	l
vector61	vectors.S	/^vector61:$/;"	l
vector62	vectors.S	/^vector62:$/;"	l
vector63	vectors.S	/^vector63:$/;"	l
vector64	vectors.S	/^vector64:$/;"	l
vector65	vectors.S	/^vector65:$/;"	l
vector66	vectors.S	/^vector66:$/;"	l
vector67	vectors.S	/^vector67:$/;"	l
vector68	vectors.S	/^vector68:$/;"	l
vector69	vectors.S	/^vector69:$/;"	l
vector7	vectors.S	/^vector7:$/;"	l
vector70	vectors.S	/^vector70:$/;"	l
vector71	vectors.S	/^vector71:$/;"	l
vector72	vectors.S	/^vector72:$/;"	l
vector73	vectors.S	/^vector73:$/;"	l
vector74	vectors.S	/^vector74:$/;"	l
vector75	vectors.S	/^vector75:$/;"	l
vector76	vectors.S	/^vector76:$/;"	l
vector77	vectors.S	/^vector77:$/;"	l
vector78	vectors.S	/^vector78:$/;"	l
vector79	vectors.S	/^vector79:$/;"	l
vector8	vectors.S	/^vector8:$/;"	l
vector80	vectors.S	/^vector80:$/;"	l
vector81	vectors.S	/^vector81:$/;"	l
vector82	vectors.S	/^vector82:$/;"	l
vector83	vectors.S	/^vector83:$/;"	l
vector84	vectors.S	/^vector84:$/;"	l
vector85	vectors.S	/^vector85:$/;"	l
vector86	vectors.S	/^vector86:$/;"	l
vector87	vectors.S	/^vector87:$/;"	l
vector88	vectors.S	/^vector88:$/;"	l
vector89	vectors.S	/^vector89:$/;"	l
vector9	vectors.S	/^vector9:$/;"	l
vector90	vectors.S	/^vector90:$/;"	l
vector91	vectors.S	/^vector91:$/;"	l
vector92	vectors.S	/^vector92:$/;"	l
vector93	vectors.S	/^vector93:$/;"	l
vector94	vectors.S	/^vector94:$/;"	l
vector95	vectors.S	/^vector95:$/;"	l
vector96	vectors.S	/^vector96:$/;"	l
vector97	vectors.S	/^vector97:$/;"	l
vector98	vectors.S	/^vector98:$/;"	l
vector99	vectors.S	/^vector99:$/;"	l
vectors	vectors.S	/^vectors:$/;"	l
version	dist/elf.h	/^  uint version;$/;"	m	struct:elfhdr
version	dist/mp.h	/^  uchar version;                \/\/ I\/O APIC version$/;"	m	struct:mpioapic
version	dist/mp.h	/^  uchar version;                \/\/ [14]$/;"	m	struct:mpconf
version	dist/mp.h	/^  uchar version;                \/\/ local APIC verison$/;"	m	struct:mpproc
version	elf.h	/^  uint version;$/;"	m	struct:elfhdr
version	mp.h	/^  uchar version;                \/\/ I\/O APIC version$/;"	m	struct:mpioapic
version	mp.h	/^  uchar version;                \/\/ [14]$/;"	m	struct:mpconf
version	mp.h	/^  uchar version;                \/\/ local APIC verison$/;"	m	struct:mpproc
virt	dist/vm.c	/^  void *virt;$/;"	m	struct:kmap	file:
virt	vm.c	/^  void *virt;$/;"	m	struct:kmap	file:
void	bootblock.asm	/^void$/;"	l
void	cat.asm	/^void$/;"	l
void	echo.asm	/^void$/;"	l
void	getnice.asm	/^void$/;"	l
void	grep.asm	/^void$/;"	l
void	init.asm	/^void$/;"	l
void	kernel.asm	/^void ps(){$/;"	l
void	kernel.asm	/^void swapread(char* ptr, int blkno)$/;"	l
void	kernel.asm	/^void swapwrite(char* ptr, int blkno)$/;"	l
void	kernel.asm	/^void$/;"	l
void	kill.asm	/^void$/;"	l
void	ln.asm	/^void$/;"	l
void	ls.asm	/^void$/;"	l
void	mkdir.asm	/^void$/;"	l
void	ps.asm	/^void$/;"	l
void	rm.asm	/^void$/;"	l
void	setnice.asm	/^void$/;"	l
void	sh.asm	/^void$/;"	l
void	stressfs.asm	/^void$/;"	l
void	swaptest.asm	/^void$/;"	l
void	test1.asm	/^void$/;"	l
void	test2.asm	/^void$/;"	l
void	testcase1.asm	/^void$/;"	l
void	testcase2.asm	/^void$/;"	l
void	usertests.asm	/^void$/;"	l
void	wc.asm	/^void$/;"	l
void	zombie.asm	/^void$/;"	l
w	console.c	/^  uint w;  \/\/ Write index$/;"	m	struct:__anon6	file:
w	dist/console.c	/^  uint w;  \/\/ Write index$/;"	m	struct:__anon14	file:
wait	dist/proc.c	/^wait(void)$/;"	f
wait	proc.c	/^wait(void)$/;"	f
waitdisk	bootmain.c	/^waitdisk(void)$/;"	f
waitdisk	dist/bootmain.c	/^waitdisk(void)$/;"	f
wakeup	dist/proc.c	/^wakeup(void *chan)$/;"	f
wakeup	proc.c	/^wakeup(void *chan)$/;"	f
wakeup1	dist/proc.c	/^wakeup1(void *chan)$/;"	f	file:
wakeup1	proc.c	/^wakeup1(void *chan)$/;"	f	file:
walkpgdir	dist/vm.c	/^walkpgdir(pde_t *pgdir, const void *va, int alloc)$/;"	f	file:
walkpgdir	vm.c	/^walkpgdir(pde_t *pgdir, const void *va, int alloc)$/;"	f	file:
wc	dist/wc.c	/^wc(int fd, char *name)$/;"	f
wc	wc.c	/^wc(int fd, char *name)$/;"	f
whitespace	dist/sh.c	/^char whitespace[] = " \\t\\r\\n\\v";$/;"	v
whitespace	sh.c	/^char whitespace[] = " \\t\\r\\n\\v";$/;"	v
winode	dist/mkfs.c	/^winode(uint inum, struct dinode *ip)$/;"	f
winode	mkfs.c	/^winode(uint inum, struct dinode *ip)$/;"	f
writable	dist/file.h	/^  char writable;$/;"	m	struct:file
writable	file.h	/^  char writable;$/;"	m	struct:file
write	dist/file.h	/^  int (*write)(struct inode*, char*, int);$/;"	m	struct:devsw
write	file.h	/^  int (*write)(struct inode*, char*, int);$/;"	m	struct:devsw
write_head	dist/log.c	/^write_head(void)$/;"	f	file:
write_head	log.c	/^write_head(void)$/;"	f	file:
write_log	dist/log.c	/^write_log(void)$/;"	f	file:
write_log	log.c	/^write_log(void)$/;"	f	file:
writefile	cuth	/^sub writefile($@){$/;"	s
writei	dist/fs.c	/^writei(struct inode *ip, char *src, uint off, uint n)$/;"	f
writei	fs.c	/^writei(struct inode *ip, char *src, uint off, uint n)$/;"	f
writeopen	dist/pipe.c	/^  int writeopen;  \/\/ write fd is still open$/;"	m	struct:pipe	file:
writeopen	pipe.c	/^  int writeopen;  \/\/ write fd is still open$/;"	m	struct:pipe	file:
writetest	dist/usertests.c	/^writetest(void)$/;"	f
writetest	usertests.c	/^writetest(void)$/;"	f
writetest1	dist/usertests.c	/^writetest1(void)$/;"	f
writetest1	usertests.c	/^writetest1(void)$/;"	f
wrv	kernel.asm	/^  wrv = (ushort*)P2V((0x40<<4 | 0x67));  \/\/ Warm reset vector$/;"	d
wsect	dist/mkfs.c	/^wsect(uint sec, void *buf)$/;"	f
wsect	mkfs.c	/^wsect(uint sec, void *buf)$/;"	f
x	cat.asm	/^    x = -xx;$/;"	d
x	cat.asm	/^    x = xx;$/;"	d
x	dist/umalloc.c	/^  Align x;$/;"	m	union:header	file:
x	echo.asm	/^    x = -xx;$/;"	d
x	echo.asm	/^    x = xx;$/;"	d
x	getnice.asm	/^    x = -xx;$/;"	d
x	getnice.asm	/^    x = xx;$/;"	d
x	grep.asm	/^    x = -xx;$/;"	d
x	grep.asm	/^    x = xx;$/;"	d
x	init.asm	/^    x = -xx;$/;"	d
x	init.asm	/^    x = xx;$/;"	d
x	kernel.asm	/^    x = -xx;$/;"	d
x	kernel.asm	/^    x = xx;$/;"	d
x	kill.asm	/^    x = -xx;$/;"	d
x	kill.asm	/^    x = xx;$/;"	d
x	ln.asm	/^    x = -xx;$/;"	d
x	ln.asm	/^    x = xx;$/;"	d
x	ls.asm	/^    x = -xx;$/;"	d
x	ls.asm	/^    x = xx;$/;"	d
x	mkdir.asm	/^    x = -xx;$/;"	d
x	mkdir.asm	/^    x = xx;$/;"	d
x	ps.asm	/^    x = -xx;$/;"	d
x	ps.asm	/^    x = xx;$/;"	d
x	rm.asm	/^    x = -xx;$/;"	d
x	rm.asm	/^    x = xx;$/;"	d
x	setnice.asm	/^    x = -xx;$/;"	d
x	setnice.asm	/^    x = xx;$/;"	d
x	sh.asm	/^    x = -xx;$/;"	d
x	sh.asm	/^    x = xx;$/;"	d
x	stressfs.asm	/^    x = -xx;$/;"	d
x	stressfs.asm	/^    x = xx;$/;"	d
x	swaptest.asm	/^    x = -xx;$/;"	d
x	swaptest.asm	/^    x = xx;$/;"	d
x	test1.asm	/^    x = -xx;$/;"	d
x	test1.asm	/^    x = xx;$/;"	d
x	test2.asm	/^    x = -xx;$/;"	d
x	test2.asm	/^    x = xx;$/;"	d
x	testcase1.asm	/^    x = -xx;$/;"	d
x	testcase1.asm	/^    x = xx;$/;"	d
x	testcase2.asm	/^    x = -xx;$/;"	d
x	testcase2.asm	/^    x = xx;$/;"	d
x	umalloc.c	/^  Align x;$/;"	m	union:header	file:
x	usertests.asm	/^    x = -xx;$/;"	d
x	usertests.asm	/^    x = x * 1103515245 + 12345;$/;"	d
x	usertests.asm	/^    x = xx;$/;"	d
x	wc.asm	/^    x = -xx;$/;"	d
x	wc.asm	/^    x = xx;$/;"	d
x	zombie.asm	/^    x = -xx;$/;"	d
x	zombie.asm	/^    x = xx;$/;"	d
xchecksum	dist/mp.h	/^  uchar xchecksum;              \/\/ extended table checksum$/;"	m	struct:mpconf
xchecksum	mp.h	/^  uchar xchecksum;              \/\/ extended table checksum$/;"	m	struct:mpconf
xchg	dist/x86.h	/^xchg(volatile uint *addr, uint newval)$/;"	f
xchg	x86.h	/^xchg(volatile uint *addr, uint newval)$/;"	f
xint	dist/mkfs.c	/^xint(uint x)$/;"	f
xint	mkfs.c	/^xint(uint x)$/;"	f
xlength	dist/mp.h	/^  ushort xlength;               \/\/ extended table length$/;"	m	struct:mpconf
xlength	mp.h	/^  ushort xlength;               \/\/ extended table length$/;"	m	struct:mpconf
xshort	dist/mkfs.c	/^xshort(ushort x)$/;"	f
xshort	mkfs.c	/^xshort(ushort x)$/;"	f
xticks	kernel.asm	/^  xticks = ticks;$/;"	d
year	date.h	/^  uint year;$/;"	m	struct:rtcdate
year	dist/date.h	/^  uint year;$/;"	m	struct:rtcdate
yield	dist/proc.c	/^yield(void)$/;"	f
yield	proc.c	/^yield(void)$/;"	f
zeroes	dist/mkfs.c	/^char zeroes[BSIZE];$/;"	v
zeroes	mkfs.c	/^char zeroes[BSIZE];$/;"	v
